<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>payton.scene.geometry.base API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{margin:40px auto;max-width:1000px;display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>payton.scene.geometry.base</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># pylama:ignore=C901
import numpy as np  # type: ignore
import ctypes
import logging
from typing import Union, List, Dict, Type, Any, Iterator, Optional
from copy import deepcopy

from OpenGL.GL import (
    glDeleteVertexArrays,
    glIsVertexArray,
    glBindVertexArray,
    GL_LINE,
    GL_FILL,
    GL_TRIANGLES,
    glPolygonMode,
    GL_LINE_STRIP,
    glGenVertexArrays,
    glGenBuffers,
    GL_ARRAY_BUFFER,
    glEnableVertexAttribArray,
    glVertexAttribPointer,
    GL_FLOAT,
    GL_STATIC_DRAW,
    GL_DYNAMIC_DRAW,
    glBindBuffer,
    glBufferData,
    glBufferSubData,
    GL_ELEMENT_ARRAY_BUFFER,
    glDeleteBuffers,
    GL_POINT,
    GL_POINTS,
    GL_FRONT_AND_BACK,
    glDrawElements,
    GL_UNSIGNED_INT,
)

from payton.math.geometry import raycast_sphere_intersect
from payton.math.vector import (
    vector_transform,
    distance,
    scale_vector,
    add_vectors,
    sub_vector,
    cross_product,
    normalize_vector,
)
from payton.math.matrix import create_rotation_matrix
from payton.scene.material import Material, SOLID, POINTS, WIREFRAME
from payton.scene.shader import Shader
from payton.scene.light import Light
from payton.scene.types import VList, IList


class Object(object):
    &#34;&#34;&#34;Main Payton Object.

    This is an abstract class to define common properties and methods between
    Mesh / Cube / Sphere/ Shape2D / PointCloud, etc.

    Objects are not actually built as 3D vertex arrays until they are rendered.
    Render function calls `build` function if needed. Build function creates
    the OpenGL Vertex Array Object. VAO is static data so, once the object
    is built, changing vertices or indices will not take effect at the scene.

    You need to call `payton.scene.geometry.base.Object.build` function to
    refresh Vertex Array Object.

    OpenGL can not magically extend a memory buffer, so for every new vertices
    added to the object, OpenGL needs to re-create the buffer area. This is
    not an efficitient technique if number of vertices increase in time.
    As a result Payton allocates buffer for 500 vertices in the beginning and
    uses part of it. If the object exceeds 500 vertices, a new buffer is
    created with 500 vertices more, copies existing vertices to the new
    buffer and the old buffer is deleted.

    &#34;&#34;&#34;

    def __init__(
        self,
        static=True,
        name=&#34;&#34;,
        visible=True,
        track_motion=False,
        **args: Any,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the basic object properties.

        Properties:
          children: Children hash for object. Each child object follows parent
                    object. They take their parent object as origin and their
                    coordinate system is relative to their parent. This
                    behaviour resembles stars, planets and their moons.
          material: Material definitions of the object.
          matrix: Matrix definition of the object. This is a 4x4 Uniform Matrix
                  but data is set as an array for easier transformations. First
                  4 decimals are &#34;Left&#34; vector, second 4 are &#34;Direction&#34;, third
                  4 are &#34;Up&#34; and last four decimals are &#34;Position&#34; vectors.

        Args:
          track_motion: Track object motion (default: false). Object tracking
                        is time independent. It just saves the object matrix
                        for every change. Uses matrix position for drawing the
                        motion path.
          static: (Default `True`) Indicates if object geometry is expected
                  to be changed in the future. If object is not static, then
                  its&#39; vertex buffer object references and vertex informations
                  will not be deleted to be used for future reference.
          name: Name of the object (optional, default &#39;&#39;) Note that, when
                object gets added to a Scene with a name, Scene will assign
                that name to the object, overwriting any existing name of the
                object.
          visible: Is this object visible at the scene, default: `True`. To
                   hide an object, you can call `object.hide()` and to show
                   it again use: `object.show()`
        &#34;&#34;&#34;
        self.children: Dict[str, Object] = {}
        self.material: Material = Material()
        self.static = static
        self.name = name
        self._visible = visible
        self.matrix: VList = [
            [1.0, 0.0, 0.0, 0.0],
            [0.0, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.0],
            [0.0, 0.0, 0.0, 1.0],
        ]
        # Object vertices. Each vertex has 3 decimals (X, Y, Z). Vertices
        # are continuous. [X, Y, Z, X, Y, Z, X, Y, Z, X, ... ]
        #                  -- 1 --  -- 2 --  -- 3 --  -- 4 --

        self._vertices: VList = []  # Object vertex list
        self._normals: List[
            List[float]
        ] = []  # Vertex normals, 1 normal coordinate for 1 Vertex
        self._texcoords: List[
            List[float]
        ] = []  # Texture coordinates, 1 coordinate per Vertex
        self._vertex_colors: List[
            List[float]
        ] = []  # per-vertex colors, optional.
        self._has_vertex_colors: bool = False  # flag for using vertex colors

        # Vertices do not mean anything unless we define how to use them.
        # For instance, 3 vertices make a triangle or 2 vertices define a line
        # order of vertices are defined in self._indices.
        self._indices: IList = []
        self._vertex_count: int = 0  # Number of vertices to report to OpenGL.

        # This is an optimization technique for dynamic objects where there are
        # increasing number of vertices. We allocate some buffer before-hand
        # and if we fill all of it, we resize it.
        self._buffer_size: float = 500 * 12
        self._t_buffer_size: float = 500 * 8
        self._model_matrix: np.ndarray = []  # Model matrix.
        # Check if buffer size allocated for the object has changed.
        self._buffer_size_changed: bool = True
        self._t_buffer_size_changed: bool = True

        # Track object motion
        self.track_motion = track_motion
        # Motion path, stores every matrix change.
        self._motion_path: List[VList] = []

        if not isinstance(self, Line):
            # _motion_path_line is used to display the motion path in scene
            self._motion_path_line = Line()
        self._previous_matrix: Union[np.ndarray, None] = None

        # For raycast tests - bounding radius is the radius of the bounding
        # sphere.
        self._bounding_radius: float = 0
        self._bounding_box: VList = []
        self._selected: bool = False

        # Vertex Array Object pointer
        self._vao: int = -1
        self._needs_update: bool = False  # Object geometry has changed.
        self._hit: bool = False
        &#34;&#34;&#34; I personally prefer not to delete vbos as in some cases I need to
        # refer to VBOs to update them partially. I don&#39;t want to loose
        # their reference and make things harder. I am not naming them
        # anyways.
        &#34;&#34;&#34;
        self._vbos: List[int] = []

    def refresh(self) -&gt; None:
        &#34;&#34;&#34;Refresh object

        Forces object to get built again
        &#34;&#34;&#34;
        self._needs_update = True

    @property
    def direction(self) -&gt; List[float]:
        &#34;&#34;&#34;Get direction vector from Matrix&#34;&#34;&#34;
        return self.matrix[1][:3]

    @direction.setter
    def direction(self, v: List[float]):
        &#34;&#34;&#34;Set direction vector of Matrix

        Attention! This needs to be a unit vector!
        &#34;&#34;&#34;
        if len(v) &lt; 3:
            raise Exception(&#34;Direction needs 3 components (x,y,z)&#34;)
        self.matrix[1][0] = v[0]
        self.matrix[1][1] = v[1]
        self.matrix[1][2] = v[2]
        left = cross_product(self.matrix[1], self.matrix[2])
        left += [0]
        self.matrix[0] = left
        up = cross_product(self.matrix[0], self.matrix[1])
        up += [0]
        self.matrix[2] = up

    def direct_to(self, v: List[float]):
        &#34;&#34;&#34;Direct the objects forward towards given point vector&#34;&#34;&#34;
        diff = sub_vector(v, self.position)
        diff = normalize_vector(diff)
        self.direction = diff

    def rotate_around_z(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Rotate around Z Axis

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([0, 0, 1], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def rotate_around_x(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Pitch - Rotate around X axis

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([1, 0, 0], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def rotate_around_y(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Roll - Rotate around Y Axis (Direction)

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([0, 1, 0], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def select(self, start: np.ndarray, vector: np.ndarray) -&gt; bool:
        &#34;&#34;&#34;Select test for object using bounding Sphere.

        This method is not 100% accurate as it is based on a rough
        assumption. Sphere area will be larger than actual object.

        If you want to have a more accurate way to handle this, try
        using raycast triangle intersect

        Args:
          start: Starting point of the ray (such as eye position)
          vector: Ray direction. This is not the end point of a line!
                  This is a unit vector showing the ray direction.
        &#34;&#34;&#34;
        self._selected = raycast_sphere_intersect(
            start,
            vector,
            np.array(self.matrix[3], dtype=np.float32),
            self._bounding_radius,
        )

        for obj in self.children:
            x = self.children[obj].select(start, vector)
            if not self._selected and x:
                self._selected = True

        return self._selected

    def destroy(self) -&gt; bool:
        &#34;&#34;&#34;
        Destroy objects self.

        Returns:
            bool: `True` on successful destroy of `self`.
        &#34;&#34;&#34;
        if self.has_vao:
            glDeleteVertexArrays(1, [self._vao])
            self._vao = -1
        return True

    def step_back(self, steps: int = 1) -&gt; bool:
        &#34;&#34;&#34;Go back N step in time

        This is suitable for solving collisions and getting a step back.
        On the other hand, this function requires `track_motion` to be
        True.

        Args:
          steps: Number of steps to go back. (Default = 1)

        Returns:
          bool: If step back is successful
        &#34;&#34;&#34;
        steps += 1
        if not self.track_motion:
            raise Exception(&#34;track_motion should be True&#34;)
        if len(self._motion_path) &lt; steps:
            return False

        self.matrix = self._motion_path[-steps]
        del self._motion_path[-steps + 1 :]
        return True

    def forward(self, distance: float) -&gt; None:
        &#34;&#34;&#34;Move object forward

        This method calculates to motion path according to direction
        of the object&#39;s matrix. `self.matrix[1]` indicates the direction.

        So matrix position gets updated according to direction * distance
        &#34;&#34;&#34;
        diff = scale_vector(self.matrix[1], distance)
        self.matrix[3] = add_vectors(self.matrix[3], diff)
        self.matrix[3][3] = 1.0

    def update_matrix(
        self, parent_matrix: Optional[np.ndarray] = None
    ) -&gt; None:
        &#34;&#34;&#34;Update matrix

        Turn object matrix into numpy array.

        Args:
          parent_matrix: Parent objects matrix
        &#34;&#34;&#34;
        # Turn matrix into numpy array. Numpy arrays are C Type arrays
        # suitable for OpenGL Pipeline
        self._model_matrix = np.array(self.matrix, dtype=np.float32)

        # When there is a parent object, child object follows parents matrix
        if parent_matrix is not None and len(parent_matrix) &gt; 0:
            self._model_matrix = parent_matrix.dot(self._model_matrix)

    def track(self) -&gt; bool:
        &#34;&#34;&#34;
        Track object motion

        Returns:
            bool: `True` on successful tracking of `self`.
        &#34;&#34;&#34;
        if not self.track_motion:
            return False
        if self._previous_matrix == self.matrix[3]:
            return True

        # Add the new matrix to motion path records
        self._motion_path.append(deepcopy(self.matrix))
        # Add the matrix position to motion math line for visualisation
        if self._motion_path_line is not None:
            self._motion_path_line.append(
                [[self.matrix[3][0], self.matrix[3][1], self.matrix[3][2]]]
            )

        # Python trick here! need to .copy or it will pass reference.
        self._previous_matrix = self.matrix[3].copy()
        return True

    @property
    def has_vao(self) -&gt; bool:
        &#34;&#34;&#34;Check if this object has an active Vertex Array Object

        Returns:
            bool: `True` if `self` has an active Vertex Array Object.
        &#34;&#34;&#34;
        return self._vao &gt; -1

    @property
    def visible(self) -&gt; bool:
        &#34;&#34;&#34;Check if object is visible

        Returns:
          bool: `True` if visible.
        &#34;&#34;&#34;
        return self._visible

    def show(self) -&gt; None:
        self._visible = True

    def hide(self) -&gt; None:
        self._visible = False

    def render(
        self,
        proj: np.ndarray,
        view: np.ndarray,
        lights: List[Light],
        parent_matrix: Optional[np.ndarray] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Virtual function for rendering the object. Some objects can overwrite
        this function.

        Args:
          proj: Camera projection matrix.
          view: Camera location/view matrix.
          lights: Light objects in the scene
          parent_matrix: Parent matrix is the matrix of the parent. Parent can
                         be the scene itself or another object. In case of
                         another object, object will position itself relative
                         to its parent object.
        &#34;&#34;&#34;
        if not self._visible:
            return

        if not self.has_vao or self._needs_update:
            self.build()

        self.update_matrix(parent_matrix=parent_matrix)
        self.track()

        if self._vertex_count == 0:
            # dummy object, render children and leave
            # render children
            for child in self.children:
                self.children[child].render(
                    proj, view, lights, self._model_matrix
                )

            return

        # Material shading mode.
        mode = None
        if self._has_vertex_colors:
            mode = Shader.PER_VERTEX_COLOR

        self.material.render(proj, view, self._model_matrix, lights, mode)

        # Actual rendering
        if glIsVertexArray(self._vao):
            glBindVertexArray(self._vao)
            pmode = GL_LINE
            primitive = GL_LINE_STRIP
            if self.material.display == SOLID:
                pmode = GL_FILL
                primitive = GL_TRIANGLES
            if self.material.display == POINTS:
                pmode = GL_POINT
                primitive = GL_POINTS
            glPolygonMode(GL_FRONT_AND_BACK, pmode)

            glDrawElements(
                primitive,
                self._vertex_count,
                GL_UNSIGNED_INT,
                ctypes.c_void_p(0),
            )
            if pmode != GL_FILL:
                glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
            glBindVertexArray(0)

        # End using the shader program.
        self.material.end()

        # Render motion path
        if self.track_motion:
            self._motion_path_line.render(proj, view, lights, parent_matrix)

        # render children
        for child in self.children:
            self.children[child].render(proj, view, lights, self._model_matrix)

    @property
    def position(self) -&gt; List[float]:
        &#34;&#34;&#34;Get position of the Object.

        Return matrix position list

        Returns:
          List[float]
        &#34;&#34;&#34;
        return self.matrix[3][:3]

    @position.setter
    def position(self, pos: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Shortcut function for explicitly modifying matrix indices.

        Basically just sets x, y, z of the matrix. Does not change its
        direction or up vectors.

        Args:
          pos: Position list ([x, y, z])
        &#34;&#34;&#34;
        if len(pos) == 2:
            pos = [pos[0], pos[1], 0.0]
        self.matrix[3][0] = pos[0]
        self.matrix[3][1] = pos[1]
        self.matrix[3][2] = pos[2]

    def add_child(self, name: str, obj: Type[&#34;Object&#34;]) -&gt; bool:
        &#34;&#34;&#34;Add child to this object.

        In a basic example:

            .. include:: ../../../examples/basics/05_children.py

        Args:
          name: Name of the object, must be unique within its siblings
          obj: Object. Must be an instance of
               `payton.scene.geometry.base.Object`

        Returns:
          bool: False in case of an error
        &#34;&#34;&#34;
        if name in self.children:
            logging.error(f&#34;Name {name} exists in object children&#34;)
            return False
        if not isinstance(obj, Object):
            logging.error(&#34;Object type is not valid&#34;)
            return False
        self.children[name] = obj
        return True

    def to_absolute(self, coordinates: List[float]) -&gt; List[float]:
        &#34;&#34;&#34;
        Return local coordinates (tuple, list) into absolute coordinates in
        space.

        Args:
          coordinates: List[float] (x, y, z)

        Returns:
          List[float] (x&#39;, y&#39;, z&#39;)
        &#34;&#34;&#34;
        return vector_transform(coordinates, self.matrix)

    def absolute_vertices(self) -&gt; Iterator[List[float]]:
        &#34;&#34;&#34;Return a map of all local vertices as absolute coordinates.

        Imagine that object B is a child of object A. In this case, B will
        always stand (follow) relative to A. If you want to know the exact
        world coordinates of all vertices in B, this method will return them.

        **Important!** This is a costly operation so use with caution!

        Returns:
          map(List[List[float]])
        &#34;&#34;&#34;
        return map(lambda v: self.to_absolute(v), self._vertices)

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle wireframe view of the Object&#34;&#34;&#34;
        d = self.material.display
        d += 1
        d = d % 3

        self.material.display = d
        for n in self.children:
            self.children[n].toggle_wireframe()

    def _calc_bounds(self) -&gt; float:
        &#34;&#34;&#34;Calculate the bounding sphere radius

        Returns:
          float
        &#34;&#34;&#34;

        bmin: Optional[List[float]] = None
        bmax: Optional[List[float]] = None
        x = [v[0] for v in self._vertices]
        y = [v[1] for v in self._vertices]
        z = [v[2] for v in self._vertices]
        bmin = [min(x), min(y), min(z)]
        bmax = [max(x), max(y), max(z)]
        self._bounding_radius = distance(bmax, bmin) / 2.0

        self._bounding_box = [bmin, bmax]
        return self._bounding_radius

    @property
    def bounding_radius(self) -&gt; float:
        &#34;&#34;&#34;Return bounding radius

        This property function *WILL NOT* update the previously
        calculated value. If you add vertices to the object, you must call
        `payton.scene.geometry.base.Object.refresh` function to get radius
        and the whole object updated.

        Returns:
          float
        &#34;&#34;&#34;

        if self._bounding_radius &gt; 0:
            return self._bounding_radius
        return self._calc_bounds()

    def build(self) -&gt; bool:
        &#34;&#34;&#34;
        Build OpenGL Vertex Array for the object

        This function gets automatically called if `self._vao` does not
        exists in the first render cycle. Once the vba is built,
        geometry changes or material display mode changes will not be
        automatically effected. So, in every geometry or display mode
        change, a `build` call is necessary.

        If `self.static` is `True`, then the system assumes that another update
        call is not expected, thus frees `_normals`, `_textcoords`,
        `_vertices` and `_indices` lists to free memory.
        So in this case, calling `build` function twice will result in
        an invisible object (will not be drawn).

        Returns:
          bool
        &#34;&#34;&#34;
        if len(self._indices) == 0:
            return False

        # If we don&#39;t have a VAO yet, we need to create one
        if not self.has_vao:
            # Generate Vertex Array
            self._vao = glGenVertexArrays(1)
            # We need 5 buffers (vertex, normal, texcoord, color, indices)
            self._vbos = glGenBuffers(5)
            glBindVertexArray(self._vao)
            # Material shader must be built when there is an active binding
            # to vertex array
            self.material.build_shader()
        else:
            # Ok, we already have vertex array object, just bind it to modify
            glBindVertexArray(self._vao)

        # Turn python arrays into C type arrays using Numpy.
        # This is required for OpenGL. Python memory model is a bit
        # different than raw memory model of C (OpenGL)
        vertices = np.array(self._vertices, dtype=np.float32).flatten()
        normals = np.array(self._normals, dtype=np.float32).flatten()
        texcoords = np.array(self._texcoords, dtype=np.float32).flatten()
        colors = np.array(self._vertex_colors, dtype=np.float32).flatten()
        indices = np.array(self._indices, dtype=np.int32).flatten()
        self._calc_bounds()

        # OpenGL allocates buffers in different mechanisms between
        # STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL
        # will assume that object buffer will not change and allocate it in a
        # more suitable way.
        draw = GL_STATIC_DRAW
        if not self.static:
            draw = GL_DYNAMIC_DRAW

        # Buffer overflow, we need more space.
        if self._buffer_size &lt; vertices.nbytes:
            self._buffer_size = vertices.nbytes
            self._buffer_size_changed = True
        if self._t_buffer_size &lt; texcoords.nbytes:
            self._t_buffer_size = texcoords.nbytes
            self._t_buffer_size_changed = True

        # Bind Vertices
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[0])
        glEnableVertexAttribArray(0)  # shader layout location
        glVertexAttribPointer(0, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        if self._buffer_size_changed:
            # glBufferData creates a new data area
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, vertices, draw)
        else:
            # glBufferSubData just replaces memory area in buffer so it is
            # much more efficient way to handle things.
            glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.nbytes, vertices)

        # Bind Normals
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[1])
        glEnableVertexAttribArray(1)  # shader layout location
        glVertexAttribPointer(1, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        if self._buffer_size_changed:
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, normals, draw)
        else:
            glBufferSubData(GL_ARRAY_BUFFER, 0, normals.nbytes, normals)

        # Bind TexCoords
        if len(self._texcoords) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[2])
            glEnableVertexAttribArray(2)  # shader layout location
            glVertexAttribPointer(2, 2, GL_FLOAT, False, 0, ctypes.c_void_p(0))
            if self._t_buffer_size_changed:
                glBufferData(
                    GL_ARRAY_BUFFER, self._t_buffer_size, texcoords, draw
                )
            else:
                glBufferSubData(
                    GL_ARRAY_BUFFER, 0, texcoords.nbytes, texcoords
                )

        # Bind Vertex Colors
        if len(self._vertex_colors) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[4])
            glEnableVertexAttribArray(3)  # shader layout location
            glVertexAttribPointer(3, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
            self._has_vertex_colors = True
            if self._buffer_size_changed:
                glBufferData(GL_ARRAY_BUFFER, self._buffer_size, colors, draw)
            else:
                glBufferSubData(GL_ARRAY_BUFFER, 0, colors.nbytes, colors)

        self._buffer_size_changed = False
        self._t_buffer_size_changed = False

        # Bind Indices
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self._vbos[3])
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.nbytes, indices, draw)
        self._vertex_count = len(indices)

        glBindVertexArray(0)
        glBindBuffer(GL_ARRAY_BUFFER, 0)

        if self.static:
            # we can clear this data to free some more memory
            glDeleteBuffers(4, self._vbos)
            self._vbos = []

        self._needs_update = False
        return True


class Line(Object):
    &#34;&#34;&#34;Line object

    Exceptionally, due to hard reference for motion path feature, this class
    is defined in base.py instead of line.py
    &#34;&#34;&#34;

    def __init__(
        self,
        vertices: Optional[VList] = None,
        color: Optional[List[float]] = None,
        **args: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Iniitalize line

        Args:
          vertices: Vertices array for list of points.
          color: Color of the line

        Example use case:

            .. include:: ../../../examples/basics/17_line.py
        &#34;&#34;&#34;
        super().__init__(**args)
        self._vertices: VList = [] if vertices is None else vertices
        self.material.color = [1.0, 1.0, 1.0] if color is None else color

        self.static: bool = False  # Do not clear the vertices each time.
        self.material.display = WIREFRAME
        self.build_lines()

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle Wireframe overwrite to disable mode change&#34;&#34;&#34;
        pass

    def append(self, vertices: VList) -&gt; None:
        &#34;&#34;&#34;Append vertex or vertices to line.

        Args:
          vertices: Vertex array of points.
        &#34;&#34;&#34;

        diff = len(vertices)  # Number of vertices added
        last_index = len(self._vertices)
        self._vertices += vertices

        self._texcoords += [[0, 0]] * diff
        self._normals += [[0, 0, 0]] * diff
        self._vertex_count = len(self._vertices)
        indices = list(map(lambda x: x + last_index, range(diff)))
        self._indices.extend([indices])

        if self.has_vao:
            self._needs_update = True

    def build_lines(
        self,
        vertices: Optional[VList] = None,
        color: Optional[List[float]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Build lines

        Build line vertex array object.
        &#34;&#34;&#34;
        if vertices is not None:
            self._vertices = vertices
        if color is not None:
            self.material.color = color
        self._vertex_count = len(self._vertices)
        for i in range(self._vertex_count - 1):
            self._indices.append([i, i + 1])

        for i in range(self._vertex_count):
            self._normals.append([0, 0, 0])
            self._texcoords.append([0, 0])

        if self.has_vao:
            # This is a dynamic object, destroying the object is not a good
            # idea so we just update the buffer here.
            self.build()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="payton.scene.geometry.base.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
<span>(</span><span>vertices=None, color=None, **args)</span>
</code></dt>
<dd>
<section class="desc"><p>Line object</p>
<p>Exceptionally, due to hard reference for motion path feature, this class
is defined in base.py instead of line.py</p>
<p>Iniitalize line</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertices array for list of points.</dd>
<dt><strong><code>color</code></strong></dt>
<dd>Color of the line</dd>
</dl>
<p>Example use case:</p>
<pre><code>from payton.scene import Scene
from payton.scene.geometry import Line


scene = Scene()

line = Line(
    vertices=[
        [0, 0, 0],
        [0, 0, 1],
        [0.5, 0, 1.5],
        [1, 0, 1],
        [0, 0, 1],
        [1, 0, 0],
        [0, 0, 0],
        [1, 0, 1],
        [1, 0, 0],
    ]
)

scene.add_object("line", line)
scene.run()
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Line(Object):
    &#34;&#34;&#34;Line object

    Exceptionally, due to hard reference for motion path feature, this class
    is defined in base.py instead of line.py
    &#34;&#34;&#34;

    def __init__(
        self,
        vertices: Optional[VList] = None,
        color: Optional[List[float]] = None,
        **args: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Iniitalize line

        Args:
          vertices: Vertices array for list of points.
          color: Color of the line

        Example use case:

            .. include:: ../../../examples/basics/17_line.py
        &#34;&#34;&#34;
        super().__init__(**args)
        self._vertices: VList = [] if vertices is None else vertices
        self.material.color = [1.0, 1.0, 1.0] if color is None else color

        self.static: bool = False  # Do not clear the vertices each time.
        self.material.display = WIREFRAME
        self.build_lines()

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle Wireframe overwrite to disable mode change&#34;&#34;&#34;
        pass

    def append(self, vertices: VList) -&gt; None:
        &#34;&#34;&#34;Append vertex or vertices to line.

        Args:
          vertices: Vertex array of points.
        &#34;&#34;&#34;

        diff = len(vertices)  # Number of vertices added
        last_index = len(self._vertices)
        self._vertices += vertices

        self._texcoords += [[0, 0]] * diff
        self._normals += [[0, 0, 0]] * diff
        self._vertex_count = len(self._vertices)
        indices = list(map(lambda x: x + last_index, range(diff)))
        self._indices.extend([indices])

        if self.has_vao:
            self._needs_update = True

    def build_lines(
        self,
        vertices: Optional[VList] = None,
        color: Optional[List[float]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Build lines

        Build line vertex array object.
        &#34;&#34;&#34;
        if vertices is not None:
            self._vertices = vertices
        if color is not None:
            self.material.color = color
        self._vertex_count = len(self._vertices)
        for i in range(self._vertex_count - 1):
            self._indices.append([i, i + 1])

        for i in range(self._vertex_count):
            self._normals.append([0, 0, 0])
            self._texcoords.append([0, 0])

        if self.has_vao:
            # This is a dynamic object, destroying the object is not a good
            # idea so we just update the buffer here.
            self.build()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.base.Object" href="#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.base.Line.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Append vertex or vertices to line.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertex array of points.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def append(self, vertices: VList) -&gt; None:
    &#34;&#34;&#34;Append vertex or vertices to line.

    Args:
      vertices: Vertex array of points.
    &#34;&#34;&#34;

    diff = len(vertices)  # Number of vertices added
    last_index = len(self._vertices)
    self._vertices += vertices

    self._texcoords += [[0, 0]] * diff
    self._normals += [[0, 0, 0]] * diff
    self._vertex_count = len(self._vertices)
    indices = list(map(lambda x: x + last_index, range(diff)))
    self._indices.extend([indices])

    if self.has_vao:
        self._needs_update = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Line.build_lines"><code class="name flex">
<span>def <span class="ident">build_lines</span></span>(<span>self, vertices=None, color=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Build lines</p>
<p>Build line vertex array object.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build_lines(
    self,
    vertices: Optional[VList] = None,
    color: Optional[List[float]] = None,
) -&gt; None:
    &#34;&#34;&#34;Build lines

    Build line vertex array object.
    &#34;&#34;&#34;
    if vertices is not None:
        self._vertices = vertices
    if color is not None:
        self.material.color = color
    self._vertex_count = len(self._vertices)
    for i in range(self._vertex_count - 1):
        self._indices.append([i, i + 1])

    for i in range(self._vertex_count):
        self._normals.append([0, 0, 0])
        self._texcoords.append([0, 0])

    if self.has_vao:
        # This is a dynamic object, destroying the object is not a good
        # idea so we just update the buffer here.
        self.build()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Line.toggle_wireframe"><code class="name flex">
<span>def <span class="ident">toggle_wireframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Toggle Wireframe overwrite to disable mode change</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def toggle_wireframe(self) -&gt; None:
    &#34;&#34;&#34;Toggle Wireframe overwrite to disable mode change&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.base.Object" href="#payton.scene.geometry.base.Object">Object</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.base.Object.absolute_vertices" href="#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.add_child" href="#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.bounding_radius" href="#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.build" href="#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.destroy" href="#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direct_to" href="#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direction" href="#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.forward" href="#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.has_vao" href="#payton.scene.geometry.base.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.position" href="#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.refresh" href="#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.render" href="#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_x" href="#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_y" href="#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_z" href="#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.select" href="#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.step_back" href="#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.to_absolute" href="#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.track" href="#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.update_matrix" href="#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.visible" href="#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.base.Object"><code class="flex name class">
<span>class <span class="ident">Object</span></span>
<span>(</span><span>static=True, name='', visible=True, track_motion=False, **args)</span>
</code></dt>
<dd>
<section class="desc"><p>Main Payton Object.</p>
<p>This is an abstract class to define common properties and methods between
Mesh / Cube / Sphere/ Shape2D / PointCloud, etc.</p>
<p>Objects are not actually built as 3D vertex arrays until they are rendered.
Render function calls <code>build</code> function if needed. Build function creates
the OpenGL Vertex Array Object. VAO is static data so, once the object
is built, changing vertices or indices will not take effect at the scene.</p>
<p>You need to call <a title="payton.scene.geometry.base.Object.build" href="#payton.scene.geometry.base.Object.build"><code>Object.build()</code></a> function to
refresh Vertex Array Object.</p>
<p>OpenGL can not magically extend a memory buffer, so for every new vertices
added to the object, OpenGL needs to re-create the buffer area. This is
not an efficitient technique if number of vertices increase in time.
As a result Payton allocates buffer for 500 vertices in the beginning and
uses part of it. If the object exceeds 500 vertices, a new buffer is
created with 500 vertices more, copies existing vertices to the new
buffer and the old buffer is deleted.</p>
<p>Initialize the basic object properties.</p>
<h2 id="properties">Properties</h2>
<dl>
<dt><strong><code>children</code></strong></dt>
<dd>Children hash for object. Each child object follows parent
object. They take their parent object as origin and their
coordinate system is relative to their parent. This
behaviour resembles stars, planets and their moons.</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material definitions of the object.</dd>
<dt><strong><code>matrix</code></strong></dt>
<dd>Matrix definition of the object. This is a 4x4 Uniform Matrix
but data is set as an array for easier transformations. First
4 decimals are "Left" vector, second 4 are "Direction", third
4 are "Up" and last four decimals are "Position" vectors.</dd>
</dl>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track_motion</code></strong></dt>
<dd>Track object motion (default: false). Object tracking
is time independent. It just saves the object matrix
for every change. Uses matrix position for drawing the
motion path.</dd>
<dt><strong><code>static</code></strong></dt>
<dd>(Default <code>True</code>) Indicates if object geometry is expected
to be changed in the future. If object is not static, then
its' vertex buffer object references and vertex informations
will not be deleted to be used for future reference.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the object (optional, default '') Note that, when
object gets added to a Scene with a name, Scene will assign
that name to the object, overwriting any existing name of the
object.</dd>
<dt><strong><code>visible</code></strong></dt>
<dd>Is this object visible at the scene, default: <code>True</code>. To
hide an object, you can call <code>object.hide()</code> and to show
it again use: <code>object.show()</code></dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Object(object):
    &#34;&#34;&#34;Main Payton Object.

    This is an abstract class to define common properties and methods between
    Mesh / Cube / Sphere/ Shape2D / PointCloud, etc.

    Objects are not actually built as 3D vertex arrays until they are rendered.
    Render function calls `build` function if needed. Build function creates
    the OpenGL Vertex Array Object. VAO is static data so, once the object
    is built, changing vertices or indices will not take effect at the scene.

    You need to call `payton.scene.geometry.base.Object.build` function to
    refresh Vertex Array Object.

    OpenGL can not magically extend a memory buffer, so for every new vertices
    added to the object, OpenGL needs to re-create the buffer area. This is
    not an efficitient technique if number of vertices increase in time.
    As a result Payton allocates buffer for 500 vertices in the beginning and
    uses part of it. If the object exceeds 500 vertices, a new buffer is
    created with 500 vertices more, copies existing vertices to the new
    buffer and the old buffer is deleted.

    &#34;&#34;&#34;

    def __init__(
        self,
        static=True,
        name=&#34;&#34;,
        visible=True,
        track_motion=False,
        **args: Any,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the basic object properties.

        Properties:
          children: Children hash for object. Each child object follows parent
                    object. They take their parent object as origin and their
                    coordinate system is relative to their parent. This
                    behaviour resembles stars, planets and their moons.
          material: Material definitions of the object.
          matrix: Matrix definition of the object. This is a 4x4 Uniform Matrix
                  but data is set as an array for easier transformations. First
                  4 decimals are &#34;Left&#34; vector, second 4 are &#34;Direction&#34;, third
                  4 are &#34;Up&#34; and last four decimals are &#34;Position&#34; vectors.

        Args:
          track_motion: Track object motion (default: false). Object tracking
                        is time independent. It just saves the object matrix
                        for every change. Uses matrix position for drawing the
                        motion path.
          static: (Default `True`) Indicates if object geometry is expected
                  to be changed in the future. If object is not static, then
                  its&#39; vertex buffer object references and vertex informations
                  will not be deleted to be used for future reference.
          name: Name of the object (optional, default &#39;&#39;) Note that, when
                object gets added to a Scene with a name, Scene will assign
                that name to the object, overwriting any existing name of the
                object.
          visible: Is this object visible at the scene, default: `True`. To
                   hide an object, you can call `object.hide()` and to show
                   it again use: `object.show()`
        &#34;&#34;&#34;
        self.children: Dict[str, Object] = {}
        self.material: Material = Material()
        self.static = static
        self.name = name
        self._visible = visible
        self.matrix: VList = [
            [1.0, 0.0, 0.0, 0.0],
            [0.0, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.0],
            [0.0, 0.0, 0.0, 1.0],
        ]
        # Object vertices. Each vertex has 3 decimals (X, Y, Z). Vertices
        # are continuous. [X, Y, Z, X, Y, Z, X, Y, Z, X, ... ]
        #                  -- 1 --  -- 2 --  -- 3 --  -- 4 --

        self._vertices: VList = []  # Object vertex list
        self._normals: List[
            List[float]
        ] = []  # Vertex normals, 1 normal coordinate for 1 Vertex
        self._texcoords: List[
            List[float]
        ] = []  # Texture coordinates, 1 coordinate per Vertex
        self._vertex_colors: List[
            List[float]
        ] = []  # per-vertex colors, optional.
        self._has_vertex_colors: bool = False  # flag for using vertex colors

        # Vertices do not mean anything unless we define how to use them.
        # For instance, 3 vertices make a triangle or 2 vertices define a line
        # order of vertices are defined in self._indices.
        self._indices: IList = []
        self._vertex_count: int = 0  # Number of vertices to report to OpenGL.

        # This is an optimization technique for dynamic objects where there are
        # increasing number of vertices. We allocate some buffer before-hand
        # and if we fill all of it, we resize it.
        self._buffer_size: float = 500 * 12
        self._t_buffer_size: float = 500 * 8
        self._model_matrix: np.ndarray = []  # Model matrix.
        # Check if buffer size allocated for the object has changed.
        self._buffer_size_changed: bool = True
        self._t_buffer_size_changed: bool = True

        # Track object motion
        self.track_motion = track_motion
        # Motion path, stores every matrix change.
        self._motion_path: List[VList] = []

        if not isinstance(self, Line):
            # _motion_path_line is used to display the motion path in scene
            self._motion_path_line = Line()
        self._previous_matrix: Union[np.ndarray, None] = None

        # For raycast tests - bounding radius is the radius of the bounding
        # sphere.
        self._bounding_radius: float = 0
        self._bounding_box: VList = []
        self._selected: bool = False

        # Vertex Array Object pointer
        self._vao: int = -1
        self._needs_update: bool = False  # Object geometry has changed.
        self._hit: bool = False
        &#34;&#34;&#34; I personally prefer not to delete vbos as in some cases I need to
        # refer to VBOs to update them partially. I don&#39;t want to loose
        # their reference and make things harder. I am not naming them
        # anyways.
        &#34;&#34;&#34;
        self._vbos: List[int] = []

    def refresh(self) -&gt; None:
        &#34;&#34;&#34;Refresh object

        Forces object to get built again
        &#34;&#34;&#34;
        self._needs_update = True

    @property
    def direction(self) -&gt; List[float]:
        &#34;&#34;&#34;Get direction vector from Matrix&#34;&#34;&#34;
        return self.matrix[1][:3]

    @direction.setter
    def direction(self, v: List[float]):
        &#34;&#34;&#34;Set direction vector of Matrix

        Attention! This needs to be a unit vector!
        &#34;&#34;&#34;
        if len(v) &lt; 3:
            raise Exception(&#34;Direction needs 3 components (x,y,z)&#34;)
        self.matrix[1][0] = v[0]
        self.matrix[1][1] = v[1]
        self.matrix[1][2] = v[2]
        left = cross_product(self.matrix[1], self.matrix[2])
        left += [0]
        self.matrix[0] = left
        up = cross_product(self.matrix[0], self.matrix[1])
        up += [0]
        self.matrix[2] = up

    def direct_to(self, v: List[float]):
        &#34;&#34;&#34;Direct the objects forward towards given point vector&#34;&#34;&#34;
        diff = sub_vector(v, self.position)
        diff = normalize_vector(diff)
        self.direction = diff

    def rotate_around_z(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Rotate around Z Axis

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([0, 0, 1], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def rotate_around_x(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Pitch - Rotate around X axis

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([1, 0, 0], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def rotate_around_y(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Roll - Rotate around Y Axis (Direction)

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([0, 1, 0], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def select(self, start: np.ndarray, vector: np.ndarray) -&gt; bool:
        &#34;&#34;&#34;Select test for object using bounding Sphere.

        This method is not 100% accurate as it is based on a rough
        assumption. Sphere area will be larger than actual object.

        If you want to have a more accurate way to handle this, try
        using raycast triangle intersect

        Args:
          start: Starting point of the ray (such as eye position)
          vector: Ray direction. This is not the end point of a line!
                  This is a unit vector showing the ray direction.
        &#34;&#34;&#34;
        self._selected = raycast_sphere_intersect(
            start,
            vector,
            np.array(self.matrix[3], dtype=np.float32),
            self._bounding_radius,
        )

        for obj in self.children:
            x = self.children[obj].select(start, vector)
            if not self._selected and x:
                self._selected = True

        return self._selected

    def destroy(self) -&gt; bool:
        &#34;&#34;&#34;
        Destroy objects self.

        Returns:
            bool: `True` on successful destroy of `self`.
        &#34;&#34;&#34;
        if self.has_vao:
            glDeleteVertexArrays(1, [self._vao])
            self._vao = -1
        return True

    def step_back(self, steps: int = 1) -&gt; bool:
        &#34;&#34;&#34;Go back N step in time

        This is suitable for solving collisions and getting a step back.
        On the other hand, this function requires `track_motion` to be
        True.

        Args:
          steps: Number of steps to go back. (Default = 1)

        Returns:
          bool: If step back is successful
        &#34;&#34;&#34;
        steps += 1
        if not self.track_motion:
            raise Exception(&#34;track_motion should be True&#34;)
        if len(self._motion_path) &lt; steps:
            return False

        self.matrix = self._motion_path[-steps]
        del self._motion_path[-steps + 1 :]
        return True

    def forward(self, distance: float) -&gt; None:
        &#34;&#34;&#34;Move object forward

        This method calculates to motion path according to direction
        of the object&#39;s matrix. `self.matrix[1]` indicates the direction.

        So matrix position gets updated according to direction * distance
        &#34;&#34;&#34;
        diff = scale_vector(self.matrix[1], distance)
        self.matrix[3] = add_vectors(self.matrix[3], diff)
        self.matrix[3][3] = 1.0

    def update_matrix(
        self, parent_matrix: Optional[np.ndarray] = None
    ) -&gt; None:
        &#34;&#34;&#34;Update matrix

        Turn object matrix into numpy array.

        Args:
          parent_matrix: Parent objects matrix
        &#34;&#34;&#34;
        # Turn matrix into numpy array. Numpy arrays are C Type arrays
        # suitable for OpenGL Pipeline
        self._model_matrix = np.array(self.matrix, dtype=np.float32)

        # When there is a parent object, child object follows parents matrix
        if parent_matrix is not None and len(parent_matrix) &gt; 0:
            self._model_matrix = parent_matrix.dot(self._model_matrix)

    def track(self) -&gt; bool:
        &#34;&#34;&#34;
        Track object motion

        Returns:
            bool: `True` on successful tracking of `self`.
        &#34;&#34;&#34;
        if not self.track_motion:
            return False
        if self._previous_matrix == self.matrix[3]:
            return True

        # Add the new matrix to motion path records
        self._motion_path.append(deepcopy(self.matrix))
        # Add the matrix position to motion math line for visualisation
        if self._motion_path_line is not None:
            self._motion_path_line.append(
                [[self.matrix[3][0], self.matrix[3][1], self.matrix[3][2]]]
            )

        # Python trick here! need to .copy or it will pass reference.
        self._previous_matrix = self.matrix[3].copy()
        return True

    @property
    def has_vao(self) -&gt; bool:
        &#34;&#34;&#34;Check if this object has an active Vertex Array Object

        Returns:
            bool: `True` if `self` has an active Vertex Array Object.
        &#34;&#34;&#34;
        return self._vao &gt; -1

    @property
    def visible(self) -&gt; bool:
        &#34;&#34;&#34;Check if object is visible

        Returns:
          bool: `True` if visible.
        &#34;&#34;&#34;
        return self._visible

    def show(self) -&gt; None:
        self._visible = True

    def hide(self) -&gt; None:
        self._visible = False

    def render(
        self,
        proj: np.ndarray,
        view: np.ndarray,
        lights: List[Light],
        parent_matrix: Optional[np.ndarray] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Virtual function for rendering the object. Some objects can overwrite
        this function.

        Args:
          proj: Camera projection matrix.
          view: Camera location/view matrix.
          lights: Light objects in the scene
          parent_matrix: Parent matrix is the matrix of the parent. Parent can
                         be the scene itself or another object. In case of
                         another object, object will position itself relative
                         to its parent object.
        &#34;&#34;&#34;
        if not self._visible:
            return

        if not self.has_vao or self._needs_update:
            self.build()

        self.update_matrix(parent_matrix=parent_matrix)
        self.track()

        if self._vertex_count == 0:
            # dummy object, render children and leave
            # render children
            for child in self.children:
                self.children[child].render(
                    proj, view, lights, self._model_matrix
                )

            return

        # Material shading mode.
        mode = None
        if self._has_vertex_colors:
            mode = Shader.PER_VERTEX_COLOR

        self.material.render(proj, view, self._model_matrix, lights, mode)

        # Actual rendering
        if glIsVertexArray(self._vao):
            glBindVertexArray(self._vao)
            pmode = GL_LINE
            primitive = GL_LINE_STRIP
            if self.material.display == SOLID:
                pmode = GL_FILL
                primitive = GL_TRIANGLES
            if self.material.display == POINTS:
                pmode = GL_POINT
                primitive = GL_POINTS
            glPolygonMode(GL_FRONT_AND_BACK, pmode)

            glDrawElements(
                primitive,
                self._vertex_count,
                GL_UNSIGNED_INT,
                ctypes.c_void_p(0),
            )
            if pmode != GL_FILL:
                glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
            glBindVertexArray(0)

        # End using the shader program.
        self.material.end()

        # Render motion path
        if self.track_motion:
            self._motion_path_line.render(proj, view, lights, parent_matrix)

        # render children
        for child in self.children:
            self.children[child].render(proj, view, lights, self._model_matrix)

    @property
    def position(self) -&gt; List[float]:
        &#34;&#34;&#34;Get position of the Object.

        Return matrix position list

        Returns:
          List[float]
        &#34;&#34;&#34;
        return self.matrix[3][:3]

    @position.setter
    def position(self, pos: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Shortcut function for explicitly modifying matrix indices.

        Basically just sets x, y, z of the matrix. Does not change its
        direction or up vectors.

        Args:
          pos: Position list ([x, y, z])
        &#34;&#34;&#34;
        if len(pos) == 2:
            pos = [pos[0], pos[1], 0.0]
        self.matrix[3][0] = pos[0]
        self.matrix[3][1] = pos[1]
        self.matrix[3][2] = pos[2]

    def add_child(self, name: str, obj: Type[&#34;Object&#34;]) -&gt; bool:
        &#34;&#34;&#34;Add child to this object.

        In a basic example:

            .. include:: ../../../examples/basics/05_children.py

        Args:
          name: Name of the object, must be unique within its siblings
          obj: Object. Must be an instance of
               `payton.scene.geometry.base.Object`

        Returns:
          bool: False in case of an error
        &#34;&#34;&#34;
        if name in self.children:
            logging.error(f&#34;Name {name} exists in object children&#34;)
            return False
        if not isinstance(obj, Object):
            logging.error(&#34;Object type is not valid&#34;)
            return False
        self.children[name] = obj
        return True

    def to_absolute(self, coordinates: List[float]) -&gt; List[float]:
        &#34;&#34;&#34;
        Return local coordinates (tuple, list) into absolute coordinates in
        space.

        Args:
          coordinates: List[float] (x, y, z)

        Returns:
          List[float] (x&#39;, y&#39;, z&#39;)
        &#34;&#34;&#34;
        return vector_transform(coordinates, self.matrix)

    def absolute_vertices(self) -&gt; Iterator[List[float]]:
        &#34;&#34;&#34;Return a map of all local vertices as absolute coordinates.

        Imagine that object B is a child of object A. In this case, B will
        always stand (follow) relative to A. If you want to know the exact
        world coordinates of all vertices in B, this method will return them.

        **Important!** This is a costly operation so use with caution!

        Returns:
          map(List[List[float]])
        &#34;&#34;&#34;
        return map(lambda v: self.to_absolute(v), self._vertices)

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle wireframe view of the Object&#34;&#34;&#34;
        d = self.material.display
        d += 1
        d = d % 3

        self.material.display = d
        for n in self.children:
            self.children[n].toggle_wireframe()

    def _calc_bounds(self) -&gt; float:
        &#34;&#34;&#34;Calculate the bounding sphere radius

        Returns:
          float
        &#34;&#34;&#34;

        bmin: Optional[List[float]] = None
        bmax: Optional[List[float]] = None
        x = [v[0] for v in self._vertices]
        y = [v[1] for v in self._vertices]
        z = [v[2] for v in self._vertices]
        bmin = [min(x), min(y), min(z)]
        bmax = [max(x), max(y), max(z)]
        self._bounding_radius = distance(bmax, bmin) / 2.0

        self._bounding_box = [bmin, bmax]
        return self._bounding_radius

    @property
    def bounding_radius(self) -&gt; float:
        &#34;&#34;&#34;Return bounding radius

        This property function *WILL NOT* update the previously
        calculated value. If you add vertices to the object, you must call
        `payton.scene.geometry.base.Object.refresh` function to get radius
        and the whole object updated.

        Returns:
          float
        &#34;&#34;&#34;

        if self._bounding_radius &gt; 0:
            return self._bounding_radius
        return self._calc_bounds()

    def build(self) -&gt; bool:
        &#34;&#34;&#34;
        Build OpenGL Vertex Array for the object

        This function gets automatically called if `self._vao` does not
        exists in the first render cycle. Once the vba is built,
        geometry changes or material display mode changes will not be
        automatically effected. So, in every geometry or display mode
        change, a `build` call is necessary.

        If `self.static` is `True`, then the system assumes that another update
        call is not expected, thus frees `_normals`, `_textcoords`,
        `_vertices` and `_indices` lists to free memory.
        So in this case, calling `build` function twice will result in
        an invisible object (will not be drawn).

        Returns:
          bool
        &#34;&#34;&#34;
        if len(self._indices) == 0:
            return False

        # If we don&#39;t have a VAO yet, we need to create one
        if not self.has_vao:
            # Generate Vertex Array
            self._vao = glGenVertexArrays(1)
            # We need 5 buffers (vertex, normal, texcoord, color, indices)
            self._vbos = glGenBuffers(5)
            glBindVertexArray(self._vao)
            # Material shader must be built when there is an active binding
            # to vertex array
            self.material.build_shader()
        else:
            # Ok, we already have vertex array object, just bind it to modify
            glBindVertexArray(self._vao)

        # Turn python arrays into C type arrays using Numpy.
        # This is required for OpenGL. Python memory model is a bit
        # different than raw memory model of C (OpenGL)
        vertices = np.array(self._vertices, dtype=np.float32).flatten()
        normals = np.array(self._normals, dtype=np.float32).flatten()
        texcoords = np.array(self._texcoords, dtype=np.float32).flatten()
        colors = np.array(self._vertex_colors, dtype=np.float32).flatten()
        indices = np.array(self._indices, dtype=np.int32).flatten()
        self._calc_bounds()

        # OpenGL allocates buffers in different mechanisms between
        # STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL
        # will assume that object buffer will not change and allocate it in a
        # more suitable way.
        draw = GL_STATIC_DRAW
        if not self.static:
            draw = GL_DYNAMIC_DRAW

        # Buffer overflow, we need more space.
        if self._buffer_size &lt; vertices.nbytes:
            self._buffer_size = vertices.nbytes
            self._buffer_size_changed = True
        if self._t_buffer_size &lt; texcoords.nbytes:
            self._t_buffer_size = texcoords.nbytes
            self._t_buffer_size_changed = True

        # Bind Vertices
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[0])
        glEnableVertexAttribArray(0)  # shader layout location
        glVertexAttribPointer(0, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        if self._buffer_size_changed:
            # glBufferData creates a new data area
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, vertices, draw)
        else:
            # glBufferSubData just replaces memory area in buffer so it is
            # much more efficient way to handle things.
            glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.nbytes, vertices)

        # Bind Normals
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[1])
        glEnableVertexAttribArray(1)  # shader layout location
        glVertexAttribPointer(1, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        if self._buffer_size_changed:
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, normals, draw)
        else:
            glBufferSubData(GL_ARRAY_BUFFER, 0, normals.nbytes, normals)

        # Bind TexCoords
        if len(self._texcoords) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[2])
            glEnableVertexAttribArray(2)  # shader layout location
            glVertexAttribPointer(2, 2, GL_FLOAT, False, 0, ctypes.c_void_p(0))
            if self._t_buffer_size_changed:
                glBufferData(
                    GL_ARRAY_BUFFER, self._t_buffer_size, texcoords, draw
                )
            else:
                glBufferSubData(
                    GL_ARRAY_BUFFER, 0, texcoords.nbytes, texcoords
                )

        # Bind Vertex Colors
        if len(self._vertex_colors) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[4])
            glEnableVertexAttribArray(3)  # shader layout location
            glVertexAttribPointer(3, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
            self._has_vertex_colors = True
            if self._buffer_size_changed:
                glBufferData(GL_ARRAY_BUFFER, self._buffer_size, colors, draw)
            else:
                glBufferSubData(GL_ARRAY_BUFFER, 0, colors.nbytes, colors)

        self._buffer_size_changed = False
        self._t_buffer_size_changed = False

        # Bind Indices
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self._vbos[3])
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.nbytes, indices, draw)
        self._vertex_count = len(indices)

        glBindVertexArray(0)
        glBindBuffer(GL_ARRAY_BUFFER, 0)

        if self.static:
            # we can clear this data to free some more memory
            glDeleteBuffers(4, self._vbos)
            self._vbos = []

        self._needs_update = False
        return True</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.base.Line" href="#payton.scene.geometry.base.Line">Line</a></li>
<li><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.point.PointCloud" href="point.html#payton.scene.geometry.point.PointCloud">PointCloud</a></li>
<li><a title="payton.scene.gui.Hud" href="../gui.html#payton.scene.gui.Hud">Hud</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="payton.scene.geometry.base.Object.bounding_radius"><code class="name">var <span class="ident">bounding_radius</span></code></dt>
<dd>
<section class="desc"><p>Return bounding radius</p>
<p>This property function <em>WILL NOT</em> update the previously
calculated value. If you add vertices to the object, you must call
<a title="payton.scene.geometry.base.Object.refresh" href="#payton.scene.geometry.base.Object.refresh"><code>Object.refresh()</code></a> function to get radius
and the whole object updated.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def bounding_radius(self) -&gt; float:
    &#34;&#34;&#34;Return bounding radius

    This property function *WILL NOT* update the previously
    calculated value. If you add vertices to the object, you must call
    `payton.scene.geometry.base.Object.refresh` function to get radius
    and the whole object updated.

    Returns:
      float
    &#34;&#34;&#34;

    if self._bounding_radius &gt; 0:
        return self._bounding_radius
    return self._calc_bounds()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.direction"><code class="name">var <span class="ident">direction</span></code></dt>
<dd>
<section class="desc"><p>Get direction vector from Matrix</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def direction(self) -&gt; List[float]:
    &#34;&#34;&#34;Get direction vector from Matrix&#34;&#34;&#34;
    return self.matrix[1][:3]</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.has_vao"><code class="name">var <span class="ident">has_vao</span></code></dt>
<dd>
<section class="desc"><p>Check if this object has an active Vertex Array Object</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd><code>True</code> if <code>self</code> has an active Vertex Array Object.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def has_vao(self) -&gt; bool:
    &#34;&#34;&#34;Check if this object has an active Vertex Array Object

    Returns:
        bool: `True` if `self` has an active Vertex Array Object.
    &#34;&#34;&#34;
    return self._vao &gt; -1</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<section class="desc"><p>Get position of the Object.</p>
<p>Return matrix position list</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code>[<code>float</code>]</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def position(self) -&gt; List[float]:
    &#34;&#34;&#34;Get position of the Object.

    Return matrix position list

    Returns:
      List[float]
    &#34;&#34;&#34;
    return self.matrix[3][:3]</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.visible"><code class="name">var <span class="ident">visible</span></code></dt>
<dd>
<section class="desc"><p>Check if object is visible</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd><code>True</code> if visible.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def visible(self) -&gt; bool:
    &#34;&#34;&#34;Check if object is visible

    Returns:
      bool: `True` if visible.
    &#34;&#34;&#34;
    return self._visible</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.base.Object.absolute_vertices"><code class="name flex">
<span>def <span class="ident">absolute_vertices</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a map of all local vertices as absolute coordinates.</p>
<p>Imagine that object B is a child of object A. In this case, B will
always stand (follow) relative to A. If you want to know the exact
world coordinates of all vertices in B, this method will return them.</p>
<p><strong>Important!</strong> This is a costly operation so use with caution!</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>map</code>(<code>List</code>[<code>List</code>[<code>float</code>]])</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def absolute_vertices(self) -&gt; Iterator[List[float]]:
    &#34;&#34;&#34;Return a map of all local vertices as absolute coordinates.

    Imagine that object B is a child of object A. In this case, B will
    always stand (follow) relative to A. If you want to know the exact
    world coordinates of all vertices in B, this method will return them.

    **Important!** This is a costly operation so use with caution!

    Returns:
      map(List[List[float]])
    &#34;&#34;&#34;
    return map(lambda v: self.to_absolute(v), self._vertices)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.add_child"><code class="name flex">
<span>def <span class="ident">add_child</span></span>(<span>self, name, obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Add child to this object.</p>
<p>In a basic example:</p>
<pre><code>import os
import math
from payton.scene import Scene
from payton.scene.geometry import Sphere
from payton.scene.light import Light


def motion(period, total):
    global space
    angle = (total * 10) % 360
    px = math.cos(math.radians(angle)) * 8
    py = math.sin(math.radians(angle)) * 8
    space.objects["nucleus"].children["particle"].position = [px, py, 0]

    sx = math.cos(math.radians(angle * 10)) * 2  # 10 times faster
    sy = math.sin(math.radians(angle * 10)) * 2
    space.objects["nucleus"].children["particle"].children[
        "sub_particle"
    ].position = [sx, sy, 0]
    space.lights[0].position = [px, py, 0]
    space.lights[1].position = [-px, -py, 0]


space = Scene()
space.lights.append(Light())
space.observers[0].position = [20, 20, 20]
space.grid.resize(40, 40, 1)

texture_file = os.path.join(os.path.dirname(__file__), "map.png")

nucleus = Sphere(radius=5, parallels=36, meridians=36)
nucleus.material.texture = texture_file
particle = Sphere()
particle.position = [8, 0, 0]

sub_particle = Sphere(radius=0.5)
sub_particle.position = [0, 2, 0]

nucleus.add_child("particle", particle)
particle.add_child("sub_particle", sub_particle)

space.add_object("nucleus", nucleus)

space.create_clock("motion", 0.01, motion)
print("Hit SPACE to continue animation")
space.run()
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the object, must be unique within its siblings</dd>
<dt><strong><code>obj</code></strong></dt>
<dd>Object. Must be an instance of
<a title="payton.scene.geometry.base.Object" href="#payton.scene.geometry.base.Object"><code>Object</code></a></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>False in case of an error</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_child(self, name: str, obj: Type[&#34;Object&#34;]) -&gt; bool:
    &#34;&#34;&#34;Add child to this object.

    In a basic example:

        .. include:: ../../../examples/basics/05_children.py

    Args:
      name: Name of the object, must be unique within its siblings
      obj: Object. Must be an instance of
           `payton.scene.geometry.base.Object`

    Returns:
      bool: False in case of an error
    &#34;&#34;&#34;
    if name in self.children:
        logging.error(f&#34;Name {name} exists in object children&#34;)
        return False
    if not isinstance(obj, Object):
        logging.error(&#34;Object type is not valid&#34;)
        return False
    self.children[name] = obj
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Build OpenGL Vertex Array for the object</p>
<p>This function gets automatically called if <code>self._vao</code> does not
exists in the first render cycle. Once the vba is built,
geometry changes or material display mode changes will not be
automatically effected. So, in every geometry or display mode
change, a <code>build</code> call is necessary.</p>
<p>If <code>self.static</code> is <code>True</code>, then the system assumes that another update
call is not expected, thus frees <code>_normals</code>, <code>_textcoords</code>,
<code>_vertices</code> and <code>_indices</code> lists to free memory.
So in this case, calling <code>build</code> function twice will result in
an invisible object (will not be drawn).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build(self) -&gt; bool:
    &#34;&#34;&#34;
    Build OpenGL Vertex Array for the object

    This function gets automatically called if `self._vao` does not
    exists in the first render cycle. Once the vba is built,
    geometry changes or material display mode changes will not be
    automatically effected. So, in every geometry or display mode
    change, a `build` call is necessary.

    If `self.static` is `True`, then the system assumes that another update
    call is not expected, thus frees `_normals`, `_textcoords`,
    `_vertices` and `_indices` lists to free memory.
    So in this case, calling `build` function twice will result in
    an invisible object (will not be drawn).

    Returns:
      bool
    &#34;&#34;&#34;
    if len(self._indices) == 0:
        return False

    # If we don&#39;t have a VAO yet, we need to create one
    if not self.has_vao:
        # Generate Vertex Array
        self._vao = glGenVertexArrays(1)
        # We need 5 buffers (vertex, normal, texcoord, color, indices)
        self._vbos = glGenBuffers(5)
        glBindVertexArray(self._vao)
        # Material shader must be built when there is an active binding
        # to vertex array
        self.material.build_shader()
    else:
        # Ok, we already have vertex array object, just bind it to modify
        glBindVertexArray(self._vao)

    # Turn python arrays into C type arrays using Numpy.
    # This is required for OpenGL. Python memory model is a bit
    # different than raw memory model of C (OpenGL)
    vertices = np.array(self._vertices, dtype=np.float32).flatten()
    normals = np.array(self._normals, dtype=np.float32).flatten()
    texcoords = np.array(self._texcoords, dtype=np.float32).flatten()
    colors = np.array(self._vertex_colors, dtype=np.float32).flatten()
    indices = np.array(self._indices, dtype=np.int32).flatten()
    self._calc_bounds()

    # OpenGL allocates buffers in different mechanisms between
    # STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL
    # will assume that object buffer will not change and allocate it in a
    # more suitable way.
    draw = GL_STATIC_DRAW
    if not self.static:
        draw = GL_DYNAMIC_DRAW

    # Buffer overflow, we need more space.
    if self._buffer_size &lt; vertices.nbytes:
        self._buffer_size = vertices.nbytes
        self._buffer_size_changed = True
    if self._t_buffer_size &lt; texcoords.nbytes:
        self._t_buffer_size = texcoords.nbytes
        self._t_buffer_size_changed = True

    # Bind Vertices
    glBindBuffer(GL_ARRAY_BUFFER, self._vbos[0])
    glEnableVertexAttribArray(0)  # shader layout location
    glVertexAttribPointer(0, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
    if self._buffer_size_changed:
        # glBufferData creates a new data area
        glBufferData(GL_ARRAY_BUFFER, self._buffer_size, vertices, draw)
    else:
        # glBufferSubData just replaces memory area in buffer so it is
        # much more efficient way to handle things.
        glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.nbytes, vertices)

    # Bind Normals
    glBindBuffer(GL_ARRAY_BUFFER, self._vbos[1])
    glEnableVertexAttribArray(1)  # shader layout location
    glVertexAttribPointer(1, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
    if self._buffer_size_changed:
        glBufferData(GL_ARRAY_BUFFER, self._buffer_size, normals, draw)
    else:
        glBufferSubData(GL_ARRAY_BUFFER, 0, normals.nbytes, normals)

    # Bind TexCoords
    if len(self._texcoords) == len(self._vertices):
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[2])
        glEnableVertexAttribArray(2)  # shader layout location
        glVertexAttribPointer(2, 2, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        if self._t_buffer_size_changed:
            glBufferData(
                GL_ARRAY_BUFFER, self._t_buffer_size, texcoords, draw
            )
        else:
            glBufferSubData(
                GL_ARRAY_BUFFER, 0, texcoords.nbytes, texcoords
            )

    # Bind Vertex Colors
    if len(self._vertex_colors) == len(self._vertices):
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[4])
        glEnableVertexAttribArray(3)  # shader layout location
        glVertexAttribPointer(3, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        self._has_vertex_colors = True
        if self._buffer_size_changed:
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, colors, draw)
        else:
            glBufferSubData(GL_ARRAY_BUFFER, 0, colors.nbytes, colors)

    self._buffer_size_changed = False
    self._t_buffer_size_changed = False

    # Bind Indices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self._vbos[3])
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.nbytes, indices, draw)
    self._vertex_count = len(indices)

    glBindVertexArray(0)
    glBindBuffer(GL_ARRAY_BUFFER, 0)

    if self.static:
        # we can clear this data to free some more memory
        glDeleteBuffers(4, self._vbos)
        self._vbos = []

    self._needs_update = False
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Destroy objects self.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd><code>True</code> on successful destroy of <code>self</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def destroy(self) -&gt; bool:
    &#34;&#34;&#34;
    Destroy objects self.

    Returns:
        bool: `True` on successful destroy of `self`.
    &#34;&#34;&#34;
    if self.has_vao:
        glDeleteVertexArrays(1, [self._vao])
        self._vao = -1
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.direct_to"><code class="name flex">
<span>def <span class="ident">direct_to</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<section class="desc"><p>Direct the objects forward towards given point vector</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def direct_to(self, v: List[float]):
    &#34;&#34;&#34;Direct the objects forward towards given point vector&#34;&#34;&#34;
    diff = sub_vector(v, self.position)
    diff = normalize_vector(diff)
    self.direction = diff</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, distance)</span>
</code></dt>
<dd>
<section class="desc"><p>Move object forward</p>
<p>This method calculates to motion path according to direction
of the object's matrix. <code>self.matrix[1]</code> indicates the direction.</p>
<p>So matrix position gets updated according to direction * distance</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def forward(self, distance: float) -&gt; None:
    &#34;&#34;&#34;Move object forward

    This method calculates to motion path according to direction
    of the object&#39;s matrix. `self.matrix[1]` indicates the direction.

    So matrix position gets updated according to direction * distance
    &#34;&#34;&#34;
    diff = scale_vector(self.matrix[1], distance)
    self.matrix[3] = add_vectors(self.matrix[3], diff)
    self.matrix[3][3] = 1.0</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.hide"><code class="name flex">
<span>def <span class="ident">hide</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hide(self) -&gt; None:
    self._visible = False</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Refresh object</p>
<p>Forces object to get built again</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def refresh(self) -&gt; None:
    &#34;&#34;&#34;Refresh object

    Forces object to get built again
    &#34;&#34;&#34;
    self._needs_update = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, proj, view, lights, parent_matrix=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Virtual function for rendering the object. Some objects can overwrite
this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proj</code></strong></dt>
<dd>Camera projection matrix.</dd>
<dt><strong><code>view</code></strong></dt>
<dd>Camera location/view matrix.</dd>
<dt><strong><code>lights</code></strong></dt>
<dd>Light objects in the scene</dd>
<dt><strong><code>parent_matrix</code></strong></dt>
<dd>Parent matrix is the matrix of the parent. Parent can
be the scene itself or another object. In case of
another object, object will position itself relative
to its parent object.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def render(
    self,
    proj: np.ndarray,
    view: np.ndarray,
    lights: List[Light],
    parent_matrix: Optional[np.ndarray] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Virtual function for rendering the object. Some objects can overwrite
    this function.

    Args:
      proj: Camera projection matrix.
      view: Camera location/view matrix.
      lights: Light objects in the scene
      parent_matrix: Parent matrix is the matrix of the parent. Parent can
                     be the scene itself or another object. In case of
                     another object, object will position itself relative
                     to its parent object.
    &#34;&#34;&#34;
    if not self._visible:
        return

    if not self.has_vao or self._needs_update:
        self.build()

    self.update_matrix(parent_matrix=parent_matrix)
    self.track()

    if self._vertex_count == 0:
        # dummy object, render children and leave
        # render children
        for child in self.children:
            self.children[child].render(
                proj, view, lights, self._model_matrix
            )

        return

    # Material shading mode.
    mode = None
    if self._has_vertex_colors:
        mode = Shader.PER_VERTEX_COLOR

    self.material.render(proj, view, self._model_matrix, lights, mode)

    # Actual rendering
    if glIsVertexArray(self._vao):
        glBindVertexArray(self._vao)
        pmode = GL_LINE
        primitive = GL_LINE_STRIP
        if self.material.display == SOLID:
            pmode = GL_FILL
            primitive = GL_TRIANGLES
        if self.material.display == POINTS:
            pmode = GL_POINT
            primitive = GL_POINTS
        glPolygonMode(GL_FRONT_AND_BACK, pmode)

        glDrawElements(
            primitive,
            self._vertex_count,
            GL_UNSIGNED_INT,
            ctypes.c_void_p(0),
        )
        if pmode != GL_FILL:
            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
        glBindVertexArray(0)

    # End using the shader program.
    self.material.end()

    # Render motion path
    if self.track_motion:
        self._motion_path_line.render(proj, view, lights, parent_matrix)

    # render children
    for child in self.children:
        self.children[child].render(proj, view, lights, self._model_matrix)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.rotate_around_x"><code class="name flex">
<span>def <span class="ident">rotate_around_x</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<section class="desc"><p>Pitch - Rotate around X axis</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle in radians</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotate_around_x(self, angle: float) -&gt; None:
    &#34;&#34;&#34;Pitch - Rotate around X axis

    Args:
      angle: Angle in radians
    &#34;&#34;&#34;
    rot_matrix = create_rotation_matrix([1, 0, 0], angle)
    local_matrix = np.array(self.matrix, dtype=np.float32)
    local_matrix = rot_matrix.dot(local_matrix)
    self.matrix = local_matrix.tolist()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.rotate_around_y"><code class="name flex">
<span>def <span class="ident">rotate_around_y</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<section class="desc"><p>Roll - Rotate around Y Axis (Direction)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle in radians</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotate_around_y(self, angle: float) -&gt; None:
    &#34;&#34;&#34;Roll - Rotate around Y Axis (Direction)

    Args:
      angle: Angle in radians
    &#34;&#34;&#34;
    rot_matrix = create_rotation_matrix([0, 1, 0], angle)
    local_matrix = np.array(self.matrix, dtype=np.float32)
    local_matrix = rot_matrix.dot(local_matrix)
    self.matrix = local_matrix.tolist()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.rotate_around_z"><code class="name flex">
<span>def <span class="ident">rotate_around_z</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate around Z Axis</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle in radians</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotate_around_z(self, angle: float) -&gt; None:
    &#34;&#34;&#34;Rotate around Z Axis

    Args:
      angle: Angle in radians
    &#34;&#34;&#34;
    rot_matrix = create_rotation_matrix([0, 0, 1], angle)
    local_matrix = np.array(self.matrix, dtype=np.float32)
    local_matrix = rot_matrix.dot(local_matrix)
    self.matrix = local_matrix.tolist()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, start, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Select test for object using bounding Sphere.</p>
<p>This method is not 100% accurate as it is based on a rough
assumption. Sphere area will be larger than actual object.</p>
<p>If you want to have a more accurate way to handle this, try
using raycast triangle intersect</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>Starting point of the ray (such as eye position)</dd>
<dt><strong><code>vector</code></strong></dt>
<dd>Ray direction. This is not the end point of a line!
This is a unit vector showing the ray direction.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select(self, start: np.ndarray, vector: np.ndarray) -&gt; bool:
    &#34;&#34;&#34;Select test for object using bounding Sphere.

    This method is not 100% accurate as it is based on a rough
    assumption. Sphere area will be larger than actual object.

    If you want to have a more accurate way to handle this, try
    using raycast triangle intersect

    Args:
      start: Starting point of the ray (such as eye position)
      vector: Ray direction. This is not the end point of a line!
              This is a unit vector showing the ray direction.
    &#34;&#34;&#34;
    self._selected = raycast_sphere_intersect(
        start,
        vector,
        np.array(self.matrix[3], dtype=np.float32),
        self._bounding_radius,
    )

    for obj in self.children:
        x = self.children[obj].select(start, vector)
        if not self._selected and x:
            self._selected = True

    return self._selected</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show(self) -&gt; None:
    self._visible = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.step_back"><code class="name flex">
<span>def <span class="ident">step_back</span></span>(<span>self, steps=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Go back N step in time</p>
<p>This is suitable for solving collisions and getting a step back.
On the other hand, this function requires <code>track_motion</code> to be
True.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>steps</code></strong></dt>
<dd>Number of steps to go back. (Default = 1)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>If step back is successful</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def step_back(self, steps: int = 1) -&gt; bool:
    &#34;&#34;&#34;Go back N step in time

    This is suitable for solving collisions and getting a step back.
    On the other hand, this function requires `track_motion` to be
    True.

    Args:
      steps: Number of steps to go back. (Default = 1)

    Returns:
      bool: If step back is successful
    &#34;&#34;&#34;
    steps += 1
    if not self.track_motion:
        raise Exception(&#34;track_motion should be True&#34;)
    if len(self._motion_path) &lt; steps:
        return False

    self.matrix = self._motion_path[-steps]
    del self._motion_path[-steps + 1 :]
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.to_absolute"><code class="name flex">
<span>def <span class="ident">to_absolute</span></span>(<span>self, coordinates)</span>
</code></dt>
<dd>
<section class="desc"><p>Return local coordinates (tuple, list) into absolute coordinates in
space.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coordinates</code></strong></dt>
<dd>List[float] (x, y, z)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code>[<code>float</code>] (<code>x'</code>, <code>y'</code>, <code>z'</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def to_absolute(self, coordinates: List[float]) -&gt; List[float]:
    &#34;&#34;&#34;
    Return local coordinates (tuple, list) into absolute coordinates in
    space.

    Args:
      coordinates: List[float] (x, y, z)

    Returns:
      List[float] (x&#39;, y&#39;, z&#39;)
    &#34;&#34;&#34;
    return vector_transform(coordinates, self.matrix)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.toggle_wireframe"><code class="name flex">
<span>def <span class="ident">toggle_wireframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Toggle wireframe view of the Object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def toggle_wireframe(self) -&gt; None:
    &#34;&#34;&#34;Toggle wireframe view of the Object&#34;&#34;&#34;
    d = self.material.display
    d += 1
    d = d % 3

    self.material.display = d
    for n in self.children:
        self.children[n].toggle_wireframe()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.track"><code class="name flex">
<span>def <span class="ident">track</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Track object motion</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd><code>True</code> on successful tracking of <code>self</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def track(self) -&gt; bool:
    &#34;&#34;&#34;
    Track object motion

    Returns:
        bool: `True` on successful tracking of `self`.
    &#34;&#34;&#34;
    if not self.track_motion:
        return False
    if self._previous_matrix == self.matrix[3]:
        return True

    # Add the new matrix to motion path records
    self._motion_path.append(deepcopy(self.matrix))
    # Add the matrix position to motion math line for visualisation
    if self._motion_path_line is not None:
        self._motion_path_line.append(
            [[self.matrix[3][0], self.matrix[3][1], self.matrix[3][2]]]
        )

    # Python trick here! need to .copy or it will pass reference.
    self._previous_matrix = self.matrix[3].copy()
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.base.Object.update_matrix"><code class="name flex">
<span>def <span class="ident">update_matrix</span></span>(<span>self, parent_matrix=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Update matrix</p>
<p>Turn object matrix into numpy array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_matrix</code></strong></dt>
<dd>Parent objects matrix</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_matrix(
    self, parent_matrix: Optional[np.ndarray] = None
) -&gt; None:
    &#34;&#34;&#34;Update matrix

    Turn object matrix into numpy array.

    Args:
      parent_matrix: Parent objects matrix
    &#34;&#34;&#34;
    # Turn matrix into numpy array. Numpy arrays are C Type arrays
    # suitable for OpenGL Pipeline
    self._model_matrix = np.array(self.matrix, dtype=np.float32)

    # When there is a parent object, child object follows parents matrix
    if parent_matrix is not None and len(parent_matrix) &gt; 0:
        self._model_matrix = parent_matrix.dot(self._model_matrix)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="payton.scene.geometry" href="index.html">payton.scene.geometry</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="payton.scene.geometry.base.Line" href="#payton.scene.geometry.base.Line">Line</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.base.Line.append" href="#payton.scene.geometry.base.Line.append">append</a></code></li>
<li><code><a title="payton.scene.geometry.base.Line.build_lines" href="#payton.scene.geometry.base.Line.build_lines">build_lines</a></code></li>
<li><code><a title="payton.scene.geometry.base.Line.toggle_wireframe" href="#payton.scene.geometry.base.Line.toggle_wireframe">toggle_wireframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.base.Object" href="#payton.scene.geometry.base.Object">Object</a></code></h4>
<ul class="two-column">
<li><code><a title="payton.scene.geometry.base.Object.absolute_vertices" href="#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.add_child" href="#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.bounding_radius" href="#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.build" href="#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.destroy" href="#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direct_to" href="#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direction" href="#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.forward" href="#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.has_vao" href="#payton.scene.geometry.base.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.hide" href="#payton.scene.geometry.base.Object.hide">hide</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.position" href="#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.refresh" href="#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.render" href="#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_x" href="#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_y" href="#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_z" href="#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.select" href="#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.show" href="#payton.scene.geometry.base.Object.show">show</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.step_back" href="#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.to_absolute" href="#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.toggle_wireframe" href="#payton.scene.geometry.base.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.track" href="#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.update_matrix" href="#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.visible" href="#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>