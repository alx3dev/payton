<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>payton.scene.geometry.base API documentation</title>
    <meta name="description" content="" />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    min-height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #0000FF } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#payton.scene.geometry.base.DEFAULT">DEFAULT</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.NO_INDICE">NO_INDICE</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.NO_VERTEX_ARRAY">NO_VERTEX_ARRAY</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.POINTS">POINTS</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.SOLID">SOLID</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.WIREFRAME">WIREFRAME</a></li>
  </ul>

    </li>


    <li class="set"><h3><a href="#header-classes">Classes</a></h3>
      <ul>
        <li class="mono">
        <span class="class_name"><a href="#payton.scene.geometry.base.Line">Line</a></span>
        
          
  <ul>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.__init__">__init__</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.absolute_vertices">absolute_vertices</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.add_child">add_child</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.add_material">add_material</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.append">append</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.build">build</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.build_lines">build_lines</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.destroy">destroy</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.direct_to">direct_to</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.forward">forward</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.hide">hide</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.refresh">refresh</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.render">render</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.rotate_around_x">rotate_around_x</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.rotate_around_y">rotate_around_y</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.rotate_around_z">rotate_around_z</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.select">select</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.show">show</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.step_back">step_back</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.to_absolute">to_absolute</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.toggle_wireframe">toggle_wireframe</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.track">track</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Line.update_matrix">update_matrix</a></li>
  </ul>

        </li>
        <li class="mono">
        <span class="class_name"><a href="#payton.scene.geometry.base.Object">Object</a></span>
        
          
  <ul>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.__init__">__init__</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.add_child">add_child</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.add_material">add_material</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.build">build</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.destroy">destroy</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.direct_to">direct_to</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.forward">forward</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.hide">hide</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.refresh">refresh</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.render">render</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.select">select</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.show">show</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.step_back">step_back</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.toggle_wireframe">toggle_wireframe</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.track">track</a></li>
    <li class="mono"><a href="#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></li>
  </ul>

        </li>
      </ul>
    </li>

    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">payton.scene.geometry.base</span> module</h1>
  
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base" class="source">
    <div class="codehilite"><pre><span></span><span class="c1"># pylama:ignore=C901</span>
<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>  <span class="c1"># type: ignore</span>
<span class="kn">from</span> <span class="nn">OpenGL.GL</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span>
    <span class="n">GL_DYNAMIC_DRAW</span><span class="p">,</span>
    <span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span>
    <span class="n">GL_FILL</span><span class="p">,</span>
    <span class="n">GL_FLOAT</span><span class="p">,</span>
    <span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span>
    <span class="n">GL_LINE</span><span class="p">,</span>
    <span class="n">GL_LINE_STRIP</span><span class="p">,</span>
    <span class="n">GL_POINT</span><span class="p">,</span>
    <span class="n">GL_POINTS</span><span class="p">,</span>
    <span class="n">GL_STATIC_DRAW</span><span class="p">,</span>
    <span class="n">GL_TRIANGLES</span><span class="p">,</span>
    <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span>
    <span class="n">glBindBuffer</span><span class="p">,</span>
    <span class="n">glBindVertexArray</span><span class="p">,</span>
    <span class="n">glBufferData</span><span class="p">,</span>
    <span class="n">glBufferSubData</span><span class="p">,</span>
    <span class="n">glDeleteBuffers</span><span class="p">,</span>
    <span class="n">glDeleteVertexArrays</span><span class="p">,</span>
    <span class="n">glDrawElements</span><span class="p">,</span>
    <span class="n">glEnableVertexAttribArray</span><span class="p">,</span>
    <span class="n">glGenBuffers</span><span class="p">,</span>
    <span class="n">glGenVertexArrays</span><span class="p">,</span>
    <span class="n">glIsVertexArray</span><span class="p">,</span>
    <span class="n">glPolygonMode</span><span class="p">,</span>
    <span class="n">glVertexAttribPointer</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">payton.math.geometry</span> <span class="kn">import</span> <span class="n">raycast_sphere_intersect</span>
<span class="kn">from</span> <span class="nn">payton.math.matrix</span> <span class="kn">import</span> <span class="n">create_rotation_matrix</span>
<span class="kn">from</span> <span class="nn">payton.math.vector</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">add_vectors</span><span class="p">,</span>
    <span class="n">cross_product</span><span class="p">,</span>
    <span class="n">distance</span><span class="p">,</span>
    <span class="n">normalize_vector</span><span class="p">,</span>
    <span class="n">scale_vector</span><span class="p">,</span>
    <span class="n">sub_vector</span><span class="p">,</span>
    <span class="n">vector_transform</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">payton.scene.light</span> <span class="kn">import</span> <span class="n">Light</span>
<span class="kn">from</span> <span class="nn">payton.scene.material</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">DEFAULT</span><span class="p">,</span>
    <span class="n">NO_INDICE</span><span class="p">,</span>
    <span class="n">NO_VERTEX_ARRAY</span><span class="p">,</span>
    <span class="n">POINTS</span><span class="p">,</span>
    <span class="n">SOLID</span><span class="p">,</span>
    <span class="n">WIREFRAME</span><span class="p">,</span>
    <span class="n">Material</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">payton.scene.shader</span> <span class="kn">import</span> <span class="n">Shader</span>
<span class="kn">from</span> <span class="nn">payton.scene.types</span> <span class="kn">import</span> <span class="n">IList</span><span class="p">,</span> <span class="n">VList</span>


<span class="k">class</span> <span class="nc">Object</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main Payton Object.</span>

<span class="sd">    This is an abstract class to define common properties and methods between</span>
<span class="sd">    Mesh / Cube / Sphere/ Shape2D / PointCloud, etc.</span>

<span class="sd">    Objects are not actually built as 3D vertex arrays until they are rendered.</span>
<span class="sd">    Render function calls `build` function if needed. Build function creates</span>
<span class="sd">    the OpenGL Vertex Array Object. VAO is static data so, once the object</span>
<span class="sd">    is built, changing vertices or indices will not take effect at the scene.</span>

<span class="sd">    You need to call `payton.scene.geometry.base.Object.build` function to</span>
<span class="sd">    refresh Vertex Array Object.</span>

<span class="sd">    OpenGL can not magically extend a memory buffer, so for every new vertices</span>
<span class="sd">    added to the object, OpenGL needs to re-create the buffer area. This is</span>
<span class="sd">    not an efficitient technique if number of vertices increase in time.</span>
<span class="sd">    As a result Payton allocates buffer for 500 vertices in the beginning and</span>
<span class="sd">    uses part of it. If the object exceeds 500 vertices, a new buffer is</span>
<span class="sd">    created with 500 vertices more, copies existing vertices to the new</span>
<span class="sd">    buffer and the old buffer is deleted.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">static</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">visible</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">track_motion</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the basic object properties.</span>

<span class="sd">        Properties:</span>
<span class="sd">          children: Children hash for object. Each child object follows parent</span>
<span class="sd">                    object. They take their parent object as origin and their</span>
<span class="sd">                    coordinate system is relative to their parent. This</span>
<span class="sd">                    behaviour resembles stars, planets and their moons.</span>
<span class="sd">          material: Material definitions of the object.</span>
<span class="sd">          matrix: Matrix definition of the object. This is a 4x4 Uniform Matrix</span>
<span class="sd">                  but data is set as an array for easier transformations. First</span>
<span class="sd">                  4 decimals are &quot;Left&quot; vector, second 4 are &quot;Direction&quot;, third</span>
<span class="sd">                  4 are &quot;Up&quot; and last four decimals are &quot;Position&quot; vectors.</span>

<span class="sd">        Args:</span>
<span class="sd">          track_motion: Track object motion (default: false). Object tracking</span>
<span class="sd">                        is time independent. It just saves the object matrix</span>
<span class="sd">                        for every change. Uses matrix position for drawing the</span>
<span class="sd">                        motion path.</span>
<span class="sd">          static: (Default `True`) Indicates if object geometry is expected</span>
<span class="sd">                  to be changed in the future. If object is not static, then</span>
<span class="sd">                  its&#39; vertex buffer object references and vertex informations</span>
<span class="sd">                  will not be deleted to be used for future reference.</span>
<span class="sd">          name: Name of the object (optional, default &#39;&#39;) Note that, when</span>
<span class="sd">                object gets added to a Scene with a name, Scene will assign</span>
<span class="sd">                that name to the object, overwriting any existing name of the</span>
<span class="sd">                object.</span>
<span class="sd">          visible: Is this object visible at the scene, default: `True`. To</span>
<span class="sd">                   hide an object, you can call `object.hide()` and to show</span>
<span class="sd">                   it again use: `object.show()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Object</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># store diffeerent materials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Material</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">DEFAULT</span><span class="p">:</span> <span class="n">Material</span><span class="p">()}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">static</span> <span class="o">=</span> <span class="n">static</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="n">visible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="p">]</span>
        <span class="c1"># Object vertices. Each vertex has 3 decimals (X, Y, Z). Vertices</span>
        <span class="c1"># are continuous. [X, Y, Z, X, Y, Z, X, Y, Z, X, ... ]</span>
        <span class="c1">#                  -- 1 --  -- 2 --  -- 3 --  -- 4 --</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Object vertex list</span>

        <span class="c1"># @NOTE: we have separate indices for materials but this base</span>
        <span class="c1">#        index list holds all indice definitions for fast access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">:</span> <span class="n">IList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Vertex normals, 1 normal coordinate for 1 Vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Texture coordinates, 1 coordinate per Vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># per-vertex colors, optional.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># flag for using vertex colors</span>

        <span class="c1"># Vertices do not mean anything unless we define how to use them.</span>
        <span class="c1"># For instance, 3 vertices make a triangle or 2 vertices define a line</span>
        <span class="c1"># order of vertices are defined in materials indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Number of vertices to report to OpenGL.</span>

        <span class="c1"># This is an optimization technique for dynamic objects where there are</span>
        <span class="c1"># increasing number of vertices. We allocate some buffer before-hand</span>
        <span class="c1"># and if we fill all of it, we resize it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">12</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Model matrix.</span>
        <span class="c1"># Check if buffer size allocated for the object has changed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1"># Track object motion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span> <span class="o">=</span> <span class="n">track_motion</span>
        <span class="c1"># Motion path, stores every matrix change.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">VList</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Line</span><span class="p">):</span>
            <span class="c1"># _motion_path_line is used to display the motion path in scene</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span> <span class="o">=</span> <span class="n">Line</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># For raycast tests - bounding radius is the radius of the bounding</span>
        <span class="c1"># sphere.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c1"># Vertex Array Object pointer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># Object geometry has changed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Refresh object</span>

<span class="sd">        Forces object to get built again</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">material</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Material</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">DEFAULT</span><span class="p">]</span>

    <span class="nd">@material.setter</span>
    <span class="k">def</span> <span class="nf">material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">DEFAULT</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span>

    <span class="k">def</span> <span class="nf">add_material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add a material to the object.</span>

<span class="sd">        Keep in mind that, adding material does not refer to the material</span>
<span class="sd">        but does it through deepcopy. Initially, material holds indice</span>
<span class="sd">        and vertex buffer objectt references. In order to prevent user</span>
<span class="sd">        from breaking the objects, we create the clone of the material.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Name {name} already exists&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">material</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">direction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get direction vector from Matrix&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span>

    <span class="nd">@direction.setter</span>
    <span class="k">def</span> <span class="nf">direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Set direction vector of Matrix</span>

<span class="sd">        Attention! This needs to be a unit vector!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Direction needs 3 components (x,y,z)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">cross_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">left</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">up</span> <span class="o">=</span> <span class="n">cross_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">up</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">up</span>

    <span class="k">def</span> <span class="nf">direct_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Direct the objects forward towards given point vector&quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">sub_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">diff</span>

    <span class="k">def</span> <span class="nf">rotate_around_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Rotate around Z Axis</span>

<span class="sd">        Args:</span>
<span class="sd">          angle: Angle in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">rotate_around_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Pitch - Rotate around X axis</span>

<span class="sd">        Args:</span>
<span class="sd">          angle: Angle in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">rotate_around_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Roll - Rotate around Y Axis (Direction)</span>

<span class="sd">        Args:</span>
<span class="sd">          angle: Angle in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Select test for object using bounding Sphere.</span>

<span class="sd">        This method is not 100% accurate as it is based on a rough</span>
<span class="sd">        assumption. Sphere area will be larger than actual object.</span>

<span class="sd">        If you want to have a more accurate way to handle this, try</span>
<span class="sd">        using raycast triangle intersect</span>

<span class="sd">        Args:</span>
<span class="sd">          start: Starting point of the ray (such as eye position)</span>
<span class="sd">          vector: Ray direction. This is not the end point of a line!</span>
<span class="sd">                  This is a unit vector showing the ray direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="o">=</span> <span class="n">raycast_sphere_intersect</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">vector</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="ow">and</span> <span class="n">x</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span>

    <span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Destroy objects self.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: `True` on successful destroy of `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
                <span class="n">glDeleteVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">])</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
            <span class="n">glDeleteVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">step_back</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Go back N step in time</span>

<span class="sd">        This is suitable for solving collisions and getting a step back.</span>
<span class="sd">        On the other hand, this function requires `track_motion` to be</span>
<span class="sd">        True.</span>

<span class="sd">        Args:</span>
<span class="sd">          steps: Number of steps to go back. (Default = 1)</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool: If step back is successful</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;track_motion should be True&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">[</span><span class="o">-</span><span class="n">steps</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">[</span><span class="o">-</span><span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>  <span class="c1"># noqa</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Move object forward</span>

<span class="sd">        This method calculates to motion path according to direction</span>
<span class="sd">        of the object&#39;s matrix. `self.matrix[1]` indicates the direction.</span>

<span class="sd">        So matrix position gets updated according to direction * distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">scale_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">distance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_vectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">diff</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">def</span> <span class="nf">update_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">parent_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update matrix</span>

<span class="sd">        Turn object matrix into numpy array.</span>

<span class="sd">        Args:</span>
<span class="sd">          parent_matrix: Parent objects matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Turn matrix into numpy array. Numpy arrays are C Type arrays</span>
        <span class="c1"># suitable for OpenGL Pipeline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># When there is a parent object, child object follows parents matrix</span>
        <span class="k">if</span> <span class="n">parent_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_matrix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">parent_matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">track</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Track object motion</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: `True` on successful tracking of `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c1"># Add the new matrix to motion path records</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">))</span>
        <span class="c1"># Add the matrix position to motion math line for visualisation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]]]</span>
            <span class="p">)</span>

        <span class="c1"># Python trick here! need to .copy or it will pass reference.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">visible</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check if object is visible</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool: `True` if visible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span>

    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">hide</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_missing_vao</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_VERTEX_ARRAY</span>
                <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">proj</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">lights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Light</span><span class="p">],</span>
        <span class="n">parent_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Virtual function for rendering the object. Some objects can overwrite</span>
<span class="sd">        this function.</span>

<span class="sd">        Args:</span>
<span class="sd">          proj: Camera projection matrix.</span>
<span class="sd">          view: Camera location/view matrix.</span>
<span class="sd">          lights: Light objects in the scene</span>
<span class="sd">          parent_matrix: Parent matrix is the matrix of the parent. Parent can</span>
<span class="sd">                         be the scene itself or another object. In case of</span>
<span class="sd">                         another object, object will position itself relative</span>
<span class="sd">                         to its parent object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_missing_vao</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_matrix</span><span class="p">(</span><span class="n">parent_matrix</span><span class="o">=</span><span class="n">parent_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># dummy object, render children and leave</span>
            <span class="c1"># render children</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">render</span><span class="p">(</span>
                    <span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span>
                <span class="p">)</span>

            <span class="k">return</span>

        <span class="c1"># Material shading mode.</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">Shader</span><span class="o">.</span><span class="n">PER_VERTEX_COLOR</span>

        <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">material</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

            <span class="c1"># Actual rendering</span>
            <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span> <span class="ow">and</span> <span class="n">glIsVertexArray</span><span class="p">(</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vao</span>
            <span class="p">):</span>
                <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
                <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_LINE</span>
                <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_LINE_STRIP</span>
                <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="n">SOLID</span><span class="p">:</span>
                    <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_FILL</span>
                    <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_TRIANGLES</span>
                <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="n">POINTS</span><span class="p">:</span>
                    <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_POINT</span>
                    <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_POINTS</span>
                <span class="n">glPolygonMode</span><span class="p">(</span><span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span> <span class="n">pmode</span><span class="p">)</span>

                <span class="n">glDrawElements</span><span class="p">(</span>
                    <span class="n">primitive</span><span class="p">,</span>
                    <span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">,</span>
                    <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">pmode</span> <span class="o">!=</span> <span class="n">GL_FILL</span><span class="p">:</span>
                    <span class="n">glPolygonMode</span><span class="p">(</span><span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span> <span class="n">GL_FILL</span><span class="p">)</span>
                <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># End using the shader program.</span>
            <span class="n">material</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="c1"># Render motion path</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="n">parent_matrix</span><span class="p">)</span>

        <span class="c1"># render children</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get position of the Object.</span>

<span class="sd">        Return matrix position list</span>

<span class="sd">        Returns:</span>
<span class="sd">          List[float]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span>

    <span class="nd">@position.setter</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shortcut function for explicitly modifying matrix indices.</span>

<span class="sd">        Basically just sets x, y, z of the matrix. Does not change its</span>
<span class="sd">        direction or up vectors.</span>

<span class="sd">        Args:</span>
<span class="sd">          pos: Position list ([x, y, z])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="s2">&quot;Object&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add child to this object.</span>

<span class="sd">        In a basic example:</span>

<span class="sd">            .. include:: ../../../examples/basics/05_children.py</span>

<span class="sd">        Args:</span>
<span class="sd">          name: Name of the object, must be unique within its siblings</span>
<span class="sd">          obj: Object. Must be an instance of</span>
<span class="sd">               `payton.scene.geometry.base.Object`</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool: False in case of an error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Name {name} exists in object children&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Object</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Object type is not valid&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">to_absolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return local coordinates (tuple, list) into absolute coordinates in</span>
<span class="sd">        space.</span>

<span class="sd">        Args:</span>
<span class="sd">          coordinates: List[float] (x, y, z)</span>

<span class="sd">        Returns:</span>
<span class="sd">          List[float] (x&#39;, y&#39;, z&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">vector_transform</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">absolute_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return a map of all local vertices as absolute coordinates.</span>

<span class="sd">        Imagine that object B is a child of object A. In this case, B will</span>
<span class="sd">        always stand (follow) relative to A. If you want to know the exact</span>
<span class="sd">        world coordinates of all vertices in B, this method will return them.</span>

<span class="sd">        **Important!** This is a costly operation so use with caution!</span>

<span class="sd">        Returns:</span>
<span class="sd">          map(List[List[float]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_absolute</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">toggle_wireframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Toggle wireframe view of the Object&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">display</span>
        <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">%</span> <span class="mi">3</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">toggle_wireframe</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_calc_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the bounding sphere radius</span>

<span class="sd">        Returns:</span>
<span class="sd">          float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bmin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">bmax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bmin</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
            <span class="n">bmax</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bmin</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="p">)]</span>
            <span class="n">bmax</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">z</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">bmax</span><span class="p">,</span> <span class="n">bmin</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="o">=</span> <span class="p">[</span><span class="n">bmin</span><span class="p">,</span> <span class="n">bmax</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounding_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return bounding radius</span>

<span class="sd">        This property function *WILL NOT* update the previously</span>
<span class="sd">        calculated value. If you add vertices to the object, you must call</span>
<span class="sd">        `payton.scene.geometry.base.Object.refresh` function to get radius</span>
<span class="sd">        and the whole object updated.</span>

<span class="sd">        Returns:</span>
<span class="sd">          float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bounds</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build OpenGL Vertex Array for the object</span>

<span class="sd">        This function gets automatically called if material&#39;s `._vao` does not</span>
<span class="sd">        exists in the first render cycle. Once the vba is built,</span>
<span class="sd">        geometry changes or material display mode changes will not be</span>
<span class="sd">        automatically effected. So, in every geometry or display mode</span>
<span class="sd">        change, a `build` call is necessary.</span>

<span class="sd">        If `self.static` is `True`, then the system assumes that another update</span>
<span class="sd">        call is not expected, thus frees `_normals`, `_textcoords`,</span>
<span class="sd">        `_vertices` and `_indices` lists to free memory.</span>
<span class="sd">        So in this case, calling `build` function twice will result in</span>
<span class="sd">        an invisible object (will not be drawn).</span>

<span class="sd">        Additionally, this method goes through each material mapping and</span>
<span class="sd">        build their indices as well. Each material map has its own</span>
<span class="sd">        Vertex Array Object and gets rendered by separate glDrawElements</span>
<span class="sd">        call.</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Turn python arrays into C type arrays using Numpy.</span>
        <span class="c1"># This is required for OpenGL. Python memory model is a bit</span>
        <span class="c1"># different than raw memory model of C (OpenGL)</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_normals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">texcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_INDICE</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

        <span class="c1"># We will let all materials to share the same buffer objects</span>
        <span class="c1"># We need 4 buffers (vertex, normal, texcoord, color)</span>

        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bounds</span><span class="p">()</span>

        <span class="c1"># OpenGL allocates buffers in different mechanisms between</span>
        <span class="c1"># STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL</span>
        <span class="c1"># will assume that object buffer will not change and allocate it in a</span>
        <span class="c1"># more suitable way.</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">GL_STATIC_DRAW</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
            <span class="n">draw</span> <span class="o">=</span> <span class="n">GL_DYNAMIC_DRAW</span>

        <span class="c1"># Buffer overflow, we need more space.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">&lt;</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span> <span class="o">&lt;</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span> <span class="o">=</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1"># Bind Vertices</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
            <span class="c1"># glBufferData creates a new data area</span>
            <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># glBufferSubData just replaces memory area in buffer so it is</span>
            <span class="c1"># much more efficient way to handle things.</span>
            <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>

        <span class="c1"># Bind Normals</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
            <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">normals</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">normals</span><span class="p">)</span>

        <span class="c1"># Bind TexCoords</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span><span class="p">:</span>
                <span class="n">glBufferData</span><span class="p">(</span>
                    <span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="n">draw</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">glBufferSubData</span><span class="p">(</span>
                    <span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">texcoords</span>
                <span class="p">)</span>

        <span class="c1"># Bind Vertex Colors</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
                <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>

        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_INDICE</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
                <span class="c1"># Generate Vertex Array</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># We need 1 buffer for material as indices</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="p">[</span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
                <span class="c1"># Material shader must be built when there is an active binding</span>
                <span class="c1"># to vertex array</span>
                <span class="n">material</span><span class="o">.</span><span class="n">build_shader</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we already have vertex array object, just bind it to modify</span>
                <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="c1"># Bind Vertices</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
            <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1"># Bind Normals</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
            <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1"># Bind TexCoords</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
                <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
                <span class="n">glVertexAttribPointer</span><span class="p">(</span>
                    <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Bind Vertex Colors</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
                <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
                <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
                <span class="n">glVertexAttribPointer</span><span class="p">(</span>
                    <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Bind Indices</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">material</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">glBufferData</span><span class="p">(</span>
                <span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">draw</span>
            <span class="p">)</span>
            <span class="n">i_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="n">i_len</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">+=</span> <span class="n">i_len</span>

            <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
            <span class="c1"># we can clear this data to free some more memory</span>
            <span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>


<span class="k">class</span> <span class="nc">Line</span><span class="p">(</span><span class="n">Object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Line object</span>

<span class="sd">    Exceptionally, due to hard reference for motion path feature, this class</span>
<span class="sd">    is defined in base.py instead of line.py</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vertices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VList</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Iniitalize line</span>

<span class="sd">        Args:</span>
<span class="sd">          vertices: Vertices array for list of points.</span>
<span class="sd">          color: Color of the line</span>

<span class="sd">        Example use case:</span>

<span class="sd">            .. include:: ../../../examples/basics/17_line.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span> <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">color</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># Do not clear the vertices each time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">WIREFRAME</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_lines</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">toggle_wireframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Toggle Wireframe overwrite to disable mode change&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">add_material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;@TODO Implement this later! Not urgent&quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Can&#39;t add materials to Line object&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">:</span> <span class="n">VList</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Append vertex or vertices to line.</span>

<span class="sd">        Args:</span>
<span class="sd">          vertices: Vertex array of points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>  <span class="c1"># Number of vertices added</span>
        <span class="n">last_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">+=</span> <span class="n">vertices</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span> <span class="o">+=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">diff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normals</span> <span class="o">+=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">diff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">last_index</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">indices</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">build_lines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vertices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VList</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Build lines</span>

<span class="sd">        Build line vertex array object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normals</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_missing_vao</span><span class="p">:</span>
            <span class="c1"># This is a dynamic object, destroying the object is not a good</span>
            <span class="c1"># idea so we just update the buffer here.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
</pre></div>

  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="payton.scene.geometry.base.DEFAULT" class="name">var <span class="ident">DEFAULT</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="payton.scene.geometry.base.NO_INDICE" class="name">var <span class="ident">NO_INDICE</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="payton.scene.geometry.base.NO_VERTEX_ARRAY" class="name">var <span class="ident">NO_VERTEX_ARRAY</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="payton.scene.geometry.base.POINTS" class="name">var <span class="ident">POINTS</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="payton.scene.geometry.base.SOLID" class="name">var <span class="ident">SOLID</span></p>
      
  
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="payton.scene.geometry.base.WIREFRAME" class="name">var <span class="ident">WIREFRAME</span></p>
      
  
  <div class="source_cont">
</div>

      </div>


    <h2 class="section-title" id="header-classes">Classes</h2>
      
      <div class="item">
      <p id="payton.scene.geometry.base.Line" class="name">class <span class="ident">Line</span></p>
      
  
    <div class="desc"><p>Line object</p>
<p>Exceptionally, due to hard reference for motion path feature, this class
is defined in base.py instead of line.py</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Line</span><span class="p">(</span><span class="n">Object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Line object</span>

<span class="sd">    Exceptionally, due to hard reference for motion path feature, this class</span>
<span class="sd">    is defined in base.py instead of line.py</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vertices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VList</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Iniitalize line</span>

<span class="sd">        Args:</span>
<span class="sd">          vertices: Vertices array for list of points.</span>
<span class="sd">          color: Color of the line</span>

<span class="sd">        Example use case:</span>

<span class="sd">            .. include:: ../../../examples/basics/17_line.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">vertices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span> <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">color</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># Do not clear the vertices each time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">WIREFRAME</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_lines</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">toggle_wireframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Toggle Wireframe overwrite to disable mode change&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">add_material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;@TODO Implement this later! Not urgent&quot;&quot;&quot;</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Can&#39;t add materials to Line object&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">:</span> <span class="n">VList</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Append vertex or vertices to line.</span>

<span class="sd">        Args:</span>
<span class="sd">          vertices: Vertex array of points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>  <span class="c1"># Number of vertices added</span>
        <span class="n">last_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">+=</span> <span class="n">vertices</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span> <span class="o">+=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">diff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normals</span> <span class="o">+=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">diff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>

        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">last_index</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">indices</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">build_lines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">vertices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VList</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Build lines</span>

<span class="sd">        Build line vertex array object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">vertices</span>
        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_normals</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_missing_vao</span><span class="p">:</span>
            <span class="c1"># This is a dynamic object, destroying the object is not a good</span>
            <span class="c1"># idea so we just update the buffer here.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#payton.scene.geometry.base.Line">Line</a></li>
          <li><a href="#payton.scene.geometry.base.Object">Object</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, vertices=None, color=None, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Iniitalize line</p>
<p>Args:
  vertices: Vertices array for list of points.
  color: Color of the line</p>
<p>Example use case:</p>
<div class="codehilite"><pre><span></span>.. <span class="k">include</span>:: ..<span class="o">/</span>..<span class="o">/</span>..<span class="o">/</span><span class="nv">examples</span><span class="o">/</span><span class="nv">basics</span><span class="o">/</span><span class="mi">17</span><span class="nv">_line</span>.<span class="nv">py</span>
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.__init__', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">vertices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VList</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
    <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Iniitalize line</span>
<span class="sd">    Args:</span>
<span class="sd">      vertices: Vertices array for list of points.</span>
<span class="sd">      color: Color of the line</span>
<span class="sd">    Example use case:</span>
<span class="sd">        .. include:: ../../../examples/basics/17_line.py</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">vertices</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span> <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">color</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># Do not clear the vertices each time.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">WIREFRAME</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">build_lines</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.absolute_vertices">
    <p>def <span class="ident">absolute_vertices</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a map of all local vertices as absolute coordinates.</p>
<p>Imagine that object B is a child of object A. In this case, B will
always stand (follow) relative to A. If you want to know the exact
world coordinates of all vertices in B, this method will return them.</p>
<p><strong>Important!</strong> This is a costly operation so use with caution!</p>
<p>Returns:
  map(List[List[float]])</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.absolute_vertices', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.absolute_vertices" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">absolute_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Return a map of all local vertices as absolute coordinates.</span>
<span class="sd">    Imagine that object B is a child of object A. In this case, B will</span>
<span class="sd">    always stand (follow) relative to A. If you want to know the exact</span>
<span class="sd">    world coordinates of all vertices in B, this method will return them.</span>
<span class="sd">    **Important!** This is a costly operation so use with caution!</span>
<span class="sd">    Returns:</span>
<span class="sd">      map(List[List[float]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_absolute</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.add_child">
    <p>def <span class="ident">add_child</span>(</p><p>self, name, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Add child to this object.</p>
<p>In a basic example:</p>
<div class="codehilite"><pre><span></span>.. <span class="k">include</span>:: ..<span class="o">/</span>..<span class="o">/</span>..<span class="o">/</span><span class="nv">examples</span><span class="o">/</span><span class="nv">basics</span><span class="o">/</span><span class="mi">05</span><span class="nv">_children</span>.<span class="nv">py</span>
</pre></div>


<p>Args:
  name: Name of the object, must be unique within its siblings
  obj: Object. Must be an instance of
       <a href="#payton.scene.geometry.base.Object"><code>Object</code></a></p>
<p>Returns:
  bool: False in case of an error</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.add_child', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.add_child" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="s2">&quot;Object&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add child to this object.</span>
<span class="sd">    In a basic example:</span>
<span class="sd">        .. include:: ../../../examples/basics/05_children.py</span>
<span class="sd">    Args:</span>
<span class="sd">      name: Name of the object, must be unique within its siblings</span>
<span class="sd">      obj: Object. Must be an instance of</span>
<span class="sd">           `payton.scene.geometry.base.Object`</span>
<span class="sd">    Returns:</span>
<span class="sd">      bool: False in case of an error</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Name {name} exists in object children&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Object</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Object type is not valid&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.add_material">
    <p>def <span class="ident">add_material</span>(</p><p>self, name, material)</p>
    </div>
    

    
  
    <div class="desc"><p>@TODO Implement this later! Not urgent</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.add_material', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.add_material" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;@TODO Implement this later! Not urgent&quot;&quot;&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Can&#39;t add materials to Line object&quot;</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.append">
    <p>def <span class="ident">append</span>(</p><p>self, vertices, material=&#39;default&#39;)</p>
    </div>
    

    
  
    <div class="desc"><p>Append vertex or vertices to line.</p>
<p>Args:
  vertices: Vertex array of points.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.append', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.append" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">:</span> <span class="n">VList</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Append vertex or vertices to line.</span>
<span class="sd">    Args:</span>
<span class="sd">      vertices: Vertex array of points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>  <span class="c1"># Number of vertices added</span>
    <span class="n">last_index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">+=</span> <span class="n">vertices</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span> <span class="o">+=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">diff</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_normals</span> <span class="o">+=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="n">diff</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="n">last_index</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="p">)))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">indices</span><span class="p">])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.build">
    <p>def <span class="ident">build</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Build OpenGL Vertex Array for the object</p>
<p>This function gets automatically called if material's <code>._vao</code> does not
exists in the first render cycle. Once the vba is built,
geometry changes or material display mode changes will not be
automatically effected. So, in every geometry or display mode
change, a <code>build</code> call is necessary.</p>
<p>If <code>self.static</code> is <code>True</code>, then the system assumes that another update
call is not expected, thus frees <code>_normals</code>, <code>_textcoords</code>,
<code>_vertices</code> and <code>_indices</code> lists to free memory.
So in this case, calling <code>build</code> function twice will result in
an invisible object (will not be drawn).</p>
<p>Additionally, this method goes through each material mapping and
build their indices as well. Each material map has its own
Vertex Array Object and gets rendered by separate glDrawElements
call.</p>
<p>Returns:
  bool</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.build', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.build" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build OpenGL Vertex Array for the object</span>
<span class="sd">    This function gets automatically called if material&#39;s `._vao` does not</span>
<span class="sd">    exists in the first render cycle. Once the vba is built,</span>
<span class="sd">    geometry changes or material display mode changes will not be</span>
<span class="sd">    automatically effected. So, in every geometry or display mode</span>
<span class="sd">    change, a `build` call is necessary.</span>
<span class="sd">    If `self.static` is `True`, then the system assumes that another update</span>
<span class="sd">    call is not expected, thus frees `_normals`, `_textcoords`,</span>
<span class="sd">    `_vertices` and `_indices` lists to free memory.</span>
<span class="sd">    So in this case, calling `build` function twice will result in</span>
<span class="sd">    an invisible object (will not be drawn).</span>
<span class="sd">    Additionally, this method goes through each material mapping and</span>
<span class="sd">    build their indices as well. Each material map has its own</span>
<span class="sd">    Vertex Array Object and gets rendered by separate glDrawElements</span>
<span class="sd">    call.</span>
<span class="sd">    Returns:</span>
<span class="sd">      bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Turn python arrays into C type arrays using Numpy.</span>
    <span class="c1"># This is required for OpenGL. Python memory model is a bit</span>
    <span class="c1"># different than raw memory model of C (OpenGL)</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_normals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">texcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_INDICE</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="c1"># We will let all materials to share the same buffer objects</span>
    <span class="c1"># We need 4 buffers (vertex, normal, texcoord, color)</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bounds</span><span class="p">()</span>
    <span class="c1"># OpenGL allocates buffers in different mechanisms between</span>
    <span class="c1"># STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL</span>
    <span class="c1"># will assume that object buffer will not change and allocate it in a</span>
    <span class="c1"># more suitable way.</span>
    <span class="n">draw</span> <span class="o">=</span> <span class="n">GL_STATIC_DRAW</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">GL_DYNAMIC_DRAW</span>
    <span class="c1"># Buffer overflow, we need more space.</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">&lt;</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span> <span class="o">&lt;</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span> <span class="o">=</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="c1"># Bind Vertices</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
        <span class="c1"># glBufferData creates a new data area</span>
        <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># glBufferSubData just replaces memory area in buffer so it is</span>
        <span class="c1"># much more efficient way to handle things.</span>
        <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
    <span class="c1"># Bind Normals</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
        <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">normals</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">normals</span><span class="p">)</span>
    <span class="c1"># Bind TexCoords</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span><span class="p">:</span>
            <span class="n">glBufferData</span><span class="p">(</span>
                <span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="n">draw</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glBufferSubData</span><span class="p">(</span>
                <span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">texcoords</span>
            <span class="p">)</span>
    <span class="c1"># Bind Vertex Colors</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
            <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_INDICE</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
            <span class="c1"># Generate Vertex Array</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># We need 1 buffer for material as indices</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="p">[</span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
            <span class="c1"># Material shader must be built when there is an active binding</span>
            <span class="c1"># to vertex array</span>
            <span class="n">material</span><span class="o">.</span><span class="n">build_shader</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we already have vertex array object, just bind it to modify</span>
            <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="c1"># Bind Vertices</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
        <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Bind Normals</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
        <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Bind TexCoords</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
            <span class="n">glVertexAttribPointer</span><span class="p">(</span>
                <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Bind Vertex Colors</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
            <span class="n">glVertexAttribPointer</span><span class="p">(</span>
                <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Bind Indices</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">material</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">glBufferData</span><span class="p">(</span>
            <span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">draw</span>
        <span class="p">)</span>
        <span class="n">i_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="n">i_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">+=</span> <span class="n">i_len</span>
        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
        <span class="c1"># we can clear this data to free some more memory</span>
        <span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.build_lines">
    <p>def <span class="ident">build_lines</span>(</p><p>self, vertices=None, color=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Build lines</p>
<p>Build line vertex array object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.build_lines', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.build_lines" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">build_lines</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">vertices</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">VList</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
    <span class="n">color</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Build lines</span>
<span class="sd">    Build line vertex array object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">vertices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span> <span class="o">=</span> <span class="n">vertices</span>
    <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">color</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normals</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_missing_vao</span><span class="p">:</span>
        <span class="c1"># This is a dynamic object, destroying the object is not a good</span>
        <span class="c1"># idea so we just update the buffer here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Destroy objects self.</p>
<p>Returns:
    bool: <code>True</code> on successful destroy of <code>self</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.destroy', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.destroy" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Destroy objects self.</span>
<span class="sd">    Returns:</span>
<span class="sd">        bool: `True` on successful destroy of `self`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
            <span class="n">glDeleteVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">])</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
        <span class="n">glDeleteVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.direct_to">
    <p>def <span class="ident">direct_to</span>(</p><p>self, v)</p>
    </div>
    

    
  
    <div class="desc"><p>Direct the objects forward towards given point vector</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.direct_to', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.direct_to" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">direct_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Direct the objects forward towards given point vector&quot;&quot;&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">sub_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">diff</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.forward">
    <p>def <span class="ident">forward</span>(</p><p>self, distance)</p>
    </div>
    

    
  
    <div class="desc"><p>Move object forward</p>
<p>This method calculates to motion path according to direction
of the object's matrix. <code>self.matrix[1]</code> indicates the direction.</p>
<p>So matrix position gets updated according to direction * distance</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.forward', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.forward" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Move object forward</span>
<span class="sd">    This method calculates to motion path according to direction</span>
<span class="sd">    of the object&#39;s matrix. `self.matrix[1]` indicates the direction.</span>
<span class="sd">    So matrix position gets updated according to direction * distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">scale_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">distance</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_vectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">diff</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.hide">
    <p>def <span class="ident">hide</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.hide', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.hide" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">hide</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.refresh">
    <p>def <span class="ident">refresh</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Refresh object</p>
<p>Forces object to get built again</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.refresh', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.refresh" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Refresh object</span>
<span class="sd">    Forces object to get built again</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.render">
    <p>def <span class="ident">render</span>(</p><p>self, proj, view, lights, parent_matrix=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Virtual function for rendering the object. Some objects can overwrite
this function.</p>
<p>Args:
  proj: Camera projection matrix.
  view: Camera location/view matrix.
  lights: Light objects in the scene
  parent_matrix: Parent matrix is the matrix of the parent. Parent can
                 be the scene itself or another object. In case of
                 another object, object will position itself relative
                 to its parent object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.render', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.render" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">render</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">proj</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">view</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">lights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Light</span><span class="p">],</span>
    <span class="n">parent_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Virtual function for rendering the object. Some objects can overwrite</span>
<span class="sd">    this function.</span>
<span class="sd">    Args:</span>
<span class="sd">      proj: Camera projection matrix.</span>
<span class="sd">      view: Camera location/view matrix.</span>
<span class="sd">      lights: Light objects in the scene</span>
<span class="sd">      parent_matrix: Parent matrix is the matrix of the parent. Parent can</span>
<span class="sd">                     be the scene itself or another object. In case of</span>
<span class="sd">                     another object, object will position itself relative</span>
<span class="sd">                     to its parent object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_missing_vao</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">update_matrix</span><span class="p">(</span><span class="n">parent_matrix</span><span class="o">=</span><span class="n">parent_matrix</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># dummy object, render children and leave</span>
        <span class="c1"># render children</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">render</span><span class="p">(</span>
                <span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span>
            <span class="p">)</span>
        <span class="k">return</span>
    <span class="c1"># Material shading mode.</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">Shader</span><span class="o">.</span><span class="n">PER_VERTEX_COLOR</span>
    <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">material</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="c1"># Actual rendering</span>
        <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span> <span class="ow">and</span> <span class="n">glIsVertexArray</span><span class="p">(</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vao</span>
        <span class="p">):</span>
            <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
            <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_LINE</span>
            <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_LINE_STRIP</span>
            <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="n">SOLID</span><span class="p">:</span>
                <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_FILL</span>
                <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_TRIANGLES</span>
            <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="n">POINTS</span><span class="p">:</span>
                <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_POINT</span>
                <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_POINTS</span>
            <span class="n">glPolygonMode</span><span class="p">(</span><span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span> <span class="n">pmode</span><span class="p">)</span>
            <span class="n">glDrawElements</span><span class="p">(</span>
                <span class="n">primitive</span><span class="p">,</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">,</span>
                <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">pmode</span> <span class="o">!=</span> <span class="n">GL_FILL</span><span class="p">:</span>
                <span class="n">glPolygonMode</span><span class="p">(</span><span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span> <span class="n">GL_FILL</span><span class="p">)</span>
            <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># End using the shader program.</span>
        <span class="n">material</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
    <span class="c1"># Render motion path</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="n">parent_matrix</span><span class="p">)</span>
    <span class="c1"># render children</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.rotate_around_x">
    <p>def <span class="ident">rotate_around_x</span>(</p><p>self, angle)</p>
    </div>
    

    
  
    <div class="desc"><p>Pitch - Rotate around X axis</p>
<p>Args:
  angle: Angle in radians</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.rotate_around_x', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.rotate_around_x" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">rotate_around_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Pitch - Rotate around X axis</span>
<span class="sd">    Args:</span>
<span class="sd">      angle: Angle in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.rotate_around_y">
    <p>def <span class="ident">rotate_around_y</span>(</p><p>self, angle)</p>
    </div>
    

    
  
    <div class="desc"><p>Roll - Rotate around Y Axis (Direction)</p>
<p>Args:
  angle: Angle in radians</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.rotate_around_y', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.rotate_around_y" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">rotate_around_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Roll - Rotate around Y Axis (Direction)</span>
<span class="sd">    Args:</span>
<span class="sd">      angle: Angle in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.rotate_around_z">
    <p>def <span class="ident">rotate_around_z</span>(</p><p>self, angle)</p>
    </div>
    

    
  
    <div class="desc"><p>Rotate around Z Axis</p>
<p>Args:
  angle: Angle in radians</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.rotate_around_z', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.rotate_around_z" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">rotate_around_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Rotate around Z Axis</span>
<span class="sd">    Args:</span>
<span class="sd">      angle: Angle in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.select">
    <p>def <span class="ident">select</span>(</p><p>self, start, vector)</p>
    </div>
    

    
  
    <div class="desc"><p>Select test for object using bounding Sphere.</p>
<p>This method is not 100% accurate as it is based on a rough
assumption. Sphere area will be larger than actual object.</p>
<p>If you want to have a more accurate way to handle this, try
using raycast triangle intersect</p>
<p>Args:
  start: Starting point of the ray (such as eye position)
  vector: Ray direction. This is not the end point of a line!
          This is a unit vector showing the ray direction.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.select', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.select" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Select test for object using bounding Sphere.</span>
<span class="sd">    This method is not 100% accurate as it is based on a rough</span>
<span class="sd">    assumption. Sphere area will be larger than actual object.</span>
<span class="sd">    If you want to have a more accurate way to handle this, try</span>
<span class="sd">    using raycast triangle intersect</span>
<span class="sd">    Args:</span>
<span class="sd">      start: Starting point of the ray (such as eye position)</span>
<span class="sd">      vector: Ray direction. This is not the end point of a line!</span>
<span class="sd">              This is a unit vector showing the ray direction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="o">=</span> <span class="n">raycast_sphere_intersect</span><span class="p">(</span>
        <span class="n">start</span><span class="p">,</span>
        <span class="n">vector</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="ow">and</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.show">
    <p>def <span class="ident">show</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.show', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.show" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.step_back">
    <p>def <span class="ident">step_back</span>(</p><p>self, steps=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Go back N step in time</p>
<p>This is suitable for solving collisions and getting a step back.
On the other hand, this function requires <code>track_motion</code> to be
True.</p>
<p>Args:
  steps: Number of steps to go back. (Default = 1)</p>
<p>Returns:
  bool: If step back is successful</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.step_back', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.step_back" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">step_back</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Go back N step in time</span>
<span class="sd">    This is suitable for solving collisions and getting a step back.</span>
<span class="sd">    On the other hand, this function requires `track_motion` to be</span>
<span class="sd">    True.</span>
<span class="sd">    Args:</span>
<span class="sd">      steps: Number of steps to go back. (Default = 1)</span>
<span class="sd">    Returns:</span>
<span class="sd">      bool: If step back is successful</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;track_motion should be True&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">[</span><span class="o">-</span><span class="n">steps</span><span class="p">]</span>
    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">[</span><span class="o">-</span><span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>  <span class="c1"># noqa</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.to_absolute">
    <p>def <span class="ident">to_absolute</span>(</p><p>self, coordinates)</p>
    </div>
    

    
  
    <div class="desc"><p>Return local coordinates (tuple, list) into absolute coordinates in
space.</p>
<p>Args:
  coordinates: List[float] (x, y, z)</p>
<p>Returns:
  List[float] (x', y', z')</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.to_absolute', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.to_absolute" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_absolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return local coordinates (tuple, list) into absolute coordinates in</span>
<span class="sd">    space.</span>
<span class="sd">    Args:</span>
<span class="sd">      coordinates: List[float] (x, y, z)</span>
<span class="sd">    Returns:</span>
<span class="sd">      List[float] (x&#39;, y&#39;, z&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">vector_transform</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.toggle_wireframe">
    <p>def <span class="ident">toggle_wireframe</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Toggle Wireframe overwrite to disable mode change</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.toggle_wireframe', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.toggle_wireframe" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">toggle_wireframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Toggle Wireframe overwrite to disable mode change&quot;&quot;&quot;</span>
    <span class="k">pass</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.track">
    <p>def <span class="ident">track</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Track object motion</p>
<p>Returns:
    bool: <code>True</code> on successful tracking of <code>self</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.track', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.track" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">track</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Track object motion</span>
<span class="sd">    Returns:</span>
<span class="sd">        bool: `True` on successful tracking of `self`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="c1"># Add the new matrix to motion path records</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">))</span>
    <span class="c1"># Add the matrix position to motion math line for visualisation</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]]]</span>
        <span class="p">)</span>
    <span class="c1"># Python trick here! need to .copy or it will pass reference.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Line.update_matrix">
    <p>def <span class="ident">update_matrix</span>(</p><p>self, parent_matrix=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Update matrix</p>
<p>Turn object matrix into numpy array.</p>
<p>Args:
  parent_matrix: Parent objects matrix</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Line.update_matrix', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Line.update_matrix" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">update_matrix</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">parent_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Update matrix</span>
<span class="sd">    Turn object matrix into numpy array.</span>
<span class="sd">    Args:</span>
<span class="sd">      parent_matrix: Parent objects matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Turn matrix into numpy array. Numpy arrays are C Type arrays</span>
    <span class="c1"># suitable for OpenGL Pipeline</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># When there is a parent object, child object follows parents matrix</span>
    <span class="k">if</span> <span class="n">parent_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_matrix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">parent_matrix</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="payton.scene.geometry.base.Line.bounding_radius" class="name">var <span class="ident">bounding_radius</span></p>
            
    <p class="inheritance">
     <strong>Inheritance:</strong>
       <code><a href="#payton.scene.geometry.base.Object">Object</a></code>.<code><a href="#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code>
    </p>

            
  
    <div class="desc inherited"><p>Return bounding radius</p>
<p>This property function <em>WILL NOT</em> update the previously
calculated value. If you add vertices to the object, you must call
<a href="#payton.scene.geometry.base.Object.refresh"><code>refresh</code></a> function to get radius
and the whole object updated.</p>
<p>Returns:
  float</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Line.direction" class="name">var <span class="ident">direction</span></p>
            

            
  
    <div class="desc"><p>Get direction vector from Matrix</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Line.has_missing_vao" class="name">var <span class="ident">has_missing_vao</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Line.material" class="name">var <span class="ident">material</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Line.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>Get position of the Object.</p>
<p>Return matrix position list</p>
<p>Returns:
  List[float]</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Line.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>Check if object is visible</p>
<p>Returns:
  bool: <code>True</code> if visible.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>
      
      <div class="item">
      <p id="payton.scene.geometry.base.Object" class="name">class <span class="ident">Object</span></p>
      
  
    <div class="desc"><p>Main Payton Object.</p>
<p>This is an abstract class to define common properties and methods between
Mesh / Cube / Sphere/ Shape2D / PointCloud, etc.</p>
<p>Objects are not actually built as 3D vertex arrays until they are rendered.
Render function calls <code>build</code> function if needed. Build function creates
the OpenGL Vertex Array Object. VAO is static data so, once the object
is built, changing vertices or indices will not take effect at the scene.</p>
<p>You need to call <a href="#payton.scene.geometry.base.Object.build"><code>build</code></a> function to
refresh Vertex Array Object.</p>
<p>OpenGL can not magically extend a memory buffer, so for every new vertices
added to the object, OpenGL needs to re-create the buffer area. This is
not an efficitient technique if number of vertices increase in time.
As a result Payton allocates buffer for 500 vertices in the beginning and
uses part of it. If the object exceeds 500 vertices, a new buffer is
created with 500 vertices more, copies existing vertices to the new
buffer and the old buffer is deleted.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object" class="source">
    <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Object</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Main Payton Object.</span>

<span class="sd">    This is an abstract class to define common properties and methods between</span>
<span class="sd">    Mesh / Cube / Sphere/ Shape2D / PointCloud, etc.</span>

<span class="sd">    Objects are not actually built as 3D vertex arrays until they are rendered.</span>
<span class="sd">    Render function calls `build` function if needed. Build function creates</span>
<span class="sd">    the OpenGL Vertex Array Object. VAO is static data so, once the object</span>
<span class="sd">    is built, changing vertices or indices will not take effect at the scene.</span>

<span class="sd">    You need to call `payton.scene.geometry.base.Object.build` function to</span>
<span class="sd">    refresh Vertex Array Object.</span>

<span class="sd">    OpenGL can not magically extend a memory buffer, so for every new vertices</span>
<span class="sd">    added to the object, OpenGL needs to re-create the buffer area. This is</span>
<span class="sd">    not an efficitient technique if number of vertices increase in time.</span>
<span class="sd">    As a result Payton allocates buffer for 500 vertices in the beginning and</span>
<span class="sd">    uses part of it. If the object exceeds 500 vertices, a new buffer is</span>
<span class="sd">    created with 500 vertices more, copies existing vertices to the new</span>
<span class="sd">    buffer and the old buffer is deleted.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">static</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="n">visible</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">track_motion</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the basic object properties.</span>

<span class="sd">        Properties:</span>
<span class="sd">          children: Children hash for object. Each child object follows parent</span>
<span class="sd">                    object. They take their parent object as origin and their</span>
<span class="sd">                    coordinate system is relative to their parent. This</span>
<span class="sd">                    behaviour resembles stars, planets and their moons.</span>
<span class="sd">          material: Material definitions of the object.</span>
<span class="sd">          matrix: Matrix definition of the object. This is a 4x4 Uniform Matrix</span>
<span class="sd">                  but data is set as an array for easier transformations. First</span>
<span class="sd">                  4 decimals are &quot;Left&quot; vector, second 4 are &quot;Direction&quot;, third</span>
<span class="sd">                  4 are &quot;Up&quot; and last four decimals are &quot;Position&quot; vectors.</span>

<span class="sd">        Args:</span>
<span class="sd">          track_motion: Track object motion (default: false). Object tracking</span>
<span class="sd">                        is time independent. It just saves the object matrix</span>
<span class="sd">                        for every change. Uses matrix position for drawing the</span>
<span class="sd">                        motion path.</span>
<span class="sd">          static: (Default `True`) Indicates if object geometry is expected</span>
<span class="sd">                  to be changed in the future. If object is not static, then</span>
<span class="sd">                  its&#39; vertex buffer object references and vertex informations</span>
<span class="sd">                  will not be deleted to be used for future reference.</span>
<span class="sd">          name: Name of the object (optional, default &#39;&#39;) Note that, when</span>
<span class="sd">                object gets added to a Scene with a name, Scene will assign</span>
<span class="sd">                that name to the object, overwriting any existing name of the</span>
<span class="sd">                object.</span>
<span class="sd">          visible: Is this object visible at the scene, default: `True`. To</span>
<span class="sd">                   hide an object, you can call `object.hide()` and to show</span>
<span class="sd">                   it again use: `object.show()`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Object</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># store diffeerent materials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Material</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">DEFAULT</span><span class="p">:</span> <span class="n">Material</span><span class="p">()}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">static</span> <span class="o">=</span> <span class="n">static</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="n">visible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
            <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="p">]</span>
        <span class="c1"># Object vertices. Each vertex has 3 decimals (X, Y, Z). Vertices</span>
        <span class="c1"># are continuous. [X, Y, Z, X, Y, Z, X, Y, Z, X, ... ]</span>
        <span class="c1">#                  -- 1 --  -- 2 --  -- 3 --  -- 4 --</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Object vertex list</span>

        <span class="c1"># @NOTE: we have separate indices for materials but this base</span>
        <span class="c1">#        index list holds all indice definitions for fast access</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">:</span> <span class="n">IList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_normals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Vertex normals, 1 normal coordinate for 1 Vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Texture coordinates, 1 coordinate per Vertex</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
        <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># per-vertex colors, optional.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># flag for using vertex colors</span>

        <span class="c1"># Vertices do not mean anything unless we define how to use them.</span>
        <span class="c1"># For instance, 3 vertices make a triangle or 2 vertices define a line</span>
        <span class="c1"># order of vertices are defined in materials indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Number of vertices to report to OpenGL.</span>

        <span class="c1"># This is an optimization technique for dynamic objects where there are</span>
        <span class="c1"># increasing number of vertices. We allocate some buffer before-hand</span>
        <span class="c1"># and if we fill all of it, we resize it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">12</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Model matrix.</span>
        <span class="c1"># Check if buffer size allocated for the object has changed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1"># Track object motion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span> <span class="o">=</span> <span class="n">track_motion</span>
        <span class="c1"># Motion path, stores every matrix change.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">VList</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Line</span><span class="p">):</span>
            <span class="c1"># _motion_path_line is used to display the motion path in scene</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span> <span class="o">=</span> <span class="n">Line</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># For raycast tests - bounding radius is the radius of the bounding</span>
        <span class="c1"># sphere.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c1"># Vertex Array Object pointer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># Object geometry has changed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Refresh object</span>

<span class="sd">        Forces object to get built again</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">material</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Material</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">DEFAULT</span><span class="p">]</span>

    <span class="nd">@material.setter</span>
    <span class="k">def</span> <span class="nf">material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">DEFAULT</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span>

    <span class="k">def</span> <span class="nf">add_material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add a material to the object.</span>

<span class="sd">        Keep in mind that, adding material does not refer to the material</span>
<span class="sd">        but does it through deepcopy. Initially, material holds indice</span>
<span class="sd">        and vertex buffer objectt references. In order to prevent user</span>
<span class="sd">        from breaking the objects, we create the clone of the material.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Name {name} already exists&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">material</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">direction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get direction vector from Matrix&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span>

    <span class="nd">@direction.setter</span>
    <span class="k">def</span> <span class="nf">direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Set direction vector of Matrix</span>

<span class="sd">        Attention! This needs to be a unit vector!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Direction needs 3 components (x,y,z)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">cross_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">left</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">up</span> <span class="o">=</span> <span class="n">cross_product</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">up</span> <span class="o">+=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">up</span>

    <span class="k">def</span> <span class="nf">direct_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Direct the objects forward towards given point vector&quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">sub_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">diff</span>

    <span class="k">def</span> <span class="nf">rotate_around_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Rotate around Z Axis</span>

<span class="sd">        Args:</span>
<span class="sd">          angle: Angle in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">rotate_around_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Pitch - Rotate around X axis</span>

<span class="sd">        Args:</span>
<span class="sd">          angle: Angle in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">rotate_around_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Roll - Rotate around Y Axis (Direction)</span>

<span class="sd">        Args:</span>
<span class="sd">          angle: Angle in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Select test for object using bounding Sphere.</span>

<span class="sd">        This method is not 100% accurate as it is based on a rough</span>
<span class="sd">        assumption. Sphere area will be larger than actual object.</span>

<span class="sd">        If you want to have a more accurate way to handle this, try</span>
<span class="sd">        using raycast triangle intersect</span>

<span class="sd">        Args:</span>
<span class="sd">          start: Starting point of the ray (such as eye position)</span>
<span class="sd">          vector: Ray direction. This is not the end point of a line!</span>
<span class="sd">                  This is a unit vector showing the ray direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="o">=</span> <span class="n">raycast_sphere_intersect</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">vector</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="ow">and</span> <span class="n">x</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span>

    <span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Destroy objects self.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: `True` on successful destroy of `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
                <span class="n">glDeleteVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">])</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
            <span class="n">glDeleteVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">step_back</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Go back N step in time</span>

<span class="sd">        This is suitable for solving collisions and getting a step back.</span>
<span class="sd">        On the other hand, this function requires `track_motion` to be</span>
<span class="sd">        True.</span>

<span class="sd">        Args:</span>
<span class="sd">          steps: Number of steps to go back. (Default = 1)</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool: If step back is successful</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;track_motion should be True&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">[</span><span class="o">-</span><span class="n">steps</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">[</span><span class="o">-</span><span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>  <span class="c1"># noqa</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Move object forward</span>

<span class="sd">        This method calculates to motion path according to direction</span>
<span class="sd">        of the object&#39;s matrix. `self.matrix[1]` indicates the direction.</span>

<span class="sd">        So matrix position gets updated according to direction * distance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">scale_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">distance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_vectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">diff</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="k">def</span> <span class="nf">update_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">parent_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Update matrix</span>

<span class="sd">        Turn object matrix into numpy array.</span>

<span class="sd">        Args:</span>
<span class="sd">          parent_matrix: Parent objects matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Turn matrix into numpy array. Numpy arrays are C Type arrays</span>
        <span class="c1"># suitable for OpenGL Pipeline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># When there is a parent object, child object follows parents matrix</span>
        <span class="k">if</span> <span class="n">parent_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_matrix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">parent_matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">track</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Track object motion</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: `True` on successful tracking of `self`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c1"># Add the new matrix to motion path records</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">))</span>
        <span class="c1"># Add the matrix position to motion math line for visualisation</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]]]</span>
            <span class="p">)</span>

        <span class="c1"># Python trick here! need to .copy or it will pass reference.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">visible</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Check if object is visible</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool: `True` if visible.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span>

    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">hide</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">has_missing_vao</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_VERTEX_ARRAY</span>
                <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">proj</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">view</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
        <span class="n">lights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Light</span><span class="p">],</span>
        <span class="n">parent_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Virtual function for rendering the object. Some objects can overwrite</span>
<span class="sd">        this function.</span>

<span class="sd">        Args:</span>
<span class="sd">          proj: Camera projection matrix.</span>
<span class="sd">          view: Camera location/view matrix.</span>
<span class="sd">          lights: Light objects in the scene</span>
<span class="sd">          parent_matrix: Parent matrix is the matrix of the parent. Parent can</span>
<span class="sd">                         be the scene itself or another object. In case of</span>
<span class="sd">                         another object, object will position itself relative</span>
<span class="sd">                         to its parent object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_missing_vao</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_matrix</span><span class="p">(</span><span class="n">parent_matrix</span><span class="o">=</span><span class="n">parent_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># dummy object, render children and leave</span>
            <span class="c1"># render children</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">render</span><span class="p">(</span>
                    <span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span>
                <span class="p">)</span>

            <span class="k">return</span>

        <span class="c1"># Material shading mode.</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">Shader</span><span class="o">.</span><span class="n">PER_VERTEX_COLOR</span>

        <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">material</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

            <span class="c1"># Actual rendering</span>
            <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span> <span class="ow">and</span> <span class="n">glIsVertexArray</span><span class="p">(</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vao</span>
            <span class="p">):</span>
                <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
                <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_LINE</span>
                <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_LINE_STRIP</span>
                <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="n">SOLID</span><span class="p">:</span>
                    <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_FILL</span>
                    <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_TRIANGLES</span>
                <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="n">POINTS</span><span class="p">:</span>
                    <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_POINT</span>
                    <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_POINTS</span>
                <span class="n">glPolygonMode</span><span class="p">(</span><span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span> <span class="n">pmode</span><span class="p">)</span>

                <span class="n">glDrawElements</span><span class="p">(</span>
                    <span class="n">primitive</span><span class="p">,</span>
                    <span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">,</span>
                    <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span>
                    <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">pmode</span> <span class="o">!=</span> <span class="n">GL_FILL</span><span class="p">:</span>
                    <span class="n">glPolygonMode</span><span class="p">(</span><span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span> <span class="n">GL_FILL</span><span class="p">)</span>
                <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># End using the shader program.</span>
            <span class="n">material</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>

        <span class="c1"># Render motion path</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="n">parent_matrix</span><span class="p">)</span>

        <span class="c1"># render children</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get position of the Object.</span>

<span class="sd">        Return matrix position list</span>

<span class="sd">        Returns:</span>
<span class="sd">          List[float]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][:</span><span class="mi">3</span><span class="p">]</span>

    <span class="nd">@position.setter</span>
    <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shortcut function for explicitly modifying matrix indices.</span>

<span class="sd">        Basically just sets x, y, z of the matrix. Does not change its</span>
<span class="sd">        direction or up vectors.</span>

<span class="sd">        Args:</span>
<span class="sd">          pos: Position list ([x, y, z])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">[</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="s2">&quot;Object&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Add child to this object.</span>

<span class="sd">        In a basic example:</span>

<span class="sd">            .. include:: ../../../examples/basics/05_children.py</span>

<span class="sd">        Args:</span>
<span class="sd">          name: Name of the object, must be unique within its siblings</span>
<span class="sd">          obj: Object. Must be an instance of</span>
<span class="sd">               `payton.scene.geometry.base.Object`</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool: False in case of an error</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Name {name} exists in object children&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Object</span><span class="p">):</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Object type is not valid&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">to_absolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return local coordinates (tuple, list) into absolute coordinates in</span>
<span class="sd">        space.</span>

<span class="sd">        Args:</span>
<span class="sd">          coordinates: List[float] (x, y, z)</span>

<span class="sd">        Returns:</span>
<span class="sd">          List[float] (x&#39;, y&#39;, z&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">vector_transform</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">absolute_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Return a map of all local vertices as absolute coordinates.</span>

<span class="sd">        Imagine that object B is a child of object A. In this case, B will</span>
<span class="sd">        always stand (follow) relative to A. If you want to know the exact</span>
<span class="sd">        world coordinates of all vertices in B, this method will return them.</span>

<span class="sd">        **Important!** This is a costly operation so use with caution!</span>

<span class="sd">        Returns:</span>
<span class="sd">          map(List[List[float]])</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_absolute</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">toggle_wireframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Toggle wireframe view of the Object&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">display</span>
        <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">%</span> <span class="mi">3</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">d</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">toggle_wireframe</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_calc_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculate the bounding sphere radius</span>

<span class="sd">        Returns:</span>
<span class="sd">          float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bmin</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">bmax</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">]</span>
        <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bmin</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
            <span class="n">bmax</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bmin</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">z</span><span class="p">)]</span>
            <span class="n">bmax</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">z</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">bmax</span><span class="p">,</span> <span class="n">bmin</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span> <span class="o">=</span> <span class="p">[</span><span class="n">bmin</span><span class="p">,</span> <span class="n">bmax</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bounding_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Return bounding radius</span>

<span class="sd">        This property function *WILL NOT* update the previously</span>
<span class="sd">        calculated value. If you add vertices to the object, you must call</span>
<span class="sd">        `payton.scene.geometry.base.Object.refresh` function to get radius</span>
<span class="sd">        and the whole object updated.</span>

<span class="sd">        Returns:</span>
<span class="sd">          float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bounds</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build OpenGL Vertex Array for the object</span>

<span class="sd">        This function gets automatically called if material&#39;s `._vao` does not</span>
<span class="sd">        exists in the first render cycle. Once the vba is built,</span>
<span class="sd">        geometry changes or material display mode changes will not be</span>
<span class="sd">        automatically effected. So, in every geometry or display mode</span>
<span class="sd">        change, a `build` call is necessary.</span>

<span class="sd">        If `self.static` is `True`, then the system assumes that another update</span>
<span class="sd">        call is not expected, thus frees `_normals`, `_textcoords`,</span>
<span class="sd">        `_vertices` and `_indices` lists to free memory.</span>
<span class="sd">        So in this case, calling `build` function twice will result in</span>
<span class="sd">        an invisible object (will not be drawn).</span>

<span class="sd">        Additionally, this method goes through each material mapping and</span>
<span class="sd">        build their indices as well. Each material map has its own</span>
<span class="sd">        Vertex Array Object and gets rendered by separate glDrawElements</span>
<span class="sd">        call.</span>

<span class="sd">        Returns:</span>
<span class="sd">          bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Turn python arrays into C type arrays using Numpy.</span>
        <span class="c1"># This is required for OpenGL. Python memory model is a bit</span>
        <span class="c1"># different than raw memory model of C (OpenGL)</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_normals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">texcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_INDICE</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

        <span class="c1"># We will let all materials to share the same buffer objects</span>
        <span class="c1"># We need 4 buffers (vertex, normal, texcoord, color)</span>

        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bounds</span><span class="p">()</span>

        <span class="c1"># OpenGL allocates buffers in different mechanisms between</span>
        <span class="c1"># STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL</span>
        <span class="c1"># will assume that object buffer will not change and allocate it in a</span>
        <span class="c1"># more suitable way.</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">GL_STATIC_DRAW</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
            <span class="n">draw</span> <span class="o">=</span> <span class="n">GL_DYNAMIC_DRAW</span>

        <span class="c1"># Buffer overflow, we need more space.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">&lt;</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span> <span class="o">&lt;</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span> <span class="o">=</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1"># Bind Vertices</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
            <span class="c1"># glBufferData creates a new data area</span>
            <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># glBufferSubData just replaces memory area in buffer so it is</span>
            <span class="c1"># much more efficient way to handle things.</span>
            <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>

        <span class="c1"># Bind Normals</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
            <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">normals</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">normals</span><span class="p">)</span>

        <span class="c1"># Bind TexCoords</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span><span class="p">:</span>
                <span class="n">glBufferData</span><span class="p">(</span>
                    <span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="n">draw</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">glBufferSubData</span><span class="p">(</span>
                    <span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">texcoords</span>
                <span class="p">)</span>

        <span class="c1"># Bind Vertex Colors</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
                <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>

        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_INDICE</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
                <span class="c1"># Generate Vertex Array</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># We need 1 buffer for material as indices</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="p">[</span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
                <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
                <span class="c1"># Material shader must be built when there is an active binding</span>
                <span class="c1"># to vertex array</span>
                <span class="n">material</span><span class="o">.</span><span class="n">build_shader</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we already have vertex array object, just bind it to modify</span>
                <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

            <span class="c1"># Bind Vertices</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
            <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1"># Bind Normals</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
            <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

            <span class="c1"># Bind TexCoords</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
                <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
                <span class="n">glVertexAttribPointer</span><span class="p">(</span>
                    <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Bind Vertex Colors</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
                <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
                <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
                <span class="n">glVertexAttribPointer</span><span class="p">(</span>
                    <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="c1"># Bind Indices</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">material</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">glBufferData</span><span class="p">(</span>
                <span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">draw</span>
            <span class="p">)</span>
            <span class="n">i_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="n">i_len</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">+=</span> <span class="n">i_len</span>

            <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
            <span class="c1"># we can clear this data to free some more memory</span>
            <span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>


      <div class="class">
          <h3>Ancestors (in MRO)</h3>
          <ul class="class_list">
          <li><a href="#payton.scene.geometry.base.Object">Object</a></li>
          <li>builtins.object</li>
          </ul>
          <h3>Static methods</h3>
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.__init__">
    <p>def <span class="ident">__init__</span>(</p><p>self, static=True, name=&#39;&#39;, visible=True, track_motion=False, **kwargs)</p>
    </div>
    

    
  
    <div class="desc"><p>Initialize the basic object properties.</p>
<p>Properties:
  children: Children hash for object. Each child object follows parent
            object. They take their parent object as origin and their
            coordinate system is relative to their parent. This
            behaviour resembles stars, planets and their moons.
  material: Material definitions of the object.
  matrix: Matrix definition of the object. This is a 4x4 Uniform Matrix
          but data is set as an array for easier transformations. First
          4 decimals are "Left" vector, second 4 are "Direction", third
          4 are "Up" and last four decimals are "Position" vectors.</p>
<p>Args:
  track_motion: Track object motion (default: false). Object tracking
                is time independent. It just saves the object matrix
                for every change. Uses matrix position for drawing the
                motion path.
  static: (Default <code>True</code>) Indicates if object geometry is expected
          to be changed in the future. If object is not static, then
          its' vertex buffer object references and vertex informations
          will not be deleted to be used for future reference.
  name: Name of the object (optional, default '') Note that, when
        object gets added to a Scene with a name, Scene will assign
        that name to the object, overwriting any existing name of the
        object.
  visible: Is this object visible at the scene, default: <code>True</code>. To
           hide an object, you can call <code>object.hide()</code> and to show
           it again use: <code>object.show()</code></p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.__init__', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.__init__" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">static</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">visible</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">track_motion</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the basic object properties.</span>
<span class="sd">    Properties:</span>
<span class="sd">      children: Children hash for object. Each child object follows parent</span>
<span class="sd">                object. They take their parent object as origin and their</span>
<span class="sd">                coordinate system is relative to their parent. This</span>
<span class="sd">                behaviour resembles stars, planets and their moons.</span>
<span class="sd">      material: Material definitions of the object.</span>
<span class="sd">      matrix: Matrix definition of the object. This is a 4x4 Uniform Matrix</span>
<span class="sd">              but data is set as an array for easier transformations. First</span>
<span class="sd">              4 decimals are &quot;Left&quot; vector, second 4 are &quot;Direction&quot;, third</span>
<span class="sd">              4 are &quot;Up&quot; and last four decimals are &quot;Position&quot; vectors.</span>
<span class="sd">    Args:</span>
<span class="sd">      track_motion: Track object motion (default: false). Object tracking</span>
<span class="sd">                    is time independent. It just saves the object matrix</span>
<span class="sd">                    for every change. Uses matrix position for drawing the</span>
<span class="sd">                    motion path.</span>
<span class="sd">      static: (Default `True`) Indicates if object geometry is expected</span>
<span class="sd">              to be changed in the future. If object is not static, then</span>
<span class="sd">              its&#39; vertex buffer object references and vertex informations</span>
<span class="sd">              will not be deleted to be used for future reference.</span>
<span class="sd">      name: Name of the object (optional, default &#39;&#39;) Note that, when</span>
<span class="sd">            object gets added to a Scene with a name, Scene will assign</span>
<span class="sd">            that name to the object, overwriting any existing name of the</span>
<span class="sd">            object.</span>
<span class="sd">      visible: Is this object visible at the scene, default: `True`. To</span>
<span class="sd">               hide an object, you can call `object.hide()` and to show</span>
<span class="sd">               it again use: `object.show()`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Object</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># store diffeerent materials</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Material</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">DEFAULT</span><span class="p">:</span> <span class="n">Material</span><span class="p">()}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">static</span> <span class="o">=</span> <span class="n">static</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="n">visible</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
    <span class="p">]</span>
    <span class="c1"># Object vertices. Each vertex has 3 decimals (X, Y, Z). Vertices</span>
    <span class="c1"># are continuous. [X, Y, Z, X, Y, Z, X, Y, Z, X, ... ]</span>
    <span class="c1">#                  -- 1 --  -- 2 --  -- 3 --  -- 4 --</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Object vertex list</span>
    <span class="c1"># @NOTE: we have separate indices for materials but this base</span>
    <span class="c1">#        index list holds all indice definitions for fast access</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">:</span> <span class="n">IList</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Indices</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_normals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Vertex normals, 1 normal coordinate for 1 Vertex</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Texture coordinates, 1 coordinate per Vertex</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># per-vertex colors, optional.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># flag for using vertex colors</span>
    <span class="c1"># Vertices do not mean anything unless we define how to use them.</span>
    <span class="c1"># For instance, 3 vertices make a triangle or 2 vertices define a line</span>
    <span class="c1"># order of vertices are defined in materials indices</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Number of vertices to report to OpenGL.</span>
    <span class="c1"># This is an optimization technique for dynamic objects where there are</span>
    <span class="c1"># increasing number of vertices. We allocate some buffer before-hand</span>
    <span class="c1"># and if we fill all of it, we resize it.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">12</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">500</span> <span class="o">*</span> <span class="mi">8</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Model matrix.</span>
    <span class="c1"># Check if buffer size allocated for the object has changed.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="c1"># Track object motion</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span> <span class="o">=</span> <span class="n">track_motion</span>
    <span class="c1"># Motion path, stores every matrix change.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">VList</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Line</span><span class="p">):</span>
        <span class="c1"># _motion_path_line is used to display the motion path in scene</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span> <span class="o">=</span> <span class="n">Line</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c1"># For raycast tests - bounding radius is the radius of the bounding</span>
    <span class="c1"># sphere.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_box</span><span class="p">:</span> <span class="n">VList</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="c1"># Vertex Array Object pointer</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>  <span class="c1"># Object geometry has changed.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_hit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.absolute_vertices">
    <p>def <span class="ident">absolute_vertices</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Return a map of all local vertices as absolute coordinates.</p>
<p>Imagine that object B is a child of object A. In this case, B will
always stand (follow) relative to A. If you want to know the exact
world coordinates of all vertices in B, this method will return them.</p>
<p><strong>Important!</strong> This is a costly operation so use with caution!</p>
<p>Returns:
  map(List[List[float]])</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.absolute_vertices', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.absolute_vertices" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">absolute_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
    <span class="sd">&quot;&quot;&quot;Return a map of all local vertices as absolute coordinates.</span>
<span class="sd">    Imagine that object B is a child of object A. In this case, B will</span>
<span class="sd">    always stand (follow) relative to A. If you want to know the exact</span>
<span class="sd">    world coordinates of all vertices in B, this method will return them.</span>
<span class="sd">    **Important!** This is a costly operation so use with caution!</span>
<span class="sd">    Returns:</span>
<span class="sd">      map(List[List[float]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_absolute</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.add_child">
    <p>def <span class="ident">add_child</span>(</p><p>self, name, obj)</p>
    </div>
    

    
  
    <div class="desc"><p>Add child to this object.</p>
<p>In a basic example:</p>
<div class="codehilite"><pre><span></span>.. <span class="k">include</span>:: ..<span class="o">/</span>..<span class="o">/</span>..<span class="o">/</span><span class="nv">examples</span><span class="o">/</span><span class="nv">basics</span><span class="o">/</span><span class="mi">05</span><span class="nv">_children</span>.<span class="nv">py</span>
</pre></div>


<p>Args:
  name: Name of the object, must be unique within its siblings
  obj: Object. Must be an instance of
       <a href="#payton.scene.geometry.base.Object"><code>Object</code></a></p>
<p>Returns:
  bool: False in case of an error</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.add_child', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.add_child" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_child</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="s2">&quot;Object&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add child to this object.</span>
<span class="sd">    In a basic example:</span>
<span class="sd">        .. include:: ../../../examples/basics/05_children.py</span>
<span class="sd">    Args:</span>
<span class="sd">      name: Name of the object, must be unique within its siblings</span>
<span class="sd">      obj: Object. Must be an instance of</span>
<span class="sd">           `payton.scene.geometry.base.Object`</span>
<span class="sd">    Returns:</span>
<span class="sd">      bool: False in case of an error</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Name {name} exists in object children&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Object</span><span class="p">):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Object type is not valid&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.add_material">
    <p>def <span class="ident">add_material</span>(</p><p>self, name, material)</p>
    </div>
    

    
  
    <div class="desc"><p>Add a material to the object.</p>
<p>Keep in mind that, adding material does not refer to the material
but does it through deepcopy. Initially, material holds indice
and vertex buffer objectt references. In order to prevent user
from breaking the objects, we create the clone of the material.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.add_material', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.add_material" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">add_material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">material</span><span class="p">:</span> <span class="n">Material</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Add a material to the object.</span>
<span class="sd">    Keep in mind that, adding material does not refer to the material</span>
<span class="sd">    but does it through deepcopy. Initially, material holds indice</span>
<span class="sd">    and vertex buffer objectt references. In order to prevent user</span>
<span class="sd">    from breaking the objects, we create the clone of the material.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Name {name} already exists&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">material</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.build">
    <p>def <span class="ident">build</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Build OpenGL Vertex Array for the object</p>
<p>This function gets automatically called if material's <code>._vao</code> does not
exists in the first render cycle. Once the vba is built,
geometry changes or material display mode changes will not be
automatically effected. So, in every geometry or display mode
change, a <code>build</code> call is necessary.</p>
<p>If <code>self.static</code> is <code>True</code>, then the system assumes that another update
call is not expected, thus frees <code>_normals</code>, <code>_textcoords</code>,
<code>_vertices</code> and <code>_indices</code> lists to free memory.
So in this case, calling <code>build</code> function twice will result in
an invisible object (will not be drawn).</p>
<p>Additionally, this method goes through each material mapping and
build their indices as well. Each material map has its own
Vertex Array Object and gets rendered by separate glDrawElements
call.</p>
<p>Returns:
  bool</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.build', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.build" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build OpenGL Vertex Array for the object</span>
<span class="sd">    This function gets automatically called if material&#39;s `._vao` does not</span>
<span class="sd">    exists in the first render cycle. Once the vba is built,</span>
<span class="sd">    geometry changes or material display mode changes will not be</span>
<span class="sd">    automatically effected. So, in every geometry or display mode</span>
<span class="sd">    change, a `build` call is necessary.</span>
<span class="sd">    If `self.static` is `True`, then the system assumes that another update</span>
<span class="sd">    call is not expected, thus frees `_normals`, `_textcoords`,</span>
<span class="sd">    `_vertices` and `_indices` lists to free memory.</span>
<span class="sd">    So in this case, calling `build` function twice will result in</span>
<span class="sd">    an invisible object (will not be drawn).</span>
<span class="sd">    Additionally, this method goes through each material mapping and</span>
<span class="sd">    build their indices as well. Each material map has its own</span>
<span class="sd">    Vertex Array Object and gets rendered by separate glDrawElements</span>
<span class="sd">    call.</span>
<span class="sd">    Returns:</span>
<span class="sd">      bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Turn python arrays into C type arrays using Numpy.</span>
    <span class="c1"># This is required for OpenGL. Python memory model is a bit</span>
    <span class="c1"># different than raw memory model of C (OpenGL)</span>
    <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">normals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_normals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">texcoords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_INDICE</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="c1"># We will let all materials to share the same buffer objects</span>
    <span class="c1"># We need 4 buffers (vertex, normal, texcoord, color)</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_calc_bounds</span><span class="p">()</span>
    <span class="c1"># OpenGL allocates buffers in different mechanisms between</span>
    <span class="c1"># STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL</span>
    <span class="c1"># will assume that object buffer will not change and allocate it in a</span>
    <span class="c1"># more suitable way.</span>
    <span class="n">draw</span> <span class="o">=</span> <span class="n">GL_STATIC_DRAW</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="n">GL_DYNAMIC_DRAW</span>
    <span class="c1"># Buffer overflow, we need more space.</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">&lt;</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span> <span class="o">=</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span> <span class="o">&lt;</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span> <span class="o">=</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="c1"># Bind Vertices</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
        <span class="c1"># glBufferData creates a new data area</span>
        <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">vertices</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># glBufferSubData just replaces memory area in buffer so it is</span>
        <span class="c1"># much more efficient way to handle things.</span>
        <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">vertices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">vertices</span><span class="p">)</span>
    <span class="c1"># Bind Normals</span>
    <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
        <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">normals</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">normals</span><span class="p">)</span>
    <span class="c1"># Bind TexCoords</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span><span class="p">:</span>
            <span class="n">glBufferData</span><span class="p">(</span>
                <span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size</span><span class="p">,</span> <span class="n">texcoords</span><span class="p">,</span> <span class="n">draw</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glBufferSubData</span><span class="p">(</span>
                <span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">texcoords</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">texcoords</span>
            <span class="p">)</span>
    <span class="c1"># Bind Vertex Colors</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span><span class="p">:</span>
            <span class="n">glBufferData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">draw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">glBufferSubData</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">colors</span><span class="p">)</span>
    <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_size_changed</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_t_buffer_size_changed</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_INDICE</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">==</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
            <span class="c1"># Generate Vertex Array</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">glGenVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># We need 1 buffer for material as indices</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="p">[</span><span class="n">glGenBuffers</span><span class="p">(</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
            <span class="c1"># Material shader must be built when there is an active binding</span>
            <span class="c1"># to vertex array</span>
            <span class="n">material</span><span class="o">.</span><span class="n">build_shader</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we already have vertex array object, just bind it to modify</span>
            <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_indices</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="c1"># Bind Vertices</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
        <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Bind Normals</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
        <span class="n">glVertexAttribPointer</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="c1"># Bind TexCoords</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_texcoords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
            <span class="n">glVertexAttribPointer</span><span class="p">(</span>
                <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Bind Vertex Colors</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertex_colors</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_vertices</span><span class="p">):</span>
            <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">4</span><span class="p">])</span>
            <span class="n">glEnableVertexAttribArray</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># shader layout location</span>
            <span class="n">glVertexAttribPointer</span><span class="p">(</span>
                <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">GL_FLOAT</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="c1"># Bind Indices</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">material</span><span class="o">.</span><span class="n">_vbos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">glBufferData</span><span class="p">(</span>
            <span class="n">GL_ELEMENT_ARRAY_BUFFER</span><span class="p">,</span> <span class="n">indices</span><span class="o">.</span><span class="n">nbytes</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">draw</span>
        <span class="p">)</span>
        <span class="n">i_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">=</span> <span class="n">i_len</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">+=</span> <span class="n">i_len</span>
        <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">glBindBuffer</span><span class="p">(</span><span class="n">GL_ARRAY_BUFFER</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">static</span><span class="p">:</span>
        <span class="c1"># we can clear this data to free some more memory</span>
        <span class="n">glDeleteBuffers</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vbos</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.destroy">
    <p>def <span class="ident">destroy</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Destroy objects self.</p>
<p>Returns:
    bool: <code>True</code> on successful destroy of <code>self</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.destroy', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.destroy" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Destroy objects self.</span>
<span class="sd">    Returns:</span>
<span class="sd">        bool: `True` on successful destroy of `self`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
            <span class="n">glDeleteVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">])</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span><span class="p">:</span>
        <span class="n">glDeleteVertexArrays</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_vao</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vao</span> <span class="o">=</span> <span class="n">NO_VERTEX_ARRAY</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.direct_to">
    <p>def <span class="ident">direct_to</span>(</p><p>self, v)</p>
    </div>
    

    
  
    <div class="desc"><p>Direct the objects forward towards given point vector</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.direct_to', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.direct_to" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">direct_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;Direct the objects forward towards given point vector&quot;&quot;&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">sub_vector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">normalize_vector</span><span class="p">(</span><span class="n">diff</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">diff</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.forward">
    <p>def <span class="ident">forward</span>(</p><p>self, distance)</p>
    </div>
    

    
  
    <div class="desc"><p>Move object forward</p>
<p>This method calculates to motion path according to direction
of the object's matrix. <code>self.matrix[1]</code> indicates the direction.</p>
<p>So matrix position gets updated according to direction * distance</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.forward', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.forward" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Move object forward</span>
<span class="sd">    This method calculates to motion path according to direction</span>
<span class="sd">    of the object&#39;s matrix. `self.matrix[1]` indicates the direction.</span>
<span class="sd">    So matrix position gets updated according to direction * distance</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">scale_vector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">distance</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_vectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">diff</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.hide">
    <p>def <span class="ident">hide</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.hide', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.hide" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">hide</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="bp">False</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.refresh">
    <p>def <span class="ident">refresh</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Refresh object</p>
<p>Forces object to get built again</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.refresh', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.refresh" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Refresh object</span>
<span class="sd">    Forces object to get built again</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.render">
    <p>def <span class="ident">render</span>(</p><p>self, proj, view, lights, parent_matrix=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Virtual function for rendering the object. Some objects can overwrite
this function.</p>
<p>Args:
  proj: Camera projection matrix.
  view: Camera location/view matrix.
  lights: Light objects in the scene
  parent_matrix: Parent matrix is the matrix of the parent. Parent can
                 be the scene itself or another object. In case of
                 another object, object will position itself relative
                 to its parent object.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.render', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.render" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">render</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">proj</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">view</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">lights</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Light</span><span class="p">],</span>
    <span class="n">parent_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Virtual function for rendering the object. Some objects can overwrite</span>
<span class="sd">    this function.</span>
<span class="sd">    Args:</span>
<span class="sd">      proj: Camera projection matrix.</span>
<span class="sd">      view: Camera location/view matrix.</span>
<span class="sd">      lights: Light objects in the scene</span>
<span class="sd">      parent_matrix: Parent matrix is the matrix of the parent. Parent can</span>
<span class="sd">                     be the scene itself or another object. In case of</span>
<span class="sd">                     another object, object will position itself relative</span>
<span class="sd">                     to its parent object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_missing_vao</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_needs_update</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">update_matrix</span><span class="p">(</span><span class="n">parent_matrix</span><span class="o">=</span><span class="n">parent_matrix</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">track</span><span class="p">()</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vertex_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># dummy object, render children and leave</span>
        <span class="c1"># render children</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">render</span><span class="p">(</span>
                <span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span>
            <span class="p">)</span>
        <span class="k">return</span>
    <span class="c1"># Material shading mode.</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_vertex_colors</span><span class="p">:</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">Shader</span><span class="o">.</span><span class="n">PER_VERTEX_COLOR</span>
    <span class="k">for</span> <span class="n">material</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">material</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
        <span class="c1"># Actual rendering</span>
        <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">_vao</span> <span class="o">&gt;</span> <span class="n">NO_VERTEX_ARRAY</span> <span class="ow">and</span> <span class="n">glIsVertexArray</span><span class="p">(</span>
            <span class="n">material</span><span class="o">.</span><span class="n">_vao</span>
        <span class="p">):</span>
            <span class="n">glBindVertexArray</span><span class="p">(</span><span class="n">material</span><span class="o">.</span><span class="n">_vao</span><span class="p">)</span>
            <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_LINE</span>
            <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_LINE_STRIP</span>
            <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="n">SOLID</span><span class="p">:</span>
                <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_FILL</span>
                <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_TRIANGLES</span>
            <span class="k">if</span> <span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">==</span> <span class="n">POINTS</span><span class="p">:</span>
                <span class="n">pmode</span> <span class="o">=</span> <span class="n">GL_POINT</span>
                <span class="n">primitive</span> <span class="o">=</span> <span class="n">GL_POINTS</span>
            <span class="n">glPolygonMode</span><span class="p">(</span><span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span> <span class="n">pmode</span><span class="p">)</span>
            <span class="n">glDrawElements</span><span class="p">(</span>
                <span class="n">primitive</span><span class="p">,</span>
                <span class="n">material</span><span class="o">.</span><span class="n">_vertex_count</span><span class="p">,</span>
                <span class="n">GL_UNSIGNED_INT</span><span class="p">,</span>
                <span class="n">ctypes</span><span class="o">.</span><span class="n">c_void_p</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">pmode</span> <span class="o">!=</span> <span class="n">GL_FILL</span><span class="p">:</span>
                <span class="n">glPolygonMode</span><span class="p">(</span><span class="n">GL_FRONT_AND_BACK</span><span class="p">,</span> <span class="n">GL_FILL</span><span class="p">)</span>
            <span class="n">glBindVertexArray</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># End using the shader program.</span>
        <span class="n">material</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
    <span class="c1"># Render motion path</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="n">parent_matrix</span><span class="p">)</span>
    <span class="c1"># render children</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">child</span><span class="p">]</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.rotate_around_x">
    <p>def <span class="ident">rotate_around_x</span>(</p><p>self, angle)</p>
    </div>
    

    
  
    <div class="desc"><p>Pitch - Rotate around X axis</p>
<p>Args:
  angle: Angle in radians</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.rotate_around_x', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.rotate_around_x" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">rotate_around_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Pitch - Rotate around X axis</span>
<span class="sd">    Args:</span>
<span class="sd">      angle: Angle in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.rotate_around_y">
    <p>def <span class="ident">rotate_around_y</span>(</p><p>self, angle)</p>
    </div>
    

    
  
    <div class="desc"><p>Roll - Rotate around Y Axis (Direction)</p>
<p>Args:
  angle: Angle in radians</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.rotate_around_y', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.rotate_around_y" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">rotate_around_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Roll - Rotate around Y Axis (Direction)</span>
<span class="sd">    Args:</span>
<span class="sd">      angle: Angle in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.rotate_around_z">
    <p>def <span class="ident">rotate_around_z</span>(</p><p>self, angle)</p>
    </div>
    

    
  
    <div class="desc"><p>Rotate around Z Axis</p>
<p>Args:
  angle: Angle in radians</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.rotate_around_z', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.rotate_around_z" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">rotate_around_z</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Rotate around Z Axis</span>
<span class="sd">    Args:</span>
<span class="sd">      angle: Angle in radians</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rot_matrix</span> <span class="o">=</span> <span class="n">create_rotation_matrix</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">angle</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">local_matrix</span> <span class="o">=</span> <span class="n">rot_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">local_matrix</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">local_matrix</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.select">
    <p>def <span class="ident">select</span>(</p><p>self, start, vector)</p>
    </div>
    

    
  
    <div class="desc"><p>Select test for object using bounding Sphere.</p>
<p>This method is not 100% accurate as it is based on a rough
assumption. Sphere area will be larger than actual object.</p>
<p>If you want to have a more accurate way to handle this, try
using raycast triangle intersect</p>
<p>Args:
  start: Starting point of the ray (such as eye position)
  vector: Ray direction. This is not the end point of a line!
          This is a unit vector showing the ray direction.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.select', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.select" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">vector</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Select test for object using bounding Sphere.</span>
<span class="sd">    This method is not 100% accurate as it is based on a rough</span>
<span class="sd">    assumption. Sphere area will be larger than actual object.</span>
<span class="sd">    If you want to have a more accurate way to handle this, try</span>
<span class="sd">    using raycast triangle intersect</span>
<span class="sd">    Args:</span>
<span class="sd">      start: Starting point of the ray (such as eye position)</span>
<span class="sd">      vector: Ray direction. This is not the end point of a line!</span>
<span class="sd">              This is a unit vector showing the ray direction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="o">=</span> <span class="n">raycast_sphere_intersect</span><span class="p">(</span>
        <span class="n">start</span><span class="p">,</span>
        <span class="n">vector</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bounding_radius</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">vector</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="ow">and</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selected</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.show">
    <p>def <span class="ident">show</span>(</p><p>self)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.show', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.show" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_visible</span> <span class="o">=</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.step_back">
    <p>def <span class="ident">step_back</span>(</p><p>self, steps=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Go back N step in time</p>
<p>This is suitable for solving collisions and getting a step back.
On the other hand, this function requires <code>track_motion</code> to be
True.</p>
<p>Args:
  steps: Number of steps to go back. (Default = 1)</p>
<p>Returns:
  bool: If step back is successful</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.step_back', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.step_back" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">step_back</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Go back N step in time</span>
<span class="sd">    This is suitable for solving collisions and getting a step back.</span>
<span class="sd">    On the other hand, this function requires `track_motion` to be</span>
<span class="sd">    True.</span>
<span class="sd">    Args:</span>
<span class="sd">      steps: Number of steps to go back. (Default = 1)</span>
<span class="sd">    Returns:</span>
<span class="sd">      bool: If step back is successful</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">steps</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;track_motion should be True&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">steps</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">[</span><span class="o">-</span><span class="n">steps</span><span class="p">]</span>
    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="p">[</span><span class="o">-</span><span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>  <span class="c1"># noqa</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.to_absolute">
    <p>def <span class="ident">to_absolute</span>(</p><p>self, coordinates)</p>
    </div>
    

    
  
    <div class="desc"><p>Return local coordinates (tuple, list) into absolute coordinates in
space.</p>
<p>Args:
  coordinates: List[float] (x, y, z)</p>
<p>Returns:
  List[float] (x', y', z')</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.to_absolute', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.to_absolute" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">to_absolute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return local coordinates (tuple, list) into absolute coordinates in</span>
<span class="sd">    space.</span>
<span class="sd">    Args:</span>
<span class="sd">      coordinates: List[float] (x, y, z)</span>
<span class="sd">    Returns:</span>
<span class="sd">      List[float] (x&#39;, y&#39;, z&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">vector_transform</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.toggle_wireframe">
    <p>def <span class="ident">toggle_wireframe</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Toggle wireframe view of the Object</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.toggle_wireframe', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.toggle_wireframe" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">toggle_wireframe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Toggle wireframe view of the Object&quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">display</span>
    <span class="n">d</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">%</span> <span class="mi">3</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">d</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">toggle_wireframe</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.track">
    <p>def <span class="ident">track</span>(</p><p>self)</p>
    </div>
    

    
  
    <div class="desc"><p>Track object motion</p>
<p>Returns:
    bool: <code>True</code> on successful tracking of <code>self</code>.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.track', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.track" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">track</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Track object motion</span>
<span class="sd">    Returns:</span>
<span class="sd">        bool: `True` on successful tracking of `self`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">track_motion</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="c1"># Add the new matrix to motion path records</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">))</span>
    <span class="c1"># Add the matrix position to motion math line for visualisation</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_motion_path_line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]]]</span>
        <span class="p">)</span>
    <span class="c1"># Python trick here! need to .copy or it will pass reference.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_previous_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="bp">True</span>
</pre></div>

  </div>
</div>

  </div>
  
            
  <div class="item">
    <div class="name def" id="payton.scene.geometry.base.Object.update_matrix">
    <p>def <span class="ident">update_matrix</span>(</p><p>self, parent_matrix=None)</p>
    </div>
    

    
  
    <div class="desc"><p>Update matrix</p>
<p>Turn object matrix into numpy array.</p>
<p>Args:
  parent_matrix: Parent objects matrix</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-payton.scene.geometry.base.Object.update_matrix', this);">Show source &equiv;</a></p>
  <div id="source-payton.scene.geometry.base.Object.update_matrix" class="source">
    <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">update_matrix</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">parent_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Update matrix</span>
<span class="sd">    Turn object matrix into numpy array.</span>
<span class="sd">    Args:</span>
<span class="sd">      parent_matrix: Parent objects matrix</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Turn matrix into numpy array. Numpy arrays are C Type arrays</span>
    <span class="c1"># suitable for OpenGL Pipeline</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="c1"># When there is a parent object, child object follows parents matrix</span>
    <span class="k">if</span> <span class="n">parent_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">parent_matrix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_model_matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">parent_matrix</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
          <h3>Instance variables</h3>
            <div class="item">
            <p id="payton.scene.geometry.base.Object.bounding_radius" class="name">var <span class="ident">bounding_radius</span></p>
            

            
  
    <div class="desc"><p>Return bounding radius</p>
<p>This property function <em>WILL NOT</em> update the previously
calculated value. If you add vertices to the object, you must call
<a href="#payton.scene.geometry.base.Object.refresh"><code>refresh</code></a> function to get radius
and the whole object updated.</p>
<p>Returns:
  float</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Object.direction" class="name">var <span class="ident">direction</span></p>
            

            
  
    <div class="desc"><p>Get direction vector from Matrix</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Object.has_missing_vao" class="name">var <span class="ident">has_missing_vao</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Object.material" class="name">var <span class="ident">material</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Object.name" class="name">var <span class="ident">name</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Object.position" class="name">var <span class="ident">position</span></p>
            

            
  
    <div class="desc"><p>Get position of the Object.</p>
<p>Return matrix position list</p>
<p>Returns:
  List[float]</p></div>
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Object.static" class="name">var <span class="ident">static</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Object.track_motion" class="name">var <span class="ident">track_motion</span></p>
            

            
  
  <div class="source_cont">
</div>

            </div>
            <div class="item">
            <p id="payton.scene.geometry.base.Object.visible" class="name">var <span class="ident">visible</span></p>
            

            
  
    <div class="desc"><p>Check if object is visible</p>
<p>Returns:
  bool: <code>True</code> if visible.</p></div>
  <div class="source_cont">
</div>

            </div>
      </div>
      </div>

  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.2</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
