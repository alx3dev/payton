<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>payton.scene.geometry API documentation</title>
<meta name="description" content="Payton main geometry module …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{margin:40px auto;max-width:1200px;display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>payton.scene.geometry</code></h1>
</header>
<section id="section-intro">
<p>Payton main geometry module</p>
<p>Geometry module holds the basic geometry shapes. They are all inherited
from <a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object"><code>Object</code></a> class. They are as simple as possible.</p>
<p>Their face informations are generated at the initialization but vertex array
object is not generated until it arrives in render pipeline.</p>
<ul>
<li>Object</li>
<li>Material (<a title="payton.scene.material" href="../material.html"><code>payton.scene.material</code></a>)<ul>
<li>Shader (<a title="payton.scene.shader" href="../shader.html"><code>payton.scene.shader</code></a>)</li>
</ul>
</li>
</ul>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># pylama:ignore=W
&#34;&#34;&#34;
Payton main geometry module

Geometry module holds the basic geometry shapes. They are all inherited
from `payton.scene.geometry.base.Object` class. They are as simple as possible.

Their face informations are generated at the initialization but vertex array
object is not generated until it arrives in render pipeline.

* Object
  * Material (`payton.scene.material`)
    * Shader (`payton.scene.shader`)
&#34;&#34;&#34;
from payton.scene.geometry.base import Object, Line
from payton.scene.geometry.mesh import Mesh
from payton.scene.geometry.cylinder import Cylinder
from payton.scene.geometry.cube import Cube
from payton.scene.geometry.plane import Plane, MatrixPlane
from payton.scene.geometry.sphere import Sphere
from payton.scene.geometry.point import PointCloud
from payton.scene.geometry.md2 import MD2


__all__ = [
    &#34;Object&#34;,
    &#34;Line&#34;,
    &#34;Mesh&#34;,
    &#34;Cylinder&#34;,
    &#34;Cube&#34;,
    &#34;Plane&#34;,
    &#34;MatrixPlane&#34;,
    &#34;Sphere&#34;,
    &#34;PointCloud&#34;,
    &#34;MD2&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="payton.scene.geometry.base" href="base.html">payton.scene.geometry.base</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="payton.scene.geometry.cube" href="cube.html">payton.scene.geometry.cube</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="payton.scene.geometry.cylinder" href="cylinder.html">payton.scene.geometry.cylinder</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="payton.scene.geometry.md2" href="md2.html">payton.scene.geometry.md2</a></code></dt>
<dd>
<section class="desc"><p>ID Software Quake 2 Model File
Some parts of this file is based on the original work from:
…</p></section>
</dd>
<dt><code class="name"><a title="payton.scene.geometry.mesh" href="mesh.html">payton.scene.geometry.mesh</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="payton.scene.geometry.plane" href="plane.html">payton.scene.geometry.plane</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="payton.scene.geometry.point" href="point.html">payton.scene.geometry.point</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt><code class="name"><a title="payton.scene.geometry.sphere" href="sphere.html">payton.scene.geometry.sphere</a></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="payton.scene.geometry.Cube"><code class="flex name class">
<span>class <span class="ident">Cube</span></span>
<span>(</span><span>width=1.0, depth=1.0, height=1.0, from_corner=None, to_corner=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Cube object</p>
<p>This is a simple Cube object with width, height and depth.</p>
<p>Cube object use case:</p>
<pre><code>from payton.scene import Scene
from payton.scene.geometry import Cube

scene = Scene()
cube = Cube()

cube_by_corners = Cube(from_corner=[-3, -3, 1], to_corner=[-1, -1, 3])

scene.add_object("cube", cube)
scene.add_object("cube_by_corners", cube_by_corners)

scene.run()
</code></pre>
<p>Initialize Cube</p>
<p>There are two ways to initialize a cube. You can use width, depth,
height properties or you can specify two distant corners in space
as <code>from_corner</code> and <code>to_corner</code>.</p>
<p>Specifiying corners overwrites width, depth and height.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong></dt>
<dd>Width of the cube (size X)</dd>
<dt><strong><code>depth</code></strong></dt>
<dd>Depth of the cube (size Y)</dd>
<dt><strong><code>height</code></strong></dt>
<dd>Height of the cube (size Z)</dd>
<dt><strong><code>from_corner</code></strong></dt>
<dd>Starting point of the cube (Optional)</dd>
<dt><strong><code>to_corner</code></strong></dt>
<dd>End point of the cube (Optional)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Cube(Mesh):
    &#34;&#34;&#34;
    Cube object

    This is a simple Cube object with width, height and depth.

    Cube object use case:

        .. include:: ../../../examples/basics/02_cube.py

    &#34;&#34;&#34;

    def __init__(
        self,
        width: float = 1.0,
        depth: float = 1.0,
        height: float = 1.0,
        from_corner: Optional[List[float]] = None,
        to_corner: Optional[List[float]] = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize Cube

        There are two ways to initialize a cube. You can use width, depth,
        height properties or you can specify two distant corners in space
        as `from_corner` and `to_corner`.

        Specifiying corners overwrites width, depth and height.

        Args:
          width: Width of the cube (size X)
          depth: Depth of the cube (size Y)
          height: Height of the cube (size Z)
          from_corner: Starting point of the cube (Optional)
          to_corner: End point of the cube (Optional)
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        width *= 0.5
        depth *= 0.5
        height *= 0.5

        if from_corner is not None and to_corner is not None:
            vmin, vmax = min_max([from_corner, to_corner])

            width = (vmax[0] - vmin[0]) / 2
            depth = (vmax[1] - vmin[1]) / 2
            height = (vmax[2] - vmin[2]) / 2
            self.position = [
                vmin[0] + width,
                vmin[1] + depth,
                vmin[2] + height,
            ]

        _vertices = [
            [width, depth, height],
            [width, depth, -height],
            [width, -depth, height],
            [width, -depth, -height],
            [-width, depth, height],
            [-width, depth, -height],
            [-width, -depth, height],
            [-width, -depth, -height],
        ]

        _normals = [
            [0.0, 0.0, 1.0],
            [0.0, -1.0, 0.0],
            [-1.0, 0.0, 0.0],
            [0.0, 0.0, -1.0],
            [1.0, 0.0, 0.0],
            [0.0, 1.0, 0.0],
        ]

        _texcoords = [
            [0.50, 0.333333],
            [0.25, 0.000000],
            [0.25, 0.333333],
            [1.00, 0.333333],
            [0.75, 0.666666],
            [1.00, 0.666666],
            [0.75, 0.333333],
            [0.50, 0.666666],
            [0.25, 0.666666],
            [0.50, 1.000000],
            [0.50, 0.666666],
            [0.25, 0.333333],
            [0.00, 0.666666],
            [0.25, 0.666666],
            [0.50, 0.333333],
            [0.25, 0.666666],
            [0.50, 0.666666],
            [0.50, 0.000000],
            [0.50, 0.333333],
            [0.25, 1.000000],
            [0.00, 0.333333],
            [0.25, 0.333333],
        ]

        _faces = [
            [[4, 0, 0], [2, 1, 0], [0, 2, 0]],
            [[2, 3, 1], [7, 4, 1], [3, 5, 1]],
            [[6, 6, 2], [5, 7, 2], [7, 4, 2]],
            [[1, 8, 3], [7, 9, 3], [5, 10, 3]],
            [[0, 11, 4], [3, 12, 4], [1, 13, 4]],
            [[4, 14, 5], [1, 15, 5], [5, 16, 5]],
            [[4, 0, 0], [6, 17, 0], [2, 1, 0]],
            [[2, 3, 1], [6, 6, 1], [7, 4, 1]],
            [[6, 6, 2], [4, 18, 2], [5, 7, 2]],
            [[1, 8, 3], [3, 19, 3], [7, 9, 3]],
            [[0, 11, 4], [2, 20, 4], [3, 12, 4]],
            [[4, 14, 5], [0, 21, 5], [1, 15, 5]],
        ]

        i = 0
        for index in _faces:
            ind = []
            for f in index:
                l_vertex = _vertices[f[0]]
                l_normal = _normals[f[2]]
                l_tex = _texcoords[f[1]]
                self._vertices.append(l_vertex)
                self._normals.append(l_normal)
                self._texcoords.append(l_tex)
                ind.append(i)
                i += 1
            self.materials[DEFAULT]._indices.append(ind)
        self._indices = self.materials[DEFAULT]._indices

        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.mesh.Mesh.absolute_vertices" href="base.html#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_child" href="base.html#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_material" href="base.html#payton.scene.geometry.base.Object.add_material">add_material</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_triangle" href="mesh.html#payton.scene.geometry.mesh.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.bounding_radius" href="base.html#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.build" href="base.html#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.clear_triangles" href="mesh.html#payton.scene.geometry.mesh.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.destroy" href="base.html#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direct_to" href="base.html#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direction" href="base.html#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_normals" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_texcoords" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_texcoords">fix_texcoords</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.forward" href="base.html#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.position" href="base.html#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.refresh" href="base.html#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.render" href="base.html#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_x" href="base.html#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_y" href="base.html#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_z" href="base.html#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.scale" href="mesh.html#payton.scene.geometry.mesh.Mesh.scale">scale</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.select" href="base.html#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.step_back" href="base.html#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.to_absolute" href="base.html#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.toggle_wireframe" href="base.html#payton.scene.geometry.base.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.track" href="base.html#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.update_matrix" href="base.html#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.visible" href="base.html#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.Cylinder"><code class="flex name class">
<span>class <span class="ident">Cylinder</span></span>
<span>(</span><span>bottom_radius=0.5, top_radius=0.5, meridians=12, height=1.0, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Cylinder Object</p>
<p>Beware of using high values for number of meridians. You might end up with
excessive number of vertices to render.</p>
<p>Example use case:</p>
<pre><code>import os
import math
from payton.scene import Scene
from payton.scene.geometry import Cylinder


def rotate(period, total):
    global scene
    scene.objects["cylinder"].rotate_around_z(math.radians(1))


scene = Scene()
cyl = Cylinder(height=2.0)

scene.create_clock("rotate", 0.01, rotate)

texture_file = os.path.join(os.path.dirname(__file__), "barrel.jpg")

cyl.material.texture = texture_file

scene.add_object("cylinder", cyl)
scene.run()
</code></pre>
<p>Iniitalize the cylinder</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bottom_radius</code></strong></dt>
<dd>Radius at the bottom of the cylinder</dd>
<dt><strong><code>top_radius</code></strong></dt>
<dd>Radius at the top of the cylinder</dd>
<dt><strong><code>meridians</code></strong></dt>
<dd>Number of meridians/edges (as in geography)</dd>
<dt><strong><code>height</code></strong></dt>
<dd>Height of the cylinder</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Cylinder(Mesh):
    &#34;&#34;&#34;Cylinder Object

    Beware of using high values for number of meridians. You might end up with
    excessive number of vertices to render.

    Example use case:

        .. include:: ../../../examples/basics/18_cylinder.py

    &#34;&#34;&#34;

    def __init__(
        self,
        bottom_radius: float = 0.5,
        top_radius: float = 0.5,
        meridians: int = 12,
        height: float = 1.0,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Iniitalize the cylinder

        Args:
          bottom_radius: Radius at the bottom of the cylinder
          top_radius: Radius at the top of the cylinder
          meridians: Number of meridians/edges (as in geography)
          height: Height of the cylinder
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._bottom_radius: float = bottom_radius
        self._top_radius: float = top_radius
        self._meridians: int = meridians
        self._height: float = height
        self.build_cylinder()

    def build_cylinder(self) -&gt; bool:
        step_angle = math.radians(360 / self._meridians)

        u_step = 1.0 / self._meridians
        r_bot = self._bottom_radius
        r_top = self._top_radius
        h_2 = self._height / 2.0
        for i in range(self._meridians):
            x1 = r_bot * math.cos(step_angle * i)
            y1 = r_bot * math.sin(step_angle * i)
            x2 = r_top * math.cos(step_angle * i)
            y2 = r_top * math.sin(step_angle * i)

            u1 = u_step * i
            v1 = 1.0
            u2 = u1
            v2 = 0.0

            x3 = r_bot * math.cos(step_angle * (i + 1))
            y3 = r_bot * math.sin(step_angle * (i + 1))
            x4 = r_top * math.cos(step_angle * (i + 1))
            y4 = r_top * math.sin(step_angle * (i + 1))

            u3 = u_step * (i + 1)
            v3 = 1.0
            u4 = u3
            v4 = 0.0

            self.add_triangle(
                [[x1, y1, -h_2], [x3, y3, -h_2], [x2, y2, h_2]],
                texcoords=[[u1, v1], [u3, v3], [u2, v2]],
            )

            self.add_triangle(
                [[x3, y3, -h_2], [x4, y4, h_2], [x2, y2, h_2]],
                texcoords=[[u3, v3], [u4, v4], [u2, v2]],
            )

            self.add_triangle(
                [[x1, y1, -h_2], [0.0, 0.0, -h_2], [x3, y3, -h_2]],
                texcoords=[[u1, v1], [0.0, 0.0], [u3, v3]],
            )

            self.add_triangle(
                [[x4, y4, h_2], [0.0, 0.0, h_2], [x2, y2, h_2]],
                texcoords=[[u4, v4], [0.0, 0.0], [u2, v2]],
            )

        self.fix_normals()
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.Cylinder.build_cylinder"><code class="name flex">
<span>def <span class="ident">build_cylinder</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build_cylinder(self) -&gt; bool:
    step_angle = math.radians(360 / self._meridians)

    u_step = 1.0 / self._meridians
    r_bot = self._bottom_radius
    r_top = self._top_radius
    h_2 = self._height / 2.0
    for i in range(self._meridians):
        x1 = r_bot * math.cos(step_angle * i)
        y1 = r_bot * math.sin(step_angle * i)
        x2 = r_top * math.cos(step_angle * i)
        y2 = r_top * math.sin(step_angle * i)

        u1 = u_step * i
        v1 = 1.0
        u2 = u1
        v2 = 0.0

        x3 = r_bot * math.cos(step_angle * (i + 1))
        y3 = r_bot * math.sin(step_angle * (i + 1))
        x4 = r_top * math.cos(step_angle * (i + 1))
        y4 = r_top * math.sin(step_angle * (i + 1))

        u3 = u_step * (i + 1)
        v3 = 1.0
        u4 = u3
        v4 = 0.0

        self.add_triangle(
            [[x1, y1, -h_2], [x3, y3, -h_2], [x2, y2, h_2]],
            texcoords=[[u1, v1], [u3, v3], [u2, v2]],
        )

        self.add_triangle(
            [[x3, y3, -h_2], [x4, y4, h_2], [x2, y2, h_2]],
            texcoords=[[u3, v3], [u4, v4], [u2, v2]],
        )

        self.add_triangle(
            [[x1, y1, -h_2], [0.0, 0.0, -h_2], [x3, y3, -h_2]],
            texcoords=[[u1, v1], [0.0, 0.0], [u3, v3]],
        )

        self.add_triangle(
            [[x4, y4, h_2], [0.0, 0.0, h_2], [x2, y2, h_2]],
            texcoords=[[u4, v4], [0.0, 0.0], [u2, v2]],
        )

    self.fix_normals()
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.mesh.Mesh.absolute_vertices" href="base.html#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_child" href="base.html#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_material" href="base.html#payton.scene.geometry.base.Object.add_material">add_material</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_triangle" href="mesh.html#payton.scene.geometry.mesh.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.bounding_radius" href="base.html#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.build" href="base.html#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.clear_triangles" href="mesh.html#payton.scene.geometry.mesh.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.destroy" href="base.html#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direct_to" href="base.html#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direction" href="base.html#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_normals" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_texcoords" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_texcoords">fix_texcoords</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.forward" href="base.html#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.position" href="base.html#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.refresh" href="base.html#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.render" href="base.html#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_x" href="base.html#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_y" href="base.html#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_z" href="base.html#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.scale" href="mesh.html#payton.scene.geometry.mesh.Mesh.scale">scale</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.select" href="base.html#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.step_back" href="base.html#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.to_absolute" href="base.html#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.toggle_wireframe" href="base.html#payton.scene.geometry.base.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.track" href="base.html#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.update_matrix" href="base.html#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.visible" href="base.html#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
<span>(</span><span>vertices=None, color=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Line object</p>
<p>Exceptionally, due to hard reference for motion path feature, this class
is defined in base.py instead of line.py</p>
<p>Iniitalize line</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertices array for list of points.</dd>
<dt><strong><code>color</code></strong></dt>
<dd>Color of the line</dd>
</dl>
<p>Example use case:</p>
<pre><code>from payton.scene import Scene
from payton.scene.geometry import Line


scene = Scene()

line = Line(
    vertices=[
        [0, 0, 0],
        [0, 0, 1],
        [0.5, 0, 1.5],
        [1, 0, 1],
        [0, 0, 1],
        [1, 0, 0],
        [0, 0, 0],
        [1, 0, 1],
        [1, 0, 0],
    ]
)

scene.add_object("line", line)
scene.run()
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Line(Object):
    &#34;&#34;&#34;Line object

    Exceptionally, due to hard reference for motion path feature, this class
    is defined in base.py instead of line.py
    &#34;&#34;&#34;

    def __init__(
        self,
        vertices: Optional[VList] = None,
        color: Optional[List[float]] = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Iniitalize line

        Args:
          vertices: Vertices array for list of points.
          color: Color of the line

        Example use case:

            .. include:: ../../../examples/basics/17_line.py
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._vertices: VList = [] if vertices is None else vertices
        self.material.color = [1.0, 1.0, 1.0] if color is None else color

        self.static: bool = False  # Do not clear the vertices each time.
        self.material.display = WIREFRAME
        self.build_lines()

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle Wireframe overwrite to disable mode change&#34;&#34;&#34;
        pass

    def add_material(self, name: str, material: Material) -&gt; None:
        &#34;&#34;&#34;@TODO Implement this later! Not urgent&#34;&#34;&#34;
        logging.error(&#34;Can&#39;t add materials to Line object&#34;)

    def append(self, vertices: VList, material: str = DEFAULT) -&gt; None:
        &#34;&#34;&#34;Append vertex or vertices to line.

        Args:
          vertices: Vertex array of points.
        &#34;&#34;&#34;
        diff = len(vertices)  # Number of vertices added
        last_index = len(self._vertices)
        self._vertices += vertices

        self._texcoords += [[0, 0]] * diff
        self._normals += [[0, 0, 0]] * diff
        self._vertex_count = len(self._vertices)

        indices = list(map(lambda x: x + last_index, range(diff)))

        self.material._indices.extend([indices])
        self._indices = self.material._indices
        if self.material._vao &gt; NO_VERTEX_ARRAY:
            self._needs_update = True

    def build_lines(
        self,
        vertices: Optional[VList] = None,
        color: Optional[List[float]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Build lines

        Build line vertex array object.
        &#34;&#34;&#34;
        if vertices is not None:
            self._vertices = vertices
        if color is not None:
            self.material.color = color
        self._vertex_count = len(self._vertices)
        self.material._vertex_count = len(self._vertices)

        for i in range(self._vertex_count - 1):
            self.material._indices.append([i, i + 1])
            self._indices = self.material._indices

        for i in range(self._vertex_count):
            self._normals.append([0, 0, 0])
            self._texcoords.append([0, 0])

        if not self.has_missing_vao:
            # This is a dynamic object, destroying the object is not a good
            # idea so we just update the buffer here.
            self.build()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.Line.add_material"><code class="name flex">
<span>def <span class="ident">add_material</span></span>(<span>self, name, material)</span>
</code></dt>
<dd>
<section class="desc"><p>@TODO Implement this later! Not urgent</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_material(self, name: str, material: Material) -&gt; None:
    &#34;&#34;&#34;@TODO Implement this later! Not urgent&#34;&#34;&#34;
    logging.error(&#34;Can&#39;t add materials to Line object&#34;)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Line.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, vertices, material='default')</span>
</code></dt>
<dd>
<section class="desc"><p>Append vertex or vertices to line.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertex array of points.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def append(self, vertices: VList, material: str = DEFAULT) -&gt; None:
    &#34;&#34;&#34;Append vertex or vertices to line.

    Args:
      vertices: Vertex array of points.
    &#34;&#34;&#34;
    diff = len(vertices)  # Number of vertices added
    last_index = len(self._vertices)
    self._vertices += vertices

    self._texcoords += [[0, 0]] * diff
    self._normals += [[0, 0, 0]] * diff
    self._vertex_count = len(self._vertices)

    indices = list(map(lambda x: x + last_index, range(diff)))

    self.material._indices.extend([indices])
    self._indices = self.material._indices
    if self.material._vao &gt; NO_VERTEX_ARRAY:
        self._needs_update = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Line.build_lines"><code class="name flex">
<span>def <span class="ident">build_lines</span></span>(<span>self, vertices=None, color=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Build lines</p>
<p>Build line vertex array object.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build_lines(
    self,
    vertices: Optional[VList] = None,
    color: Optional[List[float]] = None,
) -&gt; None:
    &#34;&#34;&#34;Build lines

    Build line vertex array object.
    &#34;&#34;&#34;
    if vertices is not None:
        self._vertices = vertices
    if color is not None:
        self.material.color = color
    self._vertex_count = len(self._vertices)
    self.material._vertex_count = len(self._vertices)

    for i in range(self._vertex_count - 1):
        self.material._indices.append([i, i + 1])
        self._indices = self.material._indices

    for i in range(self._vertex_count):
        self._normals.append([0, 0, 0])
        self._texcoords.append([0, 0])

    if not self.has_missing_vao:
        # This is a dynamic object, destroying the object is not a good
        # idea so we just update the buffer here.
        self.build()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Line.toggle_wireframe"><code class="name flex">
<span>def <span class="ident">toggle_wireframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Toggle Wireframe overwrite to disable mode change</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def toggle_wireframe(self) -&gt; None:
    &#34;&#34;&#34;Toggle Wireframe overwrite to disable mode change&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.base.Object.absolute_vertices" href="base.html#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.add_child" href="base.html#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.bounding_radius" href="base.html#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.build" href="base.html#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.destroy" href="base.html#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direct_to" href="base.html#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direction" href="base.html#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.forward" href="base.html#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.position" href="base.html#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.refresh" href="base.html#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.render" href="base.html#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_x" href="base.html#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_y" href="base.html#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_z" href="base.html#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.select" href="base.html#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.step_back" href="base.html#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.to_absolute" href="base.html#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.track" href="base.html#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.update_matrix" href="base.html#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.visible" href="base.html#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.MD2"><code class="flex name class">
<span>class <span class="ident">MD2</span></span>
<span>(</span><span>filename='', **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>MD2 File Format Loader
I know that this is a pretty old file format. We can consider it as ancient
On the other hand, our target on creating Payton is not to make a game
engine.</p>
<p>Also note that there might be some bugs, I give no guarantee here.
As this is a generic class, I haven't defined any animations before hand.
So to make things properly looping in your code, you need to set the
animation frame ranges yourself. For instance, as you will see at the
defined example, infantry has a perfect walking loop between frames 2-13</p>
<p>Unlike original frame names, frames in this class starts from 0 and goes
incremented by one.</p>
<p>NOTE: There are some hard-coded pre-assumptions like the scale of the
objects and they are just defined to look okay on a default scene.</p>
<p>Example use case:</p>
<pre><code>"""Quake 2 Model Test"""
import os
import sdl2
from payton.scene import Scene
from payton.scene.geometry import MD2
from payton.scene.controller import Controller


scene = Scene()
object_file = os.path.join(os.path.dirname(__file__), "infantry", "tris.md2")
model = MD2(filename=object_file)


class CustomKeyboardControls(Controller):
    def keyboard(self, event, scene):
        super().keyboard(event, scene)
        if event.type == sdl2.SDL_KEYUP:
            key = event.key.keysym.sym
            if key == sdl2.SDLK_UP:
                model.animate("walk", 2, 13)
            if key == sdl2.SDLK_DOWN:
                model.animate("death", 0, 19, False)


print(
    """
Hit Keyboard UP to walk
Hit Keyboard Down to death animation
"""
)


scene.add_object("infantry", model)
scene.controller = CustomKeyboardControls()
model.animate("walk", 2, 13)
scene.run()
</code></pre>
<p>Initialize the MD2 Object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>Filename to load</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class MD2(Mesh):
    &#34;&#34;&#34;
    MD2 File Format Loader
    I know that this is a pretty old file format. We can consider it as ancient
    On the other hand, our target on creating Payton is not to make a game
    engine.

    Also note that there might be some bugs, I give no guarantee here.
    As this is a generic class, I haven&#39;t defined any animations before hand.
    So to make things properly looping in your code, you need to set the
    animation frame ranges yourself. For instance, as you will see at the
    defined example, infantry has a perfect walking loop between frames 2-13

    Unlike original frame names, frames in this class starts from 0 and goes
    incremented by one.

    NOTE: There are some hard-coded pre-assumptions like the scale of the
    objects and they are just defined to look okay on a default scene.

    Example use case:

        .. include:: ../../../examples/basics/26_quake2.py
    &#34;&#34;&#34;

    def __init__(self, filename: str = &#34;&#34;, **kwargs: Any):
        &#34;&#34;&#34;Initialize the MD2 Object

        Args:
          filename: Filename to load
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.header: MD2Header = MD2Header()
        self.triangle_layout = MD2TriangleLayout()
        self.skins: List[str] = []
        self.frames: List[MD2Frame] = []
        self.animation: str = &#34;&#34;
        self.animations: Dict[str, List] = {}

        self._active_frame: int = 0
        self._frame_rate: float = 0
        self._from_frame: int = 0
        self._to_frame: int = 0
        self._time: float = 0
        self._path: str = &#34;&#34;
        self._loop: bool = False

        if os.path.exists(filename):
            self.load_file(filename)

    def animate(
        self,
        animation_name: str,
        from_frame: int,
        to_frame: int,
        loop: bool = True,
    ):
        &#34;&#34;&#34;Set the model in motion

        Args:
          animation_name: Name of the animation to play
          from_frame: Loop starting frame
          to_frame: Loop ending frame
          loop: Loop the animation?
        &#34;&#34;&#34;
        self.animation = &#34;&#34;  # For thread safety
        if animation_name not in self.animations:
            logging.error(f&#34;Animation {animation_name} not found in object&#34;)
            return
        anim = self.animations[animation_name]
        if from_frame &lt; anim[0] or from_frame &gt; anim[1]:
            logging.error(f&#34;from_frame out of bounds&#34;)
            return
        if to_frame &lt; anim[0] or to_frame &gt; anim[1]:
            logging.error(f&#34;to_frame out of bounds&#34;)
            return
        self._loop = loop
        self._active_frame = from_frame
        self._from_frame = from_frame
        self._to_frame = to_frame
        self.animation = animation_name

    def render(
        self,
        proj: np.ndarray,
        view: np.ndarray,
        lights: List[Light],
        parent_matrix: Optional[np.ndarray] = None,
    ) -&gt; None:
        if not self._visible:
            return

        if self.has_missing_vao or self._needs_update:
            self.build()

        if self.animation == &#34;&#34;:
            for child in self.children:
                self.children[child].render(
                    proj, view, lights, self._model_matrix
                )
                return

        if self._time == 0:
            self._time = time.time()

        tdiff = time.time() - self._time
        if self._frame_rate == 0:
            self._frame_rate = 1 / (self._to_frame - self._from_frame)

        if tdiff &gt;= self._frame_rate:
            self._active_frame += 1
            if self._active_frame &gt; self._to_frame:
                if self._loop:
                    self._active_frame = self._from_frame
                else:
                    self._active_frame -= 1

            self._time = time.time()

        self.update_matrix(parent_matrix=parent_matrix)
        self.track()

        frame_name = f&#34;{self.animation}{self._active_frame}&#34;

        self.children[frame_name].render(
            proj, view, lights, self._model_matrix
        )

    def load_file(self, filename: str):
        if not os.path.exists(filename):
            raise BaseException(f&#34;File not found: {filename}&#34;)
        self._path = os.path.dirname(os.path.abspath(filename))
        with open(filename, &#34;rb&#34;) as f:
            self.load_buffer(f)

    def load_buffer(self, f: BinaryIO):
        self.read_header(f)
        self.read_skin(f)
        self.read_tex_coords(f)
        self.read_triangles(f)
        self.load_frames(f)
        self.compile()

    def read_triangles(self, f: BinaryIO):
        f.seek(self.header.offset_tris, os.SEEK_SET)
        triangles = np.array(
            read_block(f, &#34;&lt; 6H&#34;, self.header.num_tris), dtype=np.uint16
        )
        triangles.shape = (-1, 6)
        vertex_indices = triangles[:, :3]
        tc_indices = triangles[:, 3:]
        self.triangle_layout = MD2TriangleLayout(
            vertex_indices=vertex_indices, tc_indices=tc_indices
        )

    def compile(self):
        self.animations = {}
        for frame in self.frames:
            name = &#34;&#34;.join(i for i in frame.name if not i.isdigit())
            if name not in self.animations:
                self.animations[name] = [0, -1]
            self.animations[name][1] += 1
            num = self.animations[name][1]
            frame_name = f&#34;{name}{num}&#34;
            self.build_frame(frame, frame_name)

    def build_frame(self, frame_information: MD2Frame, name: str):
        mesh = Mesh()
        for i, tri in enumerate(self.triangle_layout.vertex_indices):
            v3 = frame_information.vertices[tri[0]].tolist()
            v2 = frame_information.vertices[tri[1]].tolist()
            v1 = frame_information.vertices[tri[2]].tolist()
            t3 = self._texcoords[self.triangle_layout.tc_indices[i][0]]
            t2 = self._texcoords[self.triangle_layout.tc_indices[i][1]]
            t1 = self._texcoords[self.triangle_layout.tc_indices[i][2]]
            normal = plane_normal(v1, v2, v3)
            mesh.add_triangle(
                vertices=[v1, v2, v3],
                normals=[normal, normal, normal],
                texcoords=[t1, t2, t3],
            )

        mesh.material.texture = os.path.join(
            self._path, os.path.basename(self.skins[0])
        )
        self.add_child(name, cast(Type[Object], mesh))

    def read_header(self, f: BinaryIO):
        self.header = MD2Header._make(read_block(f, &#34;&lt; 4s16l&#34;, 1)[0])

        if self.header.ident.decode(&#34;ascii&#34;) != _SIGNATURE:
            raise BaseException(&#34;MD2 Identifier is incorrect&#34;)
        if self.header.version != _VERSION:
            raise BaseException(&#34;Invalid Version&#34;)

    def read_skin(self, f: BinaryIO):
        f.seek(self.header.offset_skins, os.SEEK_SET)
        skin_struct = struct.Struct(&#34;&lt; %s&#34; % (&#34;64s&#34; * self.header.num_skins))

        self.skins = [
            fix_skin_name(skin)
            for skin in skin_struct.unpack(f.read(skin_struct.size))
        ]

    def read_tex_coords(self, f: BinaryIO):
        f.seek(self.header.offset_st, os.SEEK_SET)
        tcs = np.array(
            read_block(f, &#34;&lt; 2h&#34;, self.header.num_st), dtype=np.float
        )
        tcs.shape = (-1, 2)
        tcs /= [float(self.header.skin_width), float(self.header.skin_height)]
        self._texcoords = tcs

    def load_frames(self, f: BinaryIO):
        f.seek(self.header.offset_frames, os.SEEK_SET)
        self.frames = [
            self.read_frame(f) for x in range(self.header.num_frames)
        ]

    def read_frame(self, f: BinaryIO):
        frame_translations = np.array(read_block(f, &#34;&lt; 3f&#34;, 2), dtype=np.float)
        scale = frame_translations[0]
        translation = frame_translations[1]

        name = read_block(f, &#34;&lt; 16s&#34;, 1)[0][0]
        name = name.decode(&#34;ascii&#34;).strip(&#34;\x00&#34;).replace(&#34;\x00&#34;, &#34;&#34;)

        frame_vertex_data = np.array(
            read_block(f, &#34;&lt;4B&#34;, self.header.num_vertices), dtype=np.uint8
        )

        frame_vertex_data.shape = (-1, 4)

        vertices_short = frame_vertex_data[:, :3]
        vertices = vertices_short.astype(np.float)
        vertices.shape = (-1, 3)

        vertices *= scale
        vertices += (translation[0], translation[1], 0)
        vertices /= 20.0

        return MD2Frame(name=name, vertices=vertices)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.MD2.animate"><code class="name flex">
<span>def <span class="ident">animate</span></span>(<span>self, animation_name, from_frame, to_frame, loop=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the model in motion</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>animation_name</code></strong></dt>
<dd>Name of the animation to play</dd>
<dt><strong><code>from_frame</code></strong></dt>
<dd>Loop starting frame</dd>
<dt><strong><code>to_frame</code></strong></dt>
<dd>Loop ending frame</dd>
<dt><strong><code>loop</code></strong></dt>
<dd>Loop the animation?</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def animate(
    self,
    animation_name: str,
    from_frame: int,
    to_frame: int,
    loop: bool = True,
):
    &#34;&#34;&#34;Set the model in motion

    Args:
      animation_name: Name of the animation to play
      from_frame: Loop starting frame
      to_frame: Loop ending frame
      loop: Loop the animation?
    &#34;&#34;&#34;
    self.animation = &#34;&#34;  # For thread safety
    if animation_name not in self.animations:
        logging.error(f&#34;Animation {animation_name} not found in object&#34;)
        return
    anim = self.animations[animation_name]
    if from_frame &lt; anim[0] or from_frame &gt; anim[1]:
        logging.error(f&#34;from_frame out of bounds&#34;)
        return
    if to_frame &lt; anim[0] or to_frame &gt; anim[1]:
        logging.error(f&#34;to_frame out of bounds&#34;)
        return
    self._loop = loop
    self._active_frame = from_frame
    self._from_frame = from_frame
    self._to_frame = to_frame
    self.animation = animation_name</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MD2.build_frame"><code class="name flex">
<span>def <span class="ident">build_frame</span></span>(<span>self, frame_information, name)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build_frame(self, frame_information: MD2Frame, name: str):
    mesh = Mesh()
    for i, tri in enumerate(self.triangle_layout.vertex_indices):
        v3 = frame_information.vertices[tri[0]].tolist()
        v2 = frame_information.vertices[tri[1]].tolist()
        v1 = frame_information.vertices[tri[2]].tolist()
        t3 = self._texcoords[self.triangle_layout.tc_indices[i][0]]
        t2 = self._texcoords[self.triangle_layout.tc_indices[i][1]]
        t1 = self._texcoords[self.triangle_layout.tc_indices[i][2]]
        normal = plane_normal(v1, v2, v3)
        mesh.add_triangle(
            vertices=[v1, v2, v3],
            normals=[normal, normal, normal],
            texcoords=[t1, t2, t3],
        )

    mesh.material.texture = os.path.join(
        self._path, os.path.basename(self.skins[0])
    )
    self.add_child(name, cast(Type[Object], mesh))</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MD2.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def compile(self):
    self.animations = {}
    for frame in self.frames:
        name = &#34;&#34;.join(i for i in frame.name if not i.isdigit())
        if name not in self.animations:
            self.animations[name] = [0, -1]
        self.animations[name][1] += 1
        num = self.animations[name][1]
        frame_name = f&#34;{name}{num}&#34;
        self.build_frame(frame, frame_name)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MD2.load_buffer"><code class="name flex">
<span>def <span class="ident">load_buffer</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load_buffer(self, f: BinaryIO):
    self.read_header(f)
    self.read_skin(f)
    self.read_tex_coords(f)
    self.read_triangles(f)
    self.load_frames(f)
    self.compile()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MD2.load_file"><code class="name flex">
<span>def <span class="ident">load_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load_file(self, filename: str):
    if not os.path.exists(filename):
        raise BaseException(f&#34;File not found: {filename}&#34;)
    self._path = os.path.dirname(os.path.abspath(filename))
    with open(filename, &#34;rb&#34;) as f:
        self.load_buffer(f)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MD2.load_frames"><code class="name flex">
<span>def <span class="ident">load_frames</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def load_frames(self, f: BinaryIO):
    f.seek(self.header.offset_frames, os.SEEK_SET)
    self.frames = [
        self.read_frame(f) for x in range(self.header.num_frames)
    ]</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MD2.read_frame"><code class="name flex">
<span>def <span class="ident">read_frame</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_frame(self, f: BinaryIO):
    frame_translations = np.array(read_block(f, &#34;&lt; 3f&#34;, 2), dtype=np.float)
    scale = frame_translations[0]
    translation = frame_translations[1]

    name = read_block(f, &#34;&lt; 16s&#34;, 1)[0][0]
    name = name.decode(&#34;ascii&#34;).strip(&#34;\x00&#34;).replace(&#34;\x00&#34;, &#34;&#34;)

    frame_vertex_data = np.array(
        read_block(f, &#34;&lt;4B&#34;, self.header.num_vertices), dtype=np.uint8
    )

    frame_vertex_data.shape = (-1, 4)

    vertices_short = frame_vertex_data[:, :3]
    vertices = vertices_short.astype(np.float)
    vertices.shape = (-1, 3)

    vertices *= scale
    vertices += (translation[0], translation[1], 0)
    vertices /= 20.0

    return MD2Frame(name=name, vertices=vertices)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MD2.read_header"><code class="name flex">
<span>def <span class="ident">read_header</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_header(self, f: BinaryIO):
    self.header = MD2Header._make(read_block(f, &#34;&lt; 4s16l&#34;, 1)[0])

    if self.header.ident.decode(&#34;ascii&#34;) != _SIGNATURE:
        raise BaseException(&#34;MD2 Identifier is incorrect&#34;)
    if self.header.version != _VERSION:
        raise BaseException(&#34;Invalid Version&#34;)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MD2.read_skin"><code class="name flex">
<span>def <span class="ident">read_skin</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_skin(self, f: BinaryIO):
    f.seek(self.header.offset_skins, os.SEEK_SET)
    skin_struct = struct.Struct(&#34;&lt; %s&#34; % (&#34;64s&#34; * self.header.num_skins))

    self.skins = [
        fix_skin_name(skin)
        for skin in skin_struct.unpack(f.read(skin_struct.size))
    ]</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MD2.read_tex_coords"><code class="name flex">
<span>def <span class="ident">read_tex_coords</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_tex_coords(self, f: BinaryIO):
    f.seek(self.header.offset_st, os.SEEK_SET)
    tcs = np.array(
        read_block(f, &#34;&lt; 2h&#34;, self.header.num_st), dtype=np.float
    )
    tcs.shape = (-1, 2)
    tcs /= [float(self.header.skin_width), float(self.header.skin_height)]
    self._texcoords = tcs</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MD2.read_triangles"><code class="name flex">
<span>def <span class="ident">read_triangles</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def read_triangles(self, f: BinaryIO):
    f.seek(self.header.offset_tris, os.SEEK_SET)
    triangles = np.array(
        read_block(f, &#34;&lt; 6H&#34;, self.header.num_tris), dtype=np.uint16
    )
    triangles.shape = (-1, 6)
    vertex_indices = triangles[:, :3]
    tc_indices = triangles[:, 3:]
    self.triangle_layout = MD2TriangleLayout(
        vertex_indices=vertex_indices, tc_indices=tc_indices
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.mesh.Mesh.absolute_vertices" href="base.html#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_child" href="base.html#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_material" href="base.html#payton.scene.geometry.base.Object.add_material">add_material</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_triangle" href="mesh.html#payton.scene.geometry.mesh.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.bounding_radius" href="base.html#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.build" href="base.html#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.clear_triangles" href="mesh.html#payton.scene.geometry.mesh.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.destroy" href="base.html#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direct_to" href="base.html#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direction" href="base.html#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_normals" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_texcoords" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_texcoords">fix_texcoords</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.forward" href="base.html#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.position" href="base.html#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.refresh" href="base.html#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.render" href="base.html#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_x" href="base.html#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_y" href="base.html#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_z" href="base.html#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.scale" href="mesh.html#payton.scene.geometry.mesh.Mesh.scale">scale</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.select" href="base.html#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.step_back" href="base.html#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.to_absolute" href="base.html#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.toggle_wireframe" href="base.html#payton.scene.geometry.base.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.track" href="base.html#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.update_matrix" href="base.html#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.visible" href="base.html#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.MatrixPlane"><code class="flex name class">
<span>class <span class="ident">MatrixPlane</span></span>
<span>(</span><span>width=1.0, height=1.0, x=2, y=2, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Grid plane is a special plane which is generated by a NxM matrix and you
can modify the z values by <code>.grid</code> list</p>
<p>This is quite handy if you want to create a planar animation/simulation</p>
<p>Example use case:</p>
<pre><code>import random
from copy import deepcopy
from itertools import product
from payton.scene import Scene
from payton.scene.geometry import MatrixPlane
from payton.scene.material import POINTS, LIGHT_STEEL_BLUE

water_size = 60
damp = 20


def calc_water(period, total):
    global plane
    global water
    global damp
    grid = plane.grid

    for j, i in product(range(1, water_size - 1), range(1, water_size - 1)):
        n = (
            water[i - 1][j]
            + water[i + 1][j]
            + water[i][j - 1]
            + water[i][j + 1]
        ) / 2.0
        n -= grid[i][j]
        n = n - (n / damp)
        grid[i][j] = n

    j = 0
    for i in range(1, water_size - 1):
        n = (water[i - 1][j] + water[i + 1][j] + water[i][j + 1]) / 2.0
        n -= grid[i][j]
        n -= n / damp
        grid[i][j] = n

    i = 0
    for j in range(1, water_size - 1):
        n = (water[i + 1][j] + water[i][j - 1] + water[i][j + 1]) / 2.0
        n -= grid[i][j]
        n -= n / damp
        grid[i][j] = n

    i = water_size - 1
    for j in range(1, water_size - 1):
        n = (water[i - 1][j] + water[i][j - 1] + water[i][j + 1]) / 2.0
        n -= grid[i][j]
        n -= n / damp
        grid[i][j] = n

    j = water_size - 1
    for i in range(1, water_size - 1):
        n = (water[i - 1][j] + water[i + 1][j] + water[i][j - 1]) / 2.0
        n -= grid[i][j]
        n -= n / damp
        grid[i][j] = n

    plane.update_grid()
    water, plane.grid = plane.grid, water


def drop(period, total):
    global water
    water[random.randint(0, water_size - 1)][
        random.randint(0, water_size - 1)
    ] = random.randint(-5, 15)


def ripple_pos(hit):
    global water
    i = int((hit[0] + 10) * 3)
    j = int((hit[1] + 10) * 3)
    if not (0 &lt;= i &lt; water_size):
        return
    if not (0 &lt;= j &lt; water_size):
        return
    water[i][j] = 5


scene = Scene()
scene.background.top_color = [0, 0, 0, 1]
scene.background.bottom_color = [0, 0, 0, 1]

scene.add_click_plane([0, 0, 0], [0, 0, 1], ripple_pos)
scene.grid.visible = False
scene.lights[0].position = [100, 100, 2]

plane = MatrixPlane(width=20, height=20, x=water_size, y=water_size)
water = deepcopy(plane.grid)

plane.material.display = POINTS
plane.material.color = LIGHT_STEEL_BLUE

scene.create_clock("ripple", 0.025, calc_water)
scene.create_clock("drop", 5, drop)
scene.add_object("plane", plane)
scene.active_observer.distance_to_target(20)

scene.run()
</code></pre>
<p>Initialize MatrixPlane</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong></dt>
<dd>Number of control points along X axis</dd>
<dt><strong><code>y</code></strong></dt>
<dd>Number of control points along Y axis</dd>
<dt><strong><code>width</code></strong></dt>
<dd>Total width</dd>
<dt><strong><code>height</code></strong></dt>
<dd>Total height</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class MatrixPlane(Mesh):
    &#34;&#34;&#34;Grid plane is a special plane which is generated by a NxM matrix and you
    can modify the z values by `.grid` list

    This is quite handy if you want to create a planar animation/simulation

    Example use case:

        .. include:: ../../../examples/mid-level/ripple.py
    &#34;&#34;&#34;

    def __init__(
        self,
        width: float = 1.0,
        height: float = 1.0,
        x: int = 2,
        y: int = 2,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize MatrixPlane

        Args:
          x: Number of control points along X axis
          y: Number of control points along Y axis
          width: Total width
          height: Total height
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.width = width
        self.height = height
        self.x = x
        self.y = y
        if self.x &lt; 2:
            self.x = 2
        if self.y &lt; 2:
            self.y = 2
        self.grid: List[List[float]] = []
        self.populate_grid()

    def update_grid(self) -&gt; None:
        for i, j in product(range(self.x), range(self.y)):
            self._vertices[(self.x * i) + j][2] = self.grid[i][j]
        if self.material.display == SOLID:
            self.fix_normals()
        self.refresh()

    def populate_grid(self) -&gt; None:
        &#34;&#34;&#34;Turn grid data into plane&#34;&#34;&#34;
        self.clear_triangles()

        self.grid = [[0.0] * self.y for _i in range(self.x)]

        step_x = self.width / (self.x - 1)
        step_y = self.height / (self.y - 1)
        step_u = 1.0 / (self.x - 1)
        step_v = 1.0 / (self.y - 1)

        c_x = self.width / 2.0
        c_y = self.height / 2.0
        for i, j in product(range(self.x), range(self.y)):
            self._vertices.append(
                [(i * step_x) - c_x, (j * step_y) - c_y, self.grid[i][j]]
            )
            self._texcoords.append([i * step_u, j * step_v])
            if i &lt; self.x - 1 and j &lt; self.y - 1:
                left = (self.x * i) + j
                right = (self.x * i) + (j + 1)
                top_left = (self.x * (i + 1)) + j
                top_right = (self.x * (i + 1)) + (j + 1)
                self._indices.append([left, right, top_right])
                self._indices.append([top_right, top_left, left])

        self.material._indices = self._indices
        self.fix_normals()
        self.refresh()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.MatrixPlane.populate_grid"><code class="name flex">
<span>def <span class="ident">populate_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Turn grid data into plane</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def populate_grid(self) -&gt; None:
    &#34;&#34;&#34;Turn grid data into plane&#34;&#34;&#34;
    self.clear_triangles()

    self.grid = [[0.0] * self.y for _i in range(self.x)]

    step_x = self.width / (self.x - 1)
    step_y = self.height / (self.y - 1)
    step_u = 1.0 / (self.x - 1)
    step_v = 1.0 / (self.y - 1)

    c_x = self.width / 2.0
    c_y = self.height / 2.0
    for i, j in product(range(self.x), range(self.y)):
        self._vertices.append(
            [(i * step_x) - c_x, (j * step_y) - c_y, self.grid[i][j]]
        )
        self._texcoords.append([i * step_u, j * step_v])
        if i &lt; self.x - 1 and j &lt; self.y - 1:
            left = (self.x * i) + j
            right = (self.x * i) + (j + 1)
            top_left = (self.x * (i + 1)) + j
            top_right = (self.x * (i + 1)) + (j + 1)
            self._indices.append([left, right, top_right])
            self._indices.append([top_right, top_left, left])

    self.material._indices = self._indices
    self.fix_normals()
    self.refresh()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.MatrixPlane.update_grid"><code class="name flex">
<span>def <span class="ident">update_grid</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_grid(self) -&gt; None:
    for i, j in product(range(self.x), range(self.y)):
        self._vertices[(self.x * i) + j][2] = self.grid[i][j]
    if self.material.display == SOLID:
        self.fix_normals()
    self.refresh()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.mesh.Mesh.absolute_vertices" href="base.html#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_child" href="base.html#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_material" href="base.html#payton.scene.geometry.base.Object.add_material">add_material</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_triangle" href="mesh.html#payton.scene.geometry.mesh.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.bounding_radius" href="base.html#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.build" href="base.html#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.clear_triangles" href="mesh.html#payton.scene.geometry.mesh.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.destroy" href="base.html#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direct_to" href="base.html#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direction" href="base.html#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_normals" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_texcoords" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_texcoords">fix_texcoords</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.forward" href="base.html#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.position" href="base.html#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.refresh" href="base.html#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.render" href="base.html#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_x" href="base.html#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_y" href="base.html#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_z" href="base.html#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.scale" href="mesh.html#payton.scene.geometry.mesh.Mesh.scale">scale</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.select" href="base.html#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.step_back" href="base.html#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.to_absolute" href="base.html#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.toggle_wireframe" href="base.html#payton.scene.geometry.base.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.track" href="base.html#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.update_matrix" href="base.html#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.visible" href="base.html#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.Mesh"><code class="flex name class">
<span>class <span class="ident">Mesh</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Mesh Object</p>
<p>Mesh is almost like the Object except with some extra methods to make
things easier. If you want to have custom geometries/shapes, it is
better to extend <a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh"><code>Mesh</code></a> instead of
<a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object"><code>Object</code></a>. Because Mesh will give you better
and easier constructing capabilities such as adding triangles on the fly
or sub-division or cutting and so forth. It is a way of designing objects
by code.</p>
<p>Example use case:</p>
<pre><code>import os
from payton.scene import Scene
from payton.scene.geometry import Mesh


scene = Scene()
mesh = Mesh()
mesh.add_triangle(
    [[0, 0, 0], [2, 0, 0], [2, 2, 0]], texcoords=[[0, 0], [1, 0], [1, 1]]
)
mesh.add_triangle(
    [[0, 0, 0], [2, 2, 0], [0, 2, 0]], texcoords=[[0, 0], [1, 1], [0, 1]]
)
texture_file = os.path.join(os.path.dirname(__file__), "cube.png")
mesh.material.texture = texture_file
scene.add_object("mesh", mesh)
scene.run()
</code></pre>
<p>Initialize the basic object properties.</p>
<h2 id="properties">Properties</h2>
<dl>
<dt><strong><code>children</code></strong></dt>
<dd>Children hash for object. Each child object follows parent
object. They take their parent object as origin and their
coordinate system is relative to their parent. This
behaviour resembles stars, planets and their moons.</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material definitions of the object.</dd>
<dt><strong><code>matrix</code></strong></dt>
<dd>Matrix definition of the object. This is a 4x4 Uniform Matrix
but data is set as an array for easier transformations. First
4 decimals are "Left" vector, second 4 are "Direction", third
4 are "Up" and last four decimals are "Position" vectors.</dd>
</dl>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track_motion</code></strong></dt>
<dd>Track object motion (default: false). Object tracking
is time independent. It just saves the object matrix
for every change. Uses matrix position for drawing the
motion path.</dd>
<dt><strong><code>static</code></strong></dt>
<dd>(Default <code>True</code>) Indicates if object geometry is expected
to be changed in the future. If object is not static, then
its' vertex buffer object references and vertex informations
will not be deleted to be used for future reference.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the object (optional, default '') Note that, when
object gets added to a Scene with a name, Scene will assign
that name to the object, overwriting any existing name of the
object.</dd>
<dt><strong><code>visible</code></strong></dt>
<dd>Is this object visible at the scene, default: <code>True</code>. To
hide an object, you can call <code>object.hide()</code> and to show
it again use: <code>object.show()</code></dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Mesh(Object):
    &#34;&#34;&#34;Mesh Object

    Mesh is almost like the Object except with some extra methods to make
    things easier. If you want to have custom geometries/shapes, it is
    better to extend `payton.scene.geometry.mesh.Mesh` instead of
    `payton.scene.geometry.base.Object`. Because Mesh will give you better
    and easier constructing capabilities such as adding triangles on the fly
    or sub-division or cutting and so forth. It is a way of designing objects
    by code.


    Example use case:

        .. include:: ../../../examples/basics/09_mesh.py
    &#34;&#34;&#34;

    def __init__(self, **kwargs: Any) -&gt; None:
        super().__init__(**kwargs)
        self.static = False

    def clear_triangles(self) -&gt; None:
        &#34;&#34;&#34;Clear all triangles inside the Mesh&#34;&#34;&#34;
        self._vertices = []
        self._indices = []
        self._normals = []
        self._texcoords = []
        self._vertex_colors = []
        for material in self.materials.values():
            material._indices = []

        self.refresh()

    def fix_normals(self) -&gt; None:
        &#34;&#34;&#34;Try to re-calculate Mesh normals, if your object has already perfect
        normals, do not call this method&#34;&#34;&#34;
        self._normals = [[0, 0, 1.0]] * len(self._vertices)

        for face in self._indices:
            v1, v2, v3 = (
                self._vertices[face[0]],
                self._vertices[face[1]],
                self._vertices[face[2]],
            )
            normal = plane_normal(v1, v2, v3)
            self._normals[face[0]] = normal
            self._normals[face[1]] = normal
            self._normals[face[2]] = normal

    def fix_texcoords(self, u: int = 1, v: int = 1) -&gt; None:
        &#34;&#34;&#34;Try to recalculate mesh texture coordinates by cube projection
        &#34;&#34;&#34;
        self._texcoords = []
        self._calc_bounds()
        bbox = self._bounding_box
        vmin, vmax = bbox[0], bbox[1]
        width = vmax[0] - vmin[0]
        depth = vmax[1] - vmin[1]
        height = vmax[2] - vmin[2]
        normals = [
            [0.0, -1.0, 0.0],  # front
            [1.0, 0.0, 0.0],  # right
            [-1.0, 0.0, 0.0],  # left
            [0.0, 1.0, 0.0],  # back
            [0.0, 0.0, 1.0],  # top
            [0.0, 0.0, -1.0],  # bottom
        ]
        for face in self._indices:
            v1, v2, v3 = (
                self._vertices[face[0]],
                self._vertices[face[1]],
                self._vertices[face[2]],
            )
            # find face normal
            normal = plane_normal(v1, v2, v3)
            # determine which face of the cube
            angles = [vector_angle(normal, n) for n in normals]
            face_dir = angles.index(min(angles))
            if face_dir == 0:
                t1 = (v1[0] - vmin[0]) / width
                s1 = (v1[2] - vmin[2]) / height
                t2 = (v2[0] - vmin[0]) / width
                s2 = (v2[2] - vmin[2]) / height
                t3 = (v3[0] - vmin[0]) / width
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 1:
                t1 = (v1[1] - vmin[1]) / depth
                s1 = (v1[2] - vmin[2]) / height
                t2 = (v2[1] - vmin[1]) / depth
                s2 = (v2[2] - vmin[2]) / height
                t3 = (v3[1] - vmin[1]) / depth
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 2:
                t1 = (vmax[1] - v1[1]) / depth
                s1 = (v1[2] - vmin[2]) / height
                t2 = (vmax[1] - v2[1]) / depth
                s2 = (v2[2] - vmin[2]) / height
                t3 = (vmax[1] - v3[1]) / depth
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 3:
                t1 = (vmax[0] - v1[0]) / width
                s1 = (v1[2] - vmin[2]) / height
                t2 = (vmax[0] - v2[0]) / width
                s2 = (v2[2] - vmin[2]) / height
                t3 = (vmax[0] - v3[0]) / width
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 4:
                t1 = (v1[0] - vmin[0]) / width
                s1 = (v1[1] - vmin[1]) / depth
                t2 = (v2[0] - vmin[0]) / width
                s2 = (v2[1] - vmin[1]) / depth
                t3 = (v3[0] - vmin[0]) / width
                s3 = (v3[1] - vmin[1]) / depth
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 5:
                t1 = (v1[0] - vmin[0]) / width
                s1 = (v1[1] - vmin[1]) / depth
                t2 = (v2[0] - vmin[0]) / width
                s2 = (v2[1] - vmin[1]) / depth
                t3 = (v3[0] - vmin[0]) / width
                s3 = (v3[1] - vmin[1]) / depth
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        self._texcoords = [[t[0] * u, t[1] * v] for t in self._texcoords]

    def scale(self, x: float, y: float, z: float) -&gt; None:
        &#34;&#34;&#34;Scale Mesh by given factors

        This does not create a scale matrix and multiply existing matrix
        with it. Instead, it will scale the vertices by given factors.
        &#34;&#34;&#34;
        self._vertices = list(
            map(lambda v: [v[0] * x, v[1] * y, v[2] * z], self._vertices)
        )
        self.fix_normals()
        self.refresh()

    def add_triangle(
        self,
        vertices: VList,
        material: str = DEFAULT,
        normals: Optional[VList] = None,
        texcoords: Optional[VList] = None,
        colors: Optional[VList] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add triangle to Mesh

        Args:
          vertices: Vertices of the triangle. This is required. Ex:
                    `[[0, 0, 0], [2, 0, 0], [1, 1, 0]]`
          normals: Normals of the triangle. _(When left as None, Payton will
                   calculate the surface normal based on vertices and assign
                   it per given vertex.)_
          material: Name of the material to use.
          texcoords: Texture UV coordinates.
          colors: Per vertex colors (optional)
        &#34;&#34;&#34;
        if len(vertices) != 3:
            logging.error(&#34;A triangle must have 3 vertices&#34;)
            return

        if normals is not None and len(normals) != 3:
            logging.error(&#34;There must be one normal per vertex&#34;)
            return

        if texcoords is not None and len(texcoords) != 3:
            logging.error(&#34;There must be one texcoord per vertex&#34;)
            return

        if normals is None:
            v1, v2, v3 = vertices[0], vertices[1], vertices[2]
            normal = plane_normal(v1, v2, v3)
            normals = [normal, normal, normal]
        if texcoords is None:
            texcoords = [[0, 0], [1, 0], [1, 1]]
        if colors:
            for color in colors:
                self._vertex_colors.append(color)

        self._vertices += vertices

        i = len(self._indices) * 3
        self._indices.append([i, i + 1, i + 2])
        self.materials[material]._indices.append([i, i + 1, i + 2])
        for normal in normals:
            self._normals.append(normal)
        for t in texcoords:
            self._texcoords.append(t)
        self.refresh()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.cylinder.Cylinder" href="cylinder.html#payton.scene.geometry.cylinder.Cylinder">Cylinder</a></li>
<li><a title="payton.scene.geometry.cube.Cube" href="cube.html#payton.scene.geometry.cube.Cube">Cube</a></li>
<li><a title="payton.scene.geometry.plane.Plane" href="plane.html#payton.scene.geometry.plane.Plane">Plane</a></li>
<li><a title="payton.scene.geometry.plane.MatrixPlane" href="plane.html#payton.scene.geometry.plane.MatrixPlane">MatrixPlane</a></li>
<li><a title="payton.scene.geometry.sphere.Sphere" href="sphere.html#payton.scene.geometry.sphere.Sphere">Sphere</a></li>
<li><a title="payton.scene.geometry.md2.MD2" href="md2.html#payton.scene.geometry.md2.MD2">MD2</a></li>
<li><a title="payton.scene.gui.Shape2D" href="../gui.html#payton.scene.gui.Shape2D">Shape2D</a></li>
<li><a title="payton.scene.wavefront.Wavefront" href="../wavefront.html#payton.scene.wavefront.Wavefront">Wavefront</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.Mesh.add_triangle"><code class="name flex">
<span>def <span class="ident">add_triangle</span></span>(<span>self, vertices, material='default', normals=None, texcoords=None, colors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add triangle to Mesh</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertices of the triangle. This is required. Ex:
<code>[[0, 0, 0], [2, 0, 0], [1, 1, 0]]</code></dd>
<dt><strong><code>normals</code></strong></dt>
<dd>Normals of the triangle. <em>(When left as None, Payton will
calculate the surface normal based on vertices and assign
it per given vertex.)</em></dd>
<dt><strong><code>material</code></strong></dt>
<dd>Name of the material to use.</dd>
<dt><strong><code>texcoords</code></strong></dt>
<dd>Texture UV coordinates.</dd>
<dt><strong><code>colors</code></strong></dt>
<dd>Per vertex colors (optional)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_triangle(
    self,
    vertices: VList,
    material: str = DEFAULT,
    normals: Optional[VList] = None,
    texcoords: Optional[VList] = None,
    colors: Optional[VList] = None,
) -&gt; None:
    &#34;&#34;&#34;Add triangle to Mesh

    Args:
      vertices: Vertices of the triangle. This is required. Ex:
                `[[0, 0, 0], [2, 0, 0], [1, 1, 0]]`
      normals: Normals of the triangle. _(When left as None, Payton will
               calculate the surface normal based on vertices and assign
               it per given vertex.)_
      material: Name of the material to use.
      texcoords: Texture UV coordinates.
      colors: Per vertex colors (optional)
    &#34;&#34;&#34;
    if len(vertices) != 3:
        logging.error(&#34;A triangle must have 3 vertices&#34;)
        return

    if normals is not None and len(normals) != 3:
        logging.error(&#34;There must be one normal per vertex&#34;)
        return

    if texcoords is not None and len(texcoords) != 3:
        logging.error(&#34;There must be one texcoord per vertex&#34;)
        return

    if normals is None:
        v1, v2, v3 = vertices[0], vertices[1], vertices[2]
        normal = plane_normal(v1, v2, v3)
        normals = [normal, normal, normal]
    if texcoords is None:
        texcoords = [[0, 0], [1, 0], [1, 1]]
    if colors:
        for color in colors:
            self._vertex_colors.append(color)

    self._vertices += vertices

    i = len(self._indices) * 3
    self._indices.append([i, i + 1, i + 2])
    self.materials[material]._indices.append([i, i + 1, i + 2])
    for normal in normals:
        self._normals.append(normal)
    for t in texcoords:
        self._texcoords.append(t)
    self.refresh()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Mesh.clear_triangles"><code class="name flex">
<span>def <span class="ident">clear_triangles</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Clear all triangles inside the Mesh</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def clear_triangles(self) -&gt; None:
    &#34;&#34;&#34;Clear all triangles inside the Mesh&#34;&#34;&#34;
    self._vertices = []
    self._indices = []
    self._normals = []
    self._texcoords = []
    self._vertex_colors = []
    for material in self.materials.values():
        material._indices = []

    self.refresh()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Mesh.fix_normals"><code class="name flex">
<span>def <span class="ident">fix_normals</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Try to re-calculate Mesh normals, if your object has already perfect
normals, do not call this method</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fix_normals(self) -&gt; None:
    &#34;&#34;&#34;Try to re-calculate Mesh normals, if your object has already perfect
    normals, do not call this method&#34;&#34;&#34;
    self._normals = [[0, 0, 1.0]] * len(self._vertices)

    for face in self._indices:
        v1, v2, v3 = (
            self._vertices[face[0]],
            self._vertices[face[1]],
            self._vertices[face[2]],
        )
        normal = plane_normal(v1, v2, v3)
        self._normals[face[0]] = normal
        self._normals[face[1]] = normal
        self._normals[face[2]] = normal</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Mesh.fix_texcoords"><code class="name flex">
<span>def <span class="ident">fix_texcoords</span></span>(<span>self, u=1, v=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Try to recalculate mesh texture coordinates by cube projection</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fix_texcoords(self, u: int = 1, v: int = 1) -&gt; None:
    &#34;&#34;&#34;Try to recalculate mesh texture coordinates by cube projection
    &#34;&#34;&#34;
    self._texcoords = []
    self._calc_bounds()
    bbox = self._bounding_box
    vmin, vmax = bbox[0], bbox[1]
    width = vmax[0] - vmin[0]
    depth = vmax[1] - vmin[1]
    height = vmax[2] - vmin[2]
    normals = [
        [0.0, -1.0, 0.0],  # front
        [1.0, 0.0, 0.0],  # right
        [-1.0, 0.0, 0.0],  # left
        [0.0, 1.0, 0.0],  # back
        [0.0, 0.0, 1.0],  # top
        [0.0, 0.0, -1.0],  # bottom
    ]
    for face in self._indices:
        v1, v2, v3 = (
            self._vertices[face[0]],
            self._vertices[face[1]],
            self._vertices[face[2]],
        )
        # find face normal
        normal = plane_normal(v1, v2, v3)
        # determine which face of the cube
        angles = [vector_angle(normal, n) for n in normals]
        face_dir = angles.index(min(angles))
        if face_dir == 0:
            t1 = (v1[0] - vmin[0]) / width
            s1 = (v1[2] - vmin[2]) / height
            t2 = (v2[0] - vmin[0]) / width
            s2 = (v2[2] - vmin[2]) / height
            t3 = (v3[0] - vmin[0]) / width
            s3 = (v3[2] - vmin[2]) / height
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        if face_dir == 1:
            t1 = (v1[1] - vmin[1]) / depth
            s1 = (v1[2] - vmin[2]) / height
            t2 = (v2[1] - vmin[1]) / depth
            s2 = (v2[2] - vmin[2]) / height
            t3 = (v3[1] - vmin[1]) / depth
            s3 = (v3[2] - vmin[2]) / height
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        if face_dir == 2:
            t1 = (vmax[1] - v1[1]) / depth
            s1 = (v1[2] - vmin[2]) / height
            t2 = (vmax[1] - v2[1]) / depth
            s2 = (v2[2] - vmin[2]) / height
            t3 = (vmax[1] - v3[1]) / depth
            s3 = (v3[2] - vmin[2]) / height
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        if face_dir == 3:
            t1 = (vmax[0] - v1[0]) / width
            s1 = (v1[2] - vmin[2]) / height
            t2 = (vmax[0] - v2[0]) / width
            s2 = (v2[2] - vmin[2]) / height
            t3 = (vmax[0] - v3[0]) / width
            s3 = (v3[2] - vmin[2]) / height
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        if face_dir == 4:
            t1 = (v1[0] - vmin[0]) / width
            s1 = (v1[1] - vmin[1]) / depth
            t2 = (v2[0] - vmin[0]) / width
            s2 = (v2[1] - vmin[1]) / depth
            t3 = (v3[0] - vmin[0]) / width
            s3 = (v3[1] - vmin[1]) / depth
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        if face_dir == 5:
            t1 = (v1[0] - vmin[0]) / width
            s1 = (v1[1] - vmin[1]) / depth
            t2 = (v2[0] - vmin[0]) / width
            s2 = (v2[1] - vmin[1]) / depth
            t3 = (v3[0] - vmin[0]) / width
            s3 = (v3[1] - vmin[1]) / depth
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
    self._texcoords = [[t[0] * u, t[1] * v] for t in self._texcoords]</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Mesh.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<section class="desc"><p>Scale Mesh by given factors</p>
<p>This does not create a scale matrix and multiply existing matrix
with it. Instead, it will scale the vertices by given factors.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def scale(self, x: float, y: float, z: float) -&gt; None:
    &#34;&#34;&#34;Scale Mesh by given factors

    This does not create a scale matrix and multiply existing matrix
    with it. Instead, it will scale the vertices by given factors.
    &#34;&#34;&#34;
    self._vertices = list(
        map(lambda v: [v[0] * x, v[1] * y, v[2] * z], self._vertices)
    )
    self.fix_normals()
    self.refresh()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.base.Object.absolute_vertices" href="base.html#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.add_child" href="base.html#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.add_material" href="base.html#payton.scene.geometry.base.Object.add_material">add_material</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.bounding_radius" href="base.html#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.build" href="base.html#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.destroy" href="base.html#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direct_to" href="base.html#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direction" href="base.html#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.forward" href="base.html#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.position" href="base.html#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.refresh" href="base.html#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.render" href="base.html#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_x" href="base.html#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_y" href="base.html#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_z" href="base.html#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.select" href="base.html#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.step_back" href="base.html#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.to_absolute" href="base.html#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.toggle_wireframe" href="base.html#payton.scene.geometry.base.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.track" href="base.html#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.update_matrix" href="base.html#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.visible" href="base.html#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.Object"><code class="flex name class">
<span>class <span class="ident">Object</span></span>
<span>(</span><span>static=True, name='', visible=True, track_motion=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Main Payton Object.</p>
<p>This is an abstract class to define common properties and methods between
Mesh / Cube / Sphere/ Shape2D / PointCloud, etc.</p>
<p>Objects are not actually built as 3D vertex arrays until they are rendered.
Render function calls <code>build</code> function if needed. Build function creates
the OpenGL Vertex Array Object. VAO is static data so, once the object
is built, changing vertices or indices will not take effect at the scene.</p>
<p>You need to call <a title="payton.scene.geometry.base.Object.build" href="base.html#payton.scene.geometry.base.Object.build"><code>Object.build()</code></a> function to
refresh Vertex Array Object.</p>
<p>OpenGL can not magically extend a memory buffer, so for every new vertices
added to the object, OpenGL needs to re-create the buffer area. This is
not an efficitient technique if number of vertices increase in time.
As a result Payton allocates buffer for 500 vertices in the beginning and
uses part of it. If the object exceeds 500 vertices, a new buffer is
created with 500 vertices more, copies existing vertices to the new
buffer and the old buffer is deleted.</p>
<p>Initialize the basic object properties.</p>
<h2 id="properties">Properties</h2>
<dl>
<dt><strong><code>children</code></strong></dt>
<dd>Children hash for object. Each child object follows parent
object. They take their parent object as origin and their
coordinate system is relative to their parent. This
behaviour resembles stars, planets and their moons.</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material definitions of the object.</dd>
<dt><strong><code>matrix</code></strong></dt>
<dd>Matrix definition of the object. This is a 4x4 Uniform Matrix
but data is set as an array for easier transformations. First
4 decimals are "Left" vector, second 4 are "Direction", third
4 are "Up" and last four decimals are "Position" vectors.</dd>
</dl>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track_motion</code></strong></dt>
<dd>Track object motion (default: false). Object tracking
is time independent. It just saves the object matrix
for every change. Uses matrix position for drawing the
motion path.</dd>
<dt><strong><code>static</code></strong></dt>
<dd>(Default <code>True</code>) Indicates if object geometry is expected
to be changed in the future. If object is not static, then
its' vertex buffer object references and vertex informations
will not be deleted to be used for future reference.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the object (optional, default '') Note that, when
object gets added to a Scene with a name, Scene will assign
that name to the object, overwriting any existing name of the
object.</dd>
<dt><strong><code>visible</code></strong></dt>
<dd>Is this object visible at the scene, default: <code>True</code>. To
hide an object, you can call <code>object.hide()</code> and to show
it again use: <code>object.show()</code></dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Object(object):
    &#34;&#34;&#34;Main Payton Object.

    This is an abstract class to define common properties and methods between
    Mesh / Cube / Sphere/ Shape2D / PointCloud, etc.

    Objects are not actually built as 3D vertex arrays until they are rendered.
    Render function calls `build` function if needed. Build function creates
    the OpenGL Vertex Array Object. VAO is static data so, once the object
    is built, changing vertices or indices will not take effect at the scene.

    You need to call `payton.scene.geometry.base.Object.build` function to
    refresh Vertex Array Object.

    OpenGL can not magically extend a memory buffer, so for every new vertices
    added to the object, OpenGL needs to re-create the buffer area. This is
    not an efficitient technique if number of vertices increase in time.
    As a result Payton allocates buffer for 500 vertices in the beginning and
    uses part of it. If the object exceeds 500 vertices, a new buffer is
    created with 500 vertices more, copies existing vertices to the new
    buffer and the old buffer is deleted.

    &#34;&#34;&#34;

    def __init__(
        self,
        static=True,
        name=&#34;&#34;,
        visible=True,
        track_motion=False,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize the basic object properties.

        Properties:
          children: Children hash for object. Each child object follows parent
                    object. They take their parent object as origin and their
                    coordinate system is relative to their parent. This
                    behaviour resembles stars, planets and their moons.
          material: Material definitions of the object.
          matrix: Matrix definition of the object. This is a 4x4 Uniform Matrix
                  but data is set as an array for easier transformations. First
                  4 decimals are &#34;Left&#34; vector, second 4 are &#34;Direction&#34;, third
                  4 are &#34;Up&#34; and last four decimals are &#34;Position&#34; vectors.

        Args:
          track_motion: Track object motion (default: false). Object tracking
                        is time independent. It just saves the object matrix
                        for every change. Uses matrix position for drawing the
                        motion path.
          static: (Default `True`) Indicates if object geometry is expected
                  to be changed in the future. If object is not static, then
                  its&#39; vertex buffer object references and vertex informations
                  will not be deleted to be used for future reference.
          name: Name of the object (optional, default &#39;&#39;) Note that, when
                object gets added to a Scene with a name, Scene will assign
                that name to the object, overwriting any existing name of the
                object.
          visible: Is this object visible at the scene, default: `True`. To
                   hide an object, you can call `object.hide()` and to show
                   it again use: `object.show()`
        &#34;&#34;&#34;
        self.children: Dict[str, Object] = {}

        # store diffeerent materials
        self.materials: Dict[str, Material] = {DEFAULT: Material()}

        self._vao: int = NO_VERTEX_ARRAY
        self._vbos: List[int] = []

        self.static = static
        self.name = name
        self._visible = visible
        self.matrix: VList = [
            [1.0, 0.0, 0.0, 0.0],
            [0.0, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.0],
            [0.0, 0.0, 0.0, 1.0],
        ]
        # Object vertices. Each vertex has 3 decimals (X, Y, Z). Vertices
        # are continuous. [X, Y, Z, X, Y, Z, X, Y, Z, X, ... ]
        #                  -- 1 --  -- 2 --  -- 3 --  -- 4 --

        self._vertices: VList = []  # Object vertex list

        # @NOTE: we have separate indices for materials but this base
        #        index list holds all indice definitions for fast access
        self._indices: IList = []  # Indices
        self._normals: List[
            List[float]
        ] = []  # Vertex normals, 1 normal coordinate for 1 Vertex
        self._texcoords: List[
            List[float]
        ] = []  # Texture coordinates, 1 coordinate per Vertex
        self._vertex_colors: List[
            List[float]
        ] = []  # per-vertex colors, optional.
        self._has_vertex_colors: bool = False  # flag for using vertex colors

        # Vertices do not mean anything unless we define how to use them.
        # For instance, 3 vertices make a triangle or 2 vertices define a line
        # order of vertices are defined in materials indices
        self._vertex_count: int = 0  # Number of vertices to report to OpenGL.

        # This is an optimization technique for dynamic objects where there are
        # increasing number of vertices. We allocate some buffer before-hand
        # and if we fill all of it, we resize it.
        self._buffer_size: float = 500 * 12
        self._t_buffer_size: float = 500 * 8
        self._model_matrix: np.ndarray = []  # Model matrix.
        # Check if buffer size allocated for the object has changed.
        self._buffer_size_changed: bool = True
        self._t_buffer_size_changed: bool = True

        # Track object motion
        self.track_motion = track_motion
        # Motion path, stores every matrix change.
        self._motion_path: List[VList] = []

        if not isinstance(self, Line):
            # _motion_path_line is used to display the motion path in scene
            self._motion_path_line = Line()
        self._previous_matrix: Union[np.ndarray, None] = None

        # For raycast tests - bounding radius is the radius of the bounding
        # sphere.
        self._bounding_radius: float = 0
        self._bounding_box: VList = []
        self._selected: bool = False

        # Vertex Array Object pointer
        self._needs_update: bool = False  # Object geometry has changed.
        self._hit: bool = False

    def refresh(self) -&gt; None:
        &#34;&#34;&#34;Refresh object

        Forces object to get built again
        &#34;&#34;&#34;
        self._needs_update = True

    @property
    def material(self) -&gt; Material:
        return self.materials[DEFAULT]

    @material.setter
    def material(self, mat: Material) -&gt; None:
        self.materials[DEFAULT] = mat

    def add_material(self, name: str, material: Material) -&gt; None:
        &#34;&#34;&#34;Add a material to the object.

        Keep in mind that, adding material does not refer to the material
        but does it through deepcopy. Initially, material holds indice
        and vertex buffer objectt references. In order to prevent user
        from breaking the objects, we create the clone of the material.
        &#34;&#34;&#34;
        if name in self.materials:
            raise Exception(f&#34;Name {name} already exists&#34;)
        self.materials[name] = deepcopy(material)

    @property
    def direction(self) -&gt; List[float]:
        &#34;&#34;&#34;Get direction vector from Matrix&#34;&#34;&#34;
        return self.matrix[1][:3]

    @direction.setter
    def direction(self, v: List[float]):
        &#34;&#34;&#34;Set direction vector of Matrix

        Attention! This needs to be a unit vector!
        &#34;&#34;&#34;
        if len(v) &lt; 3:
            raise Exception(&#34;Direction needs 3 components (x,y,z)&#34;)
        self.matrix[1][0] = v[0]
        self.matrix[1][1] = v[1]
        self.matrix[1][2] = v[2]
        left = cross_product(self.matrix[1], self.matrix[2])
        left += [0]
        self.matrix[0] = left
        up = cross_product(self.matrix[0], self.matrix[1])
        up += [0]
        self.matrix[2] = up

    def direct_to(self, v: List[float]):
        &#34;&#34;&#34;Direct the objects forward towards given point vector&#34;&#34;&#34;
        diff = sub_vector(v, self.position)
        diff = normalize_vector(diff)
        self.direction = diff

    def rotate_around_z(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Rotate around Z Axis

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([0, 0, 1], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def rotate_around_x(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Pitch - Rotate around X axis

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([1, 0, 0], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def rotate_around_y(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Roll - Rotate around Y Axis (Direction)

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([0, 1, 0], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def select(self, start: np.ndarray, vector: np.ndarray) -&gt; bool:
        &#34;&#34;&#34;Select test for object using bounding Sphere.

        This method is not 100% accurate as it is based on a rough
        assumption. Sphere area will be larger than actual object.

        If you want to have a more accurate way to handle this, try
        using raycast triangle intersect

        Args:
          start: Starting point of the ray (such as eye position)
          vector: Ray direction. This is not the end point of a line!
                  This is a unit vector showing the ray direction.
        &#34;&#34;&#34;
        self._selected = raycast_sphere_intersect(
            start,
            vector,
            np.array(self.matrix[3], dtype=np.float32),
            self._bounding_radius,
        )

        for obj in self.children:
            x = self.children[obj].select(start, vector)
            if not self._selected and x:
                self._selected = True

        return self._selected

    def destroy(self) -&gt; bool:
        &#34;&#34;&#34;
        Destroy objects self.

        Returns:
            bool: `True` on successful destroy of `self`.
        &#34;&#34;&#34;
        for material in self.materials.values():
            if material._vao &gt; NO_VERTEX_ARRAY:
                glDeleteVertexArrays(1, [self._vao])
                material._vao = NO_VERTEX_ARRAY

        if self._vao &gt; NO_VERTEX_ARRAY:
            glDeleteVertexArrays(1, [self._vao])
            self._vao = NO_VERTEX_ARRAY
        return True

    def step_back(self, steps: int = 1) -&gt; bool:
        &#34;&#34;&#34;Go back N step in time

        This is suitable for solving collisions and getting a step back.
        On the other hand, this function requires `track_motion` to be
        True.

        Args:
          steps: Number of steps to go back. (Default = 1)

        Returns:
          bool: If step back is successful
        &#34;&#34;&#34;
        steps += 1
        if not self.track_motion:
            raise Exception(&#34;track_motion should be True&#34;)
        if len(self._motion_path) &lt; steps:
            return False

        self.matrix = self._motion_path[-steps]
        del self._motion_path[-steps + 1 :]  # noqa
        return True

    def forward(self, distance: float) -&gt; None:
        &#34;&#34;&#34;Move object forward

        This method calculates to motion path according to direction
        of the object&#39;s matrix. `self.matrix[1]` indicates the direction.

        So matrix position gets updated according to direction * distance
        &#34;&#34;&#34;
        diff = scale_vector(self.matrix[1], distance)
        self.matrix[3] = add_vectors(self.matrix[3], diff)
        self.matrix[3][3] = 1.0

    def update_matrix(
        self, parent_matrix: Optional[np.ndarray] = None
    ) -&gt; None:
        &#34;&#34;&#34;Update matrix

        Turn object matrix into numpy array.

        Args:
          parent_matrix: Parent objects matrix
        &#34;&#34;&#34;
        # Turn matrix into numpy array. Numpy arrays are C Type arrays
        # suitable for OpenGL Pipeline
        self._model_matrix = np.array(self.matrix, dtype=np.float32)

        # When there is a parent object, child object follows parents matrix
        if parent_matrix is not None and len(parent_matrix) &gt; 0:
            self._model_matrix = parent_matrix.dot(self._model_matrix)

    def track(self) -&gt; bool:
        &#34;&#34;&#34;
        Track object motion

        Returns:
            bool: `True` on successful tracking of `self`.
        &#34;&#34;&#34;
        if not self.track_motion:
            return False
        if self._previous_matrix == self.matrix[3]:
            return True

        # Add the new matrix to motion path records
        self._motion_path.append(deepcopy(self.matrix))
        # Add the matrix position to motion math line for visualisation
        if self._motion_path_line is not None:
            self._motion_path_line.append(
                [[self.matrix[3][0], self.matrix[3][1], self.matrix[3][2]]]
            )

        # Python trick here! need to .copy or it will pass reference.
        self._previous_matrix = self.matrix[3].copy()
        return True

    @property
    def visible(self) -&gt; bool:
        &#34;&#34;&#34;Check if object is visible

        Returns:
          bool: `True` if visible.
        &#34;&#34;&#34;
        return self._visible

    def show(self) -&gt; None:
        self._visible = True

    def hide(self) -&gt; None:
        self._visible = False

    @property
    def has_missing_vao(self) -&gt; bool:
        return any(
            [
                material._vao == NO_VERTEX_ARRAY
                for material in self.materials.values()
            ]
        )

    def render(
        self,
        proj: np.ndarray,
        view: np.ndarray,
        lights: List[Light],
        parent_matrix: Optional[np.ndarray] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Virtual function for rendering the object. Some objects can overwrite
        this function.

        Args:
          proj: Camera projection matrix.
          view: Camera location/view matrix.
          lights: Light objects in the scene
          parent_matrix: Parent matrix is the matrix of the parent. Parent can
                         be the scene itself or another object. In case of
                         another object, object will position itself relative
                         to its parent object.
        &#34;&#34;&#34;
        if not self._visible:
            return

        if self.has_missing_vao or self._needs_update:
            self.build()

        self.update_matrix(parent_matrix=parent_matrix)
        self.track()

        if self._vertex_count == 0:
            # dummy object, render children and leave
            # render children
            for child in self.children:
                self.children[child].render(
                    proj, view, lights, self._model_matrix
                )

            return

        # Material shading mode.
        mode = None
        if self._has_vertex_colors:
            mode = Shader.PER_VERTEX_COLOR

        for material in self.materials.values():
            material.render(proj, view, self._model_matrix, lights, mode)

            # Actual rendering
            if material._vao &gt; NO_VERTEX_ARRAY and glIsVertexArray(
                material._vao
            ):
                glBindVertexArray(material._vao)
                pmode = GL_LINE
                primitive = GL_LINE_STRIP
                if material.display == SOLID:
                    pmode = GL_FILL
                    primitive = GL_TRIANGLES
                if material.display == POINTS:
                    pmode = GL_POINT
                    primitive = GL_POINTS
                glPolygonMode(GL_FRONT_AND_BACK, pmode)

                glDrawElements(
                    primitive,
                    material._vertex_count,
                    GL_UNSIGNED_INT,
                    ctypes.c_void_p(0),
                )

                if pmode != GL_FILL:
                    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
                glBindVertexArray(0)

            # End using the shader program.
            material.end()

        # Render motion path
        if self.track_motion:
            self._motion_path_line.render(proj, view, lights, parent_matrix)

        # render children
        for child in self.children:
            self.children[child].render(proj, view, lights, self._model_matrix)

    @property
    def position(self) -&gt; List[float]:
        &#34;&#34;&#34;Get position of the Object.

        Return matrix position list

        Returns:
          List[float]
        &#34;&#34;&#34;
        return self.matrix[3][:3]

    @position.setter
    def position(self, pos: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Shortcut function for explicitly modifying matrix indices.

        Basically just sets x, y, z of the matrix. Does not change its
        direction or up vectors.

        Args:
          pos: Position list ([x, y, z])
        &#34;&#34;&#34;
        if len(pos) == 2:
            pos = [pos[0], pos[1], 0.0]
        self.matrix[3][0] = pos[0]
        self.matrix[3][1] = pos[1]
        self.matrix[3][2] = pos[2]

    def add_child(self, name: str, obj: Type[&#34;Object&#34;]) -&gt; bool:
        &#34;&#34;&#34;Add child to this object.

        In a basic example:

            .. include:: ../../../examples/basics/05_children.py

        Args:
          name: Name of the object, must be unique within its siblings
          obj: Object. Must be an instance of
               `payton.scene.geometry.base.Object`

        Returns:
          bool: False in case of an error
        &#34;&#34;&#34;
        if name in self.children:
            logging.error(f&#34;Name {name} exists in object children&#34;)
            return False
        if not isinstance(obj, Object):
            logging.error(&#34;Object type is not valid&#34;)
            return False
        self.children[name] = obj
        return True

    def to_absolute(self, coordinates: List[float]) -&gt; List[float]:
        &#34;&#34;&#34;
        Return local coordinates (tuple, list) into absolute coordinates in
        space.

        Args:
          coordinates: List[float] (x, y, z)

        Returns:
          List[float] (x&#39;, y&#39;, z&#39;)
        &#34;&#34;&#34;
        return vector_transform(coordinates, self.matrix)

    def absolute_vertices(self) -&gt; Iterator[List[float]]:
        &#34;&#34;&#34;Return a map of all local vertices as absolute coordinates.

        Imagine that object B is a child of object A. In this case, B will
        always stand (follow) relative to A. If you want to know the exact
        world coordinates of all vertices in B, this method will return them.

        **Important!** This is a costly operation so use with caution!

        Returns:
          map(List[List[float]])
        &#34;&#34;&#34;
        return map(lambda v: self.to_absolute(v), self._vertices)

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle wireframe view of the Object&#34;&#34;&#34;
        d = self.material.display
        d += 1
        d = d % 3

        self.material.display = d
        for n in self.children:
            self.children[n].toggle_wireframe()

    def _calc_bounds(self) -&gt; float:
        &#34;&#34;&#34;Calculate the bounding sphere radius

        Returns:
          float
        &#34;&#34;&#34;

        bmin: Optional[List[float]] = None
        bmax: Optional[List[float]] = None
        x = [v[0] for v in self._vertices]
        y = [v[1] for v in self._vertices]
        z = [v[2] for v in self._vertices]

        if len(x) == 0 or len(y) == 0 or len(z) == 0:
            bmin = [0.0, 0.0, 0.0]
            bmax = [0.0, 0.0, 0.0]
        else:
            bmin = [min(x), min(y), min(z)]
            bmax = [max(x), max(y), max(z)]

        self._bounding_radius = distance(bmax, bmin) / 2.0
        self._bounding_box = [bmin, bmax]

        return self._bounding_radius

    @property
    def bounding_radius(self) -&gt; float:
        &#34;&#34;&#34;Return bounding radius

        This property function *WILL NOT* update the previously
        calculated value. If you add vertices to the object, you must call
        `payton.scene.geometry.base.Object.refresh` function to get radius
        and the whole object updated.

        Returns:
          float
        &#34;&#34;&#34;

        if self._bounding_radius &gt; 0:
            return self._bounding_radius
        return self._calc_bounds()

    def build(self) -&gt; bool:
        &#34;&#34;&#34;
        Build OpenGL Vertex Array for the object

        This function gets automatically called if material&#39;s `._vao` does not
        exists in the first render cycle. Once the vba is built,
        geometry changes or material display mode changes will not be
        automatically effected. So, in every geometry or display mode
        change, a `build` call is necessary.

        If `self.static` is `True`, then the system assumes that another update
        call is not expected, thus frees `_normals`, `_textcoords`,
        `_vertices` and `_indices` lists to free memory.
        So in this case, calling `build` function twice will result in
        an invisible object (will not be drawn).

        Additionally, this method goes through each material mapping and
        build their indices as well. Each material map has its own
        Vertex Array Object and gets rendered by separate glDrawElements
        call.

        Returns:
          bool
        &#34;&#34;&#34;
        self._vertex_count = 0

        # Turn python arrays into C type arrays using Numpy.
        # This is required for OpenGL. Python memory model is a bit
        # different than raw memory model of C (OpenGL)
        vertices = np.array(self._vertices, dtype=np.float32).flatten()
        normals = np.array(self._normals, dtype=np.float32).flatten()
        texcoords = np.array(self._texcoords, dtype=np.float32).flatten()
        colors = np.array(self._vertex_colors, dtype=np.float32).flatten()

        if self._vao == NO_INDICE:
            return False

        if self._vao == NO_VERTEX_ARRAY:
            self._vao = glGenVertexArrays(1)
            self._vbos = glGenBuffers(5)

        # We will let all materials to share the same buffer objects
        # We need 4 buffers (vertex, normal, texcoord, color)

        glBindVertexArray(self._vao)

        self._calc_bounds()

        # OpenGL allocates buffers in different mechanisms between
        # STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL
        # will assume that object buffer will not change and allocate it in a
        # more suitable way.
        draw = GL_STATIC_DRAW
        if not self.static:
            draw = GL_DYNAMIC_DRAW

        # Buffer overflow, we need more space.
        if self._buffer_size &lt; vertices.nbytes:
            self._buffer_size = vertices.nbytes
            self._buffer_size_changed = True
        if self._t_buffer_size &lt; texcoords.nbytes:
            self._t_buffer_size = texcoords.nbytes
            self._t_buffer_size_changed = True

        # Bind Vertices
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[0])
        if self._buffer_size_changed:
            # glBufferData creates a new data area
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, vertices, draw)
        else:
            # glBufferSubData just replaces memory area in buffer so it is
            # much more efficient way to handle things.
            glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.nbytes, vertices)

        # Bind Normals
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[1])
        if self._buffer_size_changed:
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, normals, draw)
        else:
            glBufferSubData(GL_ARRAY_BUFFER, 0, normals.nbytes, normals)

        # Bind TexCoords
        if len(self._texcoords) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[2])
            if self._t_buffer_size_changed:
                glBufferData(
                    GL_ARRAY_BUFFER, self._t_buffer_size, texcoords, draw
                )
            else:
                glBufferSubData(
                    GL_ARRAY_BUFFER, 0, texcoords.nbytes, texcoords
                )

        # Bind Vertex Colors
        if len(self._vertex_colors) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[4])
            self._has_vertex_colors = True
            if self._buffer_size_changed:
                glBufferData(GL_ARRAY_BUFFER, self._buffer_size, colors, draw)
            else:
                glBufferSubData(GL_ARRAY_BUFFER, 0, colors.nbytes, colors)

        glBindVertexArray(0)
        self._buffer_size_changed = False
        self._t_buffer_size_changed = False

        for material in self.materials.values():
            if len(material._indices) == 0:
                material._vao == NO_INDICE
                continue

            if material._vao == NO_VERTEX_ARRAY:
                # Generate Vertex Array
                material._vao = glGenVertexArrays(1)
                # We need 1 buffer for material as indices
                material._vbos = [glGenBuffers(1)]
                glBindVertexArray(material._vao)
                # Material shader must be built when there is an active binding
                # to vertex array
                material.build_shader()
            else:
                # we already have vertex array object, just bind it to modify
                glBindVertexArray(material._vao)

            indices = np.array(material._indices, dtype=np.int32).flatten()

            # Bind Vertices
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[0])
            glEnableVertexAttribArray(0)  # shader layout location
            glVertexAttribPointer(0, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))

            # Bind Normals
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[1])
            glEnableVertexAttribArray(1)  # shader layout location
            glVertexAttribPointer(1, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))

            # Bind TexCoords
            if len(self._texcoords) == len(self._vertices):
                glBindBuffer(GL_ARRAY_BUFFER, self._vbos[2])
                glEnableVertexAttribArray(2)  # shader layout location
                glVertexAttribPointer(
                    2, 2, GL_FLOAT, False, 0, ctypes.c_void_p(0)
                )

            # Bind Vertex Colors
            if len(self._vertex_colors) == len(self._vertices):
                glBindBuffer(GL_ARRAY_BUFFER, self._vbos[4])
                glEnableVertexAttribArray(3)  # shader layout location
                glVertexAttribPointer(
                    3, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0)
                )

            # Bind Indices
            glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, material._vbos[0])
            glBufferData(
                GL_ELEMENT_ARRAY_BUFFER, indices.nbytes, indices, draw
            )
            i_len = len(indices)
            material._vertex_count = i_len
            self._vertex_count += i_len

            glBindVertexArray(0)
            glBindBuffer(GL_ARRAY_BUFFER, 0)

        if self.static:
            # we can clear this data to free some more memory
            glDeleteBuffers(4, self._vbos)
            self._vbos = []

        self._needs_update = False
        return True</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.base.Line" href="base.html#payton.scene.geometry.base.Line">Line</a></li>
<li><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.point.PointCloud" href="point.html#payton.scene.geometry.point.PointCloud">PointCloud</a></li>
<li><a title="payton.scene.gui.Hud" href="../gui.html#payton.scene.gui.Hud">Hud</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="payton.scene.geometry.Object.bounding_radius"><code class="name">var <span class="ident">bounding_radius</span></code></dt>
<dd>
<section class="desc"><p>Return bounding radius</p>
<p>This property function <em>WILL NOT</em> update the previously
calculated value. If you add vertices to the object, you must call
<a title="payton.scene.geometry.base.Object.refresh" href="base.html#payton.scene.geometry.base.Object.refresh"><code>Object.refresh()</code></a> function to get radius
and the whole object updated.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def bounding_radius(self) -&gt; float:
    &#34;&#34;&#34;Return bounding radius

    This property function *WILL NOT* update the previously
    calculated value. If you add vertices to the object, you must call
    `payton.scene.geometry.base.Object.refresh` function to get radius
    and the whole object updated.

    Returns:
      float
    &#34;&#34;&#34;

    if self._bounding_radius &gt; 0:
        return self._bounding_radius
    return self._calc_bounds()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.direction"><code class="name">var <span class="ident">direction</span></code></dt>
<dd>
<section class="desc"><p>Get direction vector from Matrix</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def direction(self) -&gt; List[float]:
    &#34;&#34;&#34;Get direction vector from Matrix&#34;&#34;&#34;
    return self.matrix[1][:3]</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.has_missing_vao"><code class="name">var <span class="ident">has_missing_vao</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def has_missing_vao(self) -&gt; bool:
    return any(
        [
            material._vao == NO_VERTEX_ARRAY
            for material in self.materials.values()
        ]
    )</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.material"><code class="name">var <span class="ident">material</span></code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def material(self) -&gt; Material:
    return self.materials[DEFAULT]</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<section class="desc"><p>Get position of the Object.</p>
<p>Return matrix position list</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code>[<code>float</code>]</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def position(self) -&gt; List[float]:
    &#34;&#34;&#34;Get position of the Object.

    Return matrix position list

    Returns:
      List[float]
    &#34;&#34;&#34;
    return self.matrix[3][:3]</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.visible"><code class="name">var <span class="ident">visible</span></code></dt>
<dd>
<section class="desc"><p>Check if object is visible</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd><code>True</code> if visible.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def visible(self) -&gt; bool:
    &#34;&#34;&#34;Check if object is visible

    Returns:
      bool: `True` if visible.
    &#34;&#34;&#34;
    return self._visible</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.Object.absolute_vertices"><code class="name flex">
<span>def <span class="ident">absolute_vertices</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a map of all local vertices as absolute coordinates.</p>
<p>Imagine that object B is a child of object A. In this case, B will
always stand (follow) relative to A. If you want to know the exact
world coordinates of all vertices in B, this method will return them.</p>
<p><strong>Important!</strong> This is a costly operation so use with caution!</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>map</code>(<code>List</code>[<code>List</code>[<code>float</code>]])</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def absolute_vertices(self) -&gt; Iterator[List[float]]:
    &#34;&#34;&#34;Return a map of all local vertices as absolute coordinates.

    Imagine that object B is a child of object A. In this case, B will
    always stand (follow) relative to A. If you want to know the exact
    world coordinates of all vertices in B, this method will return them.

    **Important!** This is a costly operation so use with caution!

    Returns:
      map(List[List[float]])
    &#34;&#34;&#34;
    return map(lambda v: self.to_absolute(v), self._vertices)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.add_child"><code class="name flex">
<span>def <span class="ident">add_child</span></span>(<span>self, name, obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Add child to this object.</p>
<p>In a basic example:</p>
<pre><code>import os
import math
from payton.scene import Scene
from payton.scene.geometry import Sphere
from payton.scene.light import Light


def motion(period, total):
    global space
    angle = (total * 10) % 360
    px = math.cos(math.radians(angle)) * 8
    py = math.sin(math.radians(angle)) * 8
    space.objects["nucleus"].children["particle"].position = [px, py, 0]

    sx = math.cos(math.radians(angle * 10)) * 2  # 10 times faster
    sy = math.sin(math.radians(angle * 10)) * 2
    space.objects["nucleus"].children["particle"].children[
        "sub_particle"
    ].position = [sx, sy, 0]
    space.lights[0].position = [px, py, 0]
    space.lights[1].position = [-px, -py, 0]


space = Scene()
space.lights.append(Light())
space.observers[0].position = [20, 20, 20]
space.grid.resize(40, 40, 1)

texture_file = os.path.join(os.path.dirname(__file__), "map.png")

nucleus = Sphere(radius=5, parallels=36, meridians=36)
nucleus.material.texture = texture_file
particle = Sphere()
particle.position = [8, 0, 0]

sub_particle = Sphere(radius=0.5)
sub_particle.position = [0, 2, 0]

nucleus.add_child("particle", particle)
particle.add_child("sub_particle", sub_particle)

space.add_object("nucleus", nucleus)

space.create_clock("motion", 0.01, motion)
print("Hit SPACE to continue animation")
space.run()
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the object, must be unique within its siblings</dd>
<dt><strong><code>obj</code></strong></dt>
<dd>Object. Must be an instance of
<a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object"><code>Object</code></a></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>False in case of an error</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_child(self, name: str, obj: Type[&#34;Object&#34;]) -&gt; bool:
    &#34;&#34;&#34;Add child to this object.

    In a basic example:

        .. include:: ../../../examples/basics/05_children.py

    Args:
      name: Name of the object, must be unique within its siblings
      obj: Object. Must be an instance of
           `payton.scene.geometry.base.Object`

    Returns:
      bool: False in case of an error
    &#34;&#34;&#34;
    if name in self.children:
        logging.error(f&#34;Name {name} exists in object children&#34;)
        return False
    if not isinstance(obj, Object):
        logging.error(&#34;Object type is not valid&#34;)
        return False
    self.children[name] = obj
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.add_material"><code class="name flex">
<span>def <span class="ident">add_material</span></span>(<span>self, name, material)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a material to the object.</p>
<p>Keep in mind that, adding material does not refer to the material
but does it through deepcopy. Initially, material holds indice
and vertex buffer objectt references. In order to prevent user
from breaking the objects, we create the clone of the material.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_material(self, name: str, material: Material) -&gt; None:
    &#34;&#34;&#34;Add a material to the object.

    Keep in mind that, adding material does not refer to the material
    but does it through deepcopy. Initially, material holds indice
    and vertex buffer objectt references. In order to prevent user
    from breaking the objects, we create the clone of the material.
    &#34;&#34;&#34;
    if name in self.materials:
        raise Exception(f&#34;Name {name} already exists&#34;)
    self.materials[name] = deepcopy(material)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Build OpenGL Vertex Array for the object</p>
<p>This function gets automatically called if material's <code>._vao</code> does not
exists in the first render cycle. Once the vba is built,
geometry changes or material display mode changes will not be
automatically effected. So, in every geometry or display mode
change, a <code>build</code> call is necessary.</p>
<p>If <code>self.static</code> is <code>True</code>, then the system assumes that another update
call is not expected, thus frees <code>_normals</code>, <code>_textcoords</code>,
<code>_vertices</code> and <code>_indices</code> lists to free memory.
So in this case, calling <code>build</code> function twice will result in
an invisible object (will not be drawn).</p>
<p>Additionally, this method goes through each material mapping and
build their indices as well. Each material map has its own
Vertex Array Object and gets rendered by separate glDrawElements
call.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build(self) -&gt; bool:
    &#34;&#34;&#34;
    Build OpenGL Vertex Array for the object

    This function gets automatically called if material&#39;s `._vao` does not
    exists in the first render cycle. Once the vba is built,
    geometry changes or material display mode changes will not be
    automatically effected. So, in every geometry or display mode
    change, a `build` call is necessary.

    If `self.static` is `True`, then the system assumes that another update
    call is not expected, thus frees `_normals`, `_textcoords`,
    `_vertices` and `_indices` lists to free memory.
    So in this case, calling `build` function twice will result in
    an invisible object (will not be drawn).

    Additionally, this method goes through each material mapping and
    build their indices as well. Each material map has its own
    Vertex Array Object and gets rendered by separate glDrawElements
    call.

    Returns:
      bool
    &#34;&#34;&#34;
    self._vertex_count = 0

    # Turn python arrays into C type arrays using Numpy.
    # This is required for OpenGL. Python memory model is a bit
    # different than raw memory model of C (OpenGL)
    vertices = np.array(self._vertices, dtype=np.float32).flatten()
    normals = np.array(self._normals, dtype=np.float32).flatten()
    texcoords = np.array(self._texcoords, dtype=np.float32).flatten()
    colors = np.array(self._vertex_colors, dtype=np.float32).flatten()

    if self._vao == NO_INDICE:
        return False

    if self._vao == NO_VERTEX_ARRAY:
        self._vao = glGenVertexArrays(1)
        self._vbos = glGenBuffers(5)

    # We will let all materials to share the same buffer objects
    # We need 4 buffers (vertex, normal, texcoord, color)

    glBindVertexArray(self._vao)

    self._calc_bounds()

    # OpenGL allocates buffers in different mechanisms between
    # STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL
    # will assume that object buffer will not change and allocate it in a
    # more suitable way.
    draw = GL_STATIC_DRAW
    if not self.static:
        draw = GL_DYNAMIC_DRAW

    # Buffer overflow, we need more space.
    if self._buffer_size &lt; vertices.nbytes:
        self._buffer_size = vertices.nbytes
        self._buffer_size_changed = True
    if self._t_buffer_size &lt; texcoords.nbytes:
        self._t_buffer_size = texcoords.nbytes
        self._t_buffer_size_changed = True

    # Bind Vertices
    glBindBuffer(GL_ARRAY_BUFFER, self._vbos[0])
    if self._buffer_size_changed:
        # glBufferData creates a new data area
        glBufferData(GL_ARRAY_BUFFER, self._buffer_size, vertices, draw)
    else:
        # glBufferSubData just replaces memory area in buffer so it is
        # much more efficient way to handle things.
        glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.nbytes, vertices)

    # Bind Normals
    glBindBuffer(GL_ARRAY_BUFFER, self._vbos[1])
    if self._buffer_size_changed:
        glBufferData(GL_ARRAY_BUFFER, self._buffer_size, normals, draw)
    else:
        glBufferSubData(GL_ARRAY_BUFFER, 0, normals.nbytes, normals)

    # Bind TexCoords
    if len(self._texcoords) == len(self._vertices):
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[2])
        if self._t_buffer_size_changed:
            glBufferData(
                GL_ARRAY_BUFFER, self._t_buffer_size, texcoords, draw
            )
        else:
            glBufferSubData(
                GL_ARRAY_BUFFER, 0, texcoords.nbytes, texcoords
            )

    # Bind Vertex Colors
    if len(self._vertex_colors) == len(self._vertices):
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[4])
        self._has_vertex_colors = True
        if self._buffer_size_changed:
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, colors, draw)
        else:
            glBufferSubData(GL_ARRAY_BUFFER, 0, colors.nbytes, colors)

    glBindVertexArray(0)
    self._buffer_size_changed = False
    self._t_buffer_size_changed = False

    for material in self.materials.values():
        if len(material._indices) == 0:
            material._vao == NO_INDICE
            continue

        if material._vao == NO_VERTEX_ARRAY:
            # Generate Vertex Array
            material._vao = glGenVertexArrays(1)
            # We need 1 buffer for material as indices
            material._vbos = [glGenBuffers(1)]
            glBindVertexArray(material._vao)
            # Material shader must be built when there is an active binding
            # to vertex array
            material.build_shader()
        else:
            # we already have vertex array object, just bind it to modify
            glBindVertexArray(material._vao)

        indices = np.array(material._indices, dtype=np.int32).flatten()

        # Bind Vertices
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[0])
        glEnableVertexAttribArray(0)  # shader layout location
        glVertexAttribPointer(0, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))

        # Bind Normals
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[1])
        glEnableVertexAttribArray(1)  # shader layout location
        glVertexAttribPointer(1, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))

        # Bind TexCoords
        if len(self._texcoords) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[2])
            glEnableVertexAttribArray(2)  # shader layout location
            glVertexAttribPointer(
                2, 2, GL_FLOAT, False, 0, ctypes.c_void_p(0)
            )

        # Bind Vertex Colors
        if len(self._vertex_colors) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[4])
            glEnableVertexAttribArray(3)  # shader layout location
            glVertexAttribPointer(
                3, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0)
            )

        # Bind Indices
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, material._vbos[0])
        glBufferData(
            GL_ELEMENT_ARRAY_BUFFER, indices.nbytes, indices, draw
        )
        i_len = len(indices)
        material._vertex_count = i_len
        self._vertex_count += i_len

        glBindVertexArray(0)
        glBindBuffer(GL_ARRAY_BUFFER, 0)

    if self.static:
        # we can clear this data to free some more memory
        glDeleteBuffers(4, self._vbos)
        self._vbos = []

    self._needs_update = False
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Destroy objects self.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd><code>True</code> on successful destroy of <code>self</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def destroy(self) -&gt; bool:
    &#34;&#34;&#34;
    Destroy objects self.

    Returns:
        bool: `True` on successful destroy of `self`.
    &#34;&#34;&#34;
    for material in self.materials.values():
        if material._vao &gt; NO_VERTEX_ARRAY:
            glDeleteVertexArrays(1, [self._vao])
            material._vao = NO_VERTEX_ARRAY

    if self._vao &gt; NO_VERTEX_ARRAY:
        glDeleteVertexArrays(1, [self._vao])
        self._vao = NO_VERTEX_ARRAY
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.direct_to"><code class="name flex">
<span>def <span class="ident">direct_to</span></span>(<span>self, v)</span>
</code></dt>
<dd>
<section class="desc"><p>Direct the objects forward towards given point vector</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def direct_to(self, v: List[float]):
    &#34;&#34;&#34;Direct the objects forward towards given point vector&#34;&#34;&#34;
    diff = sub_vector(v, self.position)
    diff = normalize_vector(diff)
    self.direction = diff</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, distance)</span>
</code></dt>
<dd>
<section class="desc"><p>Move object forward</p>
<p>This method calculates to motion path according to direction
of the object's matrix. <code>self.matrix[1]</code> indicates the direction.</p>
<p>So matrix position gets updated according to direction * distance</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def forward(self, distance: float) -&gt; None:
    &#34;&#34;&#34;Move object forward

    This method calculates to motion path according to direction
    of the object&#39;s matrix. `self.matrix[1]` indicates the direction.

    So matrix position gets updated according to direction * distance
    &#34;&#34;&#34;
    diff = scale_vector(self.matrix[1], distance)
    self.matrix[3] = add_vectors(self.matrix[3], diff)
    self.matrix[3][3] = 1.0</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.hide"><code class="name flex">
<span>def <span class="ident">hide</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hide(self) -&gt; None:
    self._visible = False</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Refresh object</p>
<p>Forces object to get built again</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def refresh(self) -&gt; None:
    &#34;&#34;&#34;Refresh object

    Forces object to get built again
    &#34;&#34;&#34;
    self._needs_update = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, proj, view, lights, parent_matrix=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Virtual function for rendering the object. Some objects can overwrite
this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proj</code></strong></dt>
<dd>Camera projection matrix.</dd>
<dt><strong><code>view</code></strong></dt>
<dd>Camera location/view matrix.</dd>
<dt><strong><code>lights</code></strong></dt>
<dd>Light objects in the scene</dd>
<dt><strong><code>parent_matrix</code></strong></dt>
<dd>Parent matrix is the matrix of the parent. Parent can
be the scene itself or another object. In case of
another object, object will position itself relative
to its parent object.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def render(
    self,
    proj: np.ndarray,
    view: np.ndarray,
    lights: List[Light],
    parent_matrix: Optional[np.ndarray] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Virtual function for rendering the object. Some objects can overwrite
    this function.

    Args:
      proj: Camera projection matrix.
      view: Camera location/view matrix.
      lights: Light objects in the scene
      parent_matrix: Parent matrix is the matrix of the parent. Parent can
                     be the scene itself or another object. In case of
                     another object, object will position itself relative
                     to its parent object.
    &#34;&#34;&#34;
    if not self._visible:
        return

    if self.has_missing_vao or self._needs_update:
        self.build()

    self.update_matrix(parent_matrix=parent_matrix)
    self.track()

    if self._vertex_count == 0:
        # dummy object, render children and leave
        # render children
        for child in self.children:
            self.children[child].render(
                proj, view, lights, self._model_matrix
            )

        return

    # Material shading mode.
    mode = None
    if self._has_vertex_colors:
        mode = Shader.PER_VERTEX_COLOR

    for material in self.materials.values():
        material.render(proj, view, self._model_matrix, lights, mode)

        # Actual rendering
        if material._vao &gt; NO_VERTEX_ARRAY and glIsVertexArray(
            material._vao
        ):
            glBindVertexArray(material._vao)
            pmode = GL_LINE
            primitive = GL_LINE_STRIP
            if material.display == SOLID:
                pmode = GL_FILL
                primitive = GL_TRIANGLES
            if material.display == POINTS:
                pmode = GL_POINT
                primitive = GL_POINTS
            glPolygonMode(GL_FRONT_AND_BACK, pmode)

            glDrawElements(
                primitive,
                material._vertex_count,
                GL_UNSIGNED_INT,
                ctypes.c_void_p(0),
            )

            if pmode != GL_FILL:
                glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
            glBindVertexArray(0)

        # End using the shader program.
        material.end()

    # Render motion path
    if self.track_motion:
        self._motion_path_line.render(proj, view, lights, parent_matrix)

    # render children
    for child in self.children:
        self.children[child].render(proj, view, lights, self._model_matrix)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.rotate_around_x"><code class="name flex">
<span>def <span class="ident">rotate_around_x</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<section class="desc"><p>Pitch - Rotate around X axis</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle in radians</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotate_around_x(self, angle: float) -&gt; None:
    &#34;&#34;&#34;Pitch - Rotate around X axis

    Args:
      angle: Angle in radians
    &#34;&#34;&#34;
    rot_matrix = create_rotation_matrix([1, 0, 0], angle)
    local_matrix = np.array(self.matrix, dtype=np.float32)
    local_matrix = rot_matrix.dot(local_matrix)
    self.matrix = local_matrix.tolist()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.rotate_around_y"><code class="name flex">
<span>def <span class="ident">rotate_around_y</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<section class="desc"><p>Roll - Rotate around Y Axis (Direction)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle in radians</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotate_around_y(self, angle: float) -&gt; None:
    &#34;&#34;&#34;Roll - Rotate around Y Axis (Direction)

    Args:
      angle: Angle in radians
    &#34;&#34;&#34;
    rot_matrix = create_rotation_matrix([0, 1, 0], angle)
    local_matrix = np.array(self.matrix, dtype=np.float32)
    local_matrix = rot_matrix.dot(local_matrix)
    self.matrix = local_matrix.tolist()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.rotate_around_z"><code class="name flex">
<span>def <span class="ident">rotate_around_z</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate around Z Axis</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle in radians</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotate_around_z(self, angle: float) -&gt; None:
    &#34;&#34;&#34;Rotate around Z Axis

    Args:
      angle: Angle in radians
    &#34;&#34;&#34;
    rot_matrix = create_rotation_matrix([0, 0, 1], angle)
    local_matrix = np.array(self.matrix, dtype=np.float32)
    local_matrix = rot_matrix.dot(local_matrix)
    self.matrix = local_matrix.tolist()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, start, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Select test for object using bounding Sphere.</p>
<p>This method is not 100% accurate as it is based on a rough
assumption. Sphere area will be larger than actual object.</p>
<p>If you want to have a more accurate way to handle this, try
using raycast triangle intersect</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>Starting point of the ray (such as eye position)</dd>
<dt><strong><code>vector</code></strong></dt>
<dd>Ray direction. This is not the end point of a line!
This is a unit vector showing the ray direction.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select(self, start: np.ndarray, vector: np.ndarray) -&gt; bool:
    &#34;&#34;&#34;Select test for object using bounding Sphere.

    This method is not 100% accurate as it is based on a rough
    assumption. Sphere area will be larger than actual object.

    If you want to have a more accurate way to handle this, try
    using raycast triangle intersect

    Args:
      start: Starting point of the ray (such as eye position)
      vector: Ray direction. This is not the end point of a line!
              This is a unit vector showing the ray direction.
    &#34;&#34;&#34;
    self._selected = raycast_sphere_intersect(
        start,
        vector,
        np.array(self.matrix[3], dtype=np.float32),
        self._bounding_radius,
    )

    for obj in self.children:
        x = self.children[obj].select(start, vector)
        if not self._selected and x:
            self._selected = True

    return self._selected</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show(self) -&gt; None:
    self._visible = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.step_back"><code class="name flex">
<span>def <span class="ident">step_back</span></span>(<span>self, steps=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Go back N step in time</p>
<p>This is suitable for solving collisions and getting a step back.
On the other hand, this function requires <code>track_motion</code> to be
True.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>steps</code></strong></dt>
<dd>Number of steps to go back. (Default = 1)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>If step back is successful</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def step_back(self, steps: int = 1) -&gt; bool:
    &#34;&#34;&#34;Go back N step in time

    This is suitable for solving collisions and getting a step back.
    On the other hand, this function requires `track_motion` to be
    True.

    Args:
      steps: Number of steps to go back. (Default = 1)

    Returns:
      bool: If step back is successful
    &#34;&#34;&#34;
    steps += 1
    if not self.track_motion:
        raise Exception(&#34;track_motion should be True&#34;)
    if len(self._motion_path) &lt; steps:
        return False

    self.matrix = self._motion_path[-steps]
    del self._motion_path[-steps + 1 :]  # noqa
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.to_absolute"><code class="name flex">
<span>def <span class="ident">to_absolute</span></span>(<span>self, coordinates)</span>
</code></dt>
<dd>
<section class="desc"><p>Return local coordinates (tuple, list) into absolute coordinates in
space.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coordinates</code></strong></dt>
<dd>List[float] (x, y, z)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code>[<code>float</code>] (<code>x'</code>, <code>y'</code>, <code>z'</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def to_absolute(self, coordinates: List[float]) -&gt; List[float]:
    &#34;&#34;&#34;
    Return local coordinates (tuple, list) into absolute coordinates in
    space.

    Args:
      coordinates: List[float] (x, y, z)

    Returns:
      List[float] (x&#39;, y&#39;, z&#39;)
    &#34;&#34;&#34;
    return vector_transform(coordinates, self.matrix)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.toggle_wireframe"><code class="name flex">
<span>def <span class="ident">toggle_wireframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Toggle wireframe view of the Object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def toggle_wireframe(self) -&gt; None:
    &#34;&#34;&#34;Toggle wireframe view of the Object&#34;&#34;&#34;
    d = self.material.display
    d += 1
    d = d % 3

    self.material.display = d
    for n in self.children:
        self.children[n].toggle_wireframe()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.track"><code class="name flex">
<span>def <span class="ident">track</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Track object motion</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd><code>True</code> on successful tracking of <code>self</code>.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def track(self) -&gt; bool:
    &#34;&#34;&#34;
    Track object motion

    Returns:
        bool: `True` on successful tracking of `self`.
    &#34;&#34;&#34;
    if not self.track_motion:
        return False
    if self._previous_matrix == self.matrix[3]:
        return True

    # Add the new matrix to motion path records
    self._motion_path.append(deepcopy(self.matrix))
    # Add the matrix position to motion math line for visualisation
    if self._motion_path_line is not None:
        self._motion_path_line.append(
            [[self.matrix[3][0], self.matrix[3][1], self.matrix[3][2]]]
        )

    # Python trick here! need to .copy or it will pass reference.
    self._previous_matrix = self.matrix[3].copy()
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.update_matrix"><code class="name flex">
<span>def <span class="ident">update_matrix</span></span>(<span>self, parent_matrix=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Update matrix</p>
<p>Turn object matrix into numpy array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_matrix</code></strong></dt>
<dd>Parent objects matrix</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_matrix(
    self, parent_matrix: Optional[np.ndarray] = None
) -&gt; None:
    &#34;&#34;&#34;Update matrix

    Turn object matrix into numpy array.

    Args:
      parent_matrix: Parent objects matrix
    &#34;&#34;&#34;
    # Turn matrix into numpy array. Numpy arrays are C Type arrays
    # suitable for OpenGL Pipeline
    self._model_matrix = np.array(self.matrix, dtype=np.float32)

    # When there is a parent object, child object follows parents matrix
    if parent_matrix is not None and len(parent_matrix) &gt; 0:
        self._model_matrix = parent_matrix.dot(self._model_matrix)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="payton.scene.geometry.Plane"><code class="flex name class">
<span>class <span class="ident">Plane</span></span>
<span>(</span><span>width=1.0, height=1.0, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Plane object</p>
<p>This is a 2D Plane in 3D World. Has a width in X and height in Y.
If you need to place it in another axis, try modifying its matrix.</p>
<p>Example use case:</p>
<pre><code>from payton.scene import Scene
from payton.scene.geometry import Plane


scene = Scene()
plane = Plane(width=2, height=2)
scene.add_object("plane", plane)
scene.run()
</code></pre>
<p>Initialize plane</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong></dt>
<dd>Width of the plane</dd>
<dt><strong><code>height</code></strong></dt>
<dd>Height of the plane</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Plane(Mesh):
    &#34;&#34;&#34;Plane object

    This is a 2D Plane in 3D World. Has a width in X and height in Y.
    If you need to place it in another axis, try modifying its matrix.

    Example use case:

        .. include:: ../../../examples/basics/13_plane.py
    &#34;&#34;&#34;

    def __init__(
        self, width: float = 1.0, height: float = 1.0, **kwargs: Any
    ) -&gt; None:
        &#34;&#34;&#34;Initialize plane

        Args:
          width: Width of the plane
          height: Height of the plane
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        width *= 0.5
        height *= 0.5
        self._vertices = [
            [-width, -height, 0],
            [width, -height, 0],
            [width, height, 0],
            [-width, height, 0],
        ]
        self._normals = [[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]]
        self._texcoords = [[-1, -1], [1, -1], [1, 1], [-1, 1]]
        self._indices = [[0, 1, 2], [2, 3, 0]]
        self.material._indices = self._indices</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.mesh.Mesh.absolute_vertices" href="base.html#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_child" href="base.html#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_material" href="base.html#payton.scene.geometry.base.Object.add_material">add_material</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_triangle" href="mesh.html#payton.scene.geometry.mesh.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.bounding_radius" href="base.html#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.build" href="base.html#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.clear_triangles" href="mesh.html#payton.scene.geometry.mesh.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.destroy" href="base.html#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direct_to" href="base.html#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direction" href="base.html#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_normals" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_texcoords" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_texcoords">fix_texcoords</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.forward" href="base.html#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.position" href="base.html#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.refresh" href="base.html#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.render" href="base.html#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_x" href="base.html#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_y" href="base.html#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_z" href="base.html#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.scale" href="mesh.html#payton.scene.geometry.mesh.Mesh.scale">scale</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.select" href="base.html#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.step_back" href="base.html#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.to_absolute" href="base.html#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.toggle_wireframe" href="base.html#payton.scene.geometry.base.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.track" href="base.html#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.update_matrix" href="base.html#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.visible" href="base.html#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.PointCloud"><code class="flex name class">
<span>class <span class="ident">PointCloud</span></span>
<span>(</span><span>vertices=None, colors=None, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Point cloud</p>
<p>If you change the vertices, do not forget to do a <code>refresh</code> to take
effect.</p>
<p>Example use case:</p>
<pre><code>import random
from payton.scene import Scene
from payton.scene.gui import Hud, Text
from payton.scene.geometry import PointCloud


def generate(period, total):
    global scene
    x = random.randint(-10, 10)
    y = random.randint(-10, 10)
    z = random.randint(-10, 10)
    r = random.randint(0, 255) / 255
    g = random.randint(0, 255) / 255
    b = random.randint(0, 255) / 255
    scene.objects["pc"].add([[x, y, z]], [[r, g, b]])


scene = Scene()
scene.background.top_color = [0, 0, 0, 1]
scene.background.bottom_color = [0, 0, 0, 1]

hud = Hud()
text = Text(
    label="Hit Space to create points",
    position=(5, 5),
    size=(200, 35),
    color=(1, 1, 1),
)

hud.add_child("text", text)
scene.add_object("hud", hud)

pc = PointCloud()

scene.add_object("pc", pc)
scene.create_clock("generate", 0.001, generate)

scene.run()
</code></pre>
<p>Initialize Point Cloud</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>List of point vertices</dd>
<dt><strong><code>colors</code></strong></dt>
<dd>List of colors per vertex, follows the same index as vertices</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class PointCloud(Object):
    &#34;&#34;&#34;Point cloud

    If you change the vertices, do not forget to do a `refresh` to take
    effect.

    Example use case:

        .. include:: ../../../examples/basics/11_point_cloud.py
    &#34;&#34;&#34;

    def __init__(
        self,
        vertices: Optional[VList] = None,
        colors: Optional[VList] = None,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize Point Cloud

        Args:
          vertices: List of point vertices
          colors: List of colors per vertex, follows the same index as vertices
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self._vertices: VList = [] if vertices is None else vertices
        # Expose vertices by reference for modification
        self.vertices: VList = self._vertices
        self._vertex_colors: VList = [] if colors is None else colors
        self._vertex_history: VList = []
        self.material.display = POINTS
        self.static: bool = False

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle wireframe overwrite to disable mode change&#34;&#34;&#34;
        pass

    def track(self) -&gt; bool:
        &#34;&#34;&#34;Tracking point cloud is not possible at the moment

        Returns:
            bool: `False`. Tracking of point clouds not implemented.
        &#34;&#34;&#34;
        return False

    def add(
        self,
        vertices: VList,
        colors: Optional[VList] = None,
        material: str = DEFAULT,
    ) -&gt; None:
        &#34;&#34;&#34;Add a point to the cloud

        Args:
          vertices: Vertices to add
          colors: Colors of the vertices in the same order. (Optional)
        &#34;&#34;&#34;
        i = len(self._indices)
        for vertex in vertices:
            self._vertices.append(vertex)
            self._indices.append([i])
            self.materials[material]._indices.append([i])
            i += 1

        if colors is not None:
            if len(colors) != len(vertices):
                logging.error(&#34;len(colors) != len(vertices)&#34;)
                return
            for color in colors:
                self._vertex_colors.append(color)

        self._needs_update = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.PointCloud.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, vertices, colors=None, material='default')</span>
</code></dt>
<dd>
<section class="desc"><p>Add a point to the cloud</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertices to add</dd>
<dt><strong><code>colors</code></strong></dt>
<dd>Colors of the vertices in the same order. (Optional)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add(
    self,
    vertices: VList,
    colors: Optional[VList] = None,
    material: str = DEFAULT,
) -&gt; None:
    &#34;&#34;&#34;Add a point to the cloud

    Args:
      vertices: Vertices to add
      colors: Colors of the vertices in the same order. (Optional)
    &#34;&#34;&#34;
    i = len(self._indices)
    for vertex in vertices:
        self._vertices.append(vertex)
        self._indices.append([i])
        self.materials[material]._indices.append([i])
        i += 1

    if colors is not None:
        if len(colors) != len(vertices):
            logging.error(&#34;len(colors) != len(vertices)&#34;)
            return
        for color in colors:
            self._vertex_colors.append(color)

    self._needs_update = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.PointCloud.toggle_wireframe"><code class="name flex">
<span>def <span class="ident">toggle_wireframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Toggle wireframe overwrite to disable mode change</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def toggle_wireframe(self) -&gt; None:
    &#34;&#34;&#34;Toggle wireframe overwrite to disable mode change&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.PointCloud.track"><code class="name flex">
<span>def <span class="ident">track</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Tracking point cloud is not possible at the moment</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd><code>False</code>. Tracking of point clouds not implemented.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def track(self) -&gt; bool:
    &#34;&#34;&#34;Tracking point cloud is not possible at the moment

    Returns:
        bool: `False`. Tracking of point clouds not implemented.
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.base.Object.absolute_vertices" href="base.html#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.add_child" href="base.html#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.add_material" href="base.html#payton.scene.geometry.base.Object.add_material">add_material</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.bounding_radius" href="base.html#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.build" href="base.html#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.destroy" href="base.html#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direct_to" href="base.html#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direction" href="base.html#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.forward" href="base.html#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.position" href="base.html#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.refresh" href="base.html#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.render" href="base.html#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_x" href="base.html#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_y" href="base.html#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_z" href="base.html#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.select" href="base.html#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.step_back" href="base.html#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.to_absolute" href="base.html#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.update_matrix" href="base.html#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.visible" href="base.html#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.Sphere"><code class="flex name class">
<span>class <span class="ident">Sphere</span></span>
<span>(</span><span>radius=0.5, parallels=12, meridians=12, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Sphere object.</p>
<p>This object is generated using basic Spherical coordinates.
Beware of using high values for parallels and meridians. You might end up
with excessive number of vertices to render and a performance trouble.</p>
<p>Parameters:</p>
<ul>
<li><code>radius</code> default: <code>0.5</code></li>
<li><code>parallels</code> default: <code>12</code></li>
<li><code>meridians</code> default: <code>12</code></li>
</ul>
<p>Sphere object use case</p>
<pre><code>import os
import math
from payton.scene import Scene
from payton.scene.geometry import Sphere
from payton.scene.light import Light


def motion(period, total):
    global space
    angle = (total * 10) % 360
    px = math.cos(math.radians(angle)) * 8
    py = math.sin(math.radians(angle)) * 8
    space.objects["nucleus"].children["particle"].position = [px, py, 0]

    sx = math.cos(math.radians(angle * 10)) * 2  # 10 times faster
    sy = math.sin(math.radians(angle * 10)) * 2
    space.objects["nucleus"].children["particle"].children[
        "sub_particle"
    ].position = [sx, sy, 0]
    space.lights[0].position = [px, py, 0]
    space.lights[1].position = [-px, -py, 0]


space = Scene()
space.lights.append(Light())
space.observers[0].position = [20, 20, 20]
space.grid.resize(40, 40, 1)

texture_file = os.path.join(os.path.dirname(__file__), "map.png")

nucleus = Sphere(radius=5, parallels=36, meridians=36)
nucleus.material.texture = texture_file
particle = Sphere()
particle.position = [8, 0, 0]

sub_particle = Sphere(radius=0.5)
sub_particle.position = [0, 2, 0]

nucleus.add_child("particle", particle)
particle.add_child("sub_particle", sub_particle)

space.add_object("nucleus", nucleus)

space.create_clock("motion", 0.01, motion)
print("Hit SPACE to continue animation")
space.run()
</code></pre>
<p>Initialize the sphere</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Radius of the sphere (default: 0.5, making it a unit sphere)</dd>
<dt><strong><code>parallels</code></strong></dt>
<dd>Number of parallels (as in geography). (default: 12, 30
degrees of arcs)</dd>
<dt><strong><code>meridians</code></strong></dt>
<dd>Number of meridians (as in geography). (default: 12)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Sphere(Mesh):
    &#34;&#34;&#34;
    Sphere object.

    This object is generated using basic Spherical coordinates.
    Beware of using high values for parallels and meridians. You might end up
    with excessive number of vertices to render and a performance trouble.

    Parameters:

    - `radius` default: `0.5`
    - `parallels` default: `12`
    - `meridians` default: `12`

    Sphere object use case

        .. include:: ../../../examples/basics/05_children.py

    &#34;&#34;&#34;

    def __init__(
        self,
        radius: float = 0.5,
        parallels: int = 12,
        meridians: int = 12,
        **kwargs: Any,
    ) -&gt; None:
        &#34;&#34;&#34;Initialize the sphere

        Args:
          radius: Radius of the sphere (default: 0.5, making it a unit sphere)
          parallels: Number of parallels (as in geography). (default: 12, 30
                     degrees of arcs)
          meridians: Number of meridians (as in geography). (default: 12)
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.radius: float = radius
        self.parallels: int = parallels
        self.meridians: int = meridians
        self.build_sphere()

    def build_sphere(self) -&gt; bool:
        &#34;&#34;&#34;
        Generate the sphere

        Returns:
          bool: `True` on successful creation of a `Sphere` object.
        &#34;&#34;&#34;
        r = self.radius
        # step angle is the rotational angle to build the sphere
        step_angle = math.radians(360.0 / self.meridians)
        # step height is the arc in height
        step_height = math.radians(180.0 / self.parallels)
        indices = 0
        u_step = 1.0 / self.meridians
        v_step = 1.0 / self.parallels

        for i, j in product(range(self.parallels), range(self.meridians)):
            x1 = r * math.sin(step_height * i) * math.cos(step_angle * j)
            y1 = r * math.sin(step_height * i) * math.sin(step_angle * j)
            z1 = r * math.cos(step_height * i)
            u1 = u_step * j
            v1 = v_step * i

            x2 = r * math.sin(step_height * (i + 1)) * math.cos(step_angle * j)
            y2 = r * math.sin(step_height * (i + 1)) * math.sin(step_angle * j)
            z2 = r * math.cos(step_height * (i + 1))
            u2 = u_step * j
            v2 = v_step * (i + 1)

            x3 = (
                r
                * math.sin(step_height * (i + 1))
                * math.cos(step_angle * (j + 1))
            )
            y3 = (
                r
                * math.sin(step_height * (i + 1))
                * math.sin(step_angle * (j + 1))
            )
            z3 = r * math.cos(step_height * (i + 1))
            u3 = u_step * (j + 1)
            v3 = v_step * (i + 1)

            x4 = r * math.sin(step_height * i) * math.cos(step_angle * (j + 1))
            y4 = r * math.sin(step_height * i) * math.sin(step_angle * (j + 1))
            z4 = r * math.cos(step_height * i)
            u4 = u_step * (j + 1)
            v4 = v_step * i

            normal = plane_normal([x1, y1, z1], [x2, y2, z2], [x3, y3, z3])
            self._vertices.append([x1, y1, z1])
            self._vertices.append([x2, y2, z2])
            self._vertices.append([x3, y3, z3])
            self._vertices.append([x4, y4, z4])
            self._texcoords.append([u1, v1])
            self._texcoords.append([u2, v2])
            self._texcoords.append([u3, v3])
            self._texcoords.append([u4, v4])
            self._normals.append([normal[0], normal[1], normal[2]])
            self._normals.append([normal[0], normal[1], normal[2]])
            self._normals.append([normal[0], normal[1], normal[2]])
            self._normals.append([normal[0], normal[1], normal[2]])
            self._indices.append([indices, indices + 1, indices + 2])
            self._indices.append([indices, indices + 2, indices + 3])
            self.materials[DEFAULT]._indices.append(
                [indices, indices + 1, indices + 2]
            )
            self.materials[DEFAULT]._indices.append(
                [indices, indices + 2, indices + 3]
            )
            indices += 4
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.Sphere.build_sphere"><code class="name flex">
<span>def <span class="ident">build_sphere</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate the sphere</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd><code>True</code> on successful creation of a <a title="payton.scene.geometry.Sphere" href="#payton.scene.geometry.Sphere"><code>Sphere</code></a> object.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build_sphere(self) -&gt; bool:
    &#34;&#34;&#34;
    Generate the sphere

    Returns:
      bool: `True` on successful creation of a `Sphere` object.
    &#34;&#34;&#34;
    r = self.radius
    # step angle is the rotational angle to build the sphere
    step_angle = math.radians(360.0 / self.meridians)
    # step height is the arc in height
    step_height = math.radians(180.0 / self.parallels)
    indices = 0
    u_step = 1.0 / self.meridians
    v_step = 1.0 / self.parallels

    for i, j in product(range(self.parallels), range(self.meridians)):
        x1 = r * math.sin(step_height * i) * math.cos(step_angle * j)
        y1 = r * math.sin(step_height * i) * math.sin(step_angle * j)
        z1 = r * math.cos(step_height * i)
        u1 = u_step * j
        v1 = v_step * i

        x2 = r * math.sin(step_height * (i + 1)) * math.cos(step_angle * j)
        y2 = r * math.sin(step_height * (i + 1)) * math.sin(step_angle * j)
        z2 = r * math.cos(step_height * (i + 1))
        u2 = u_step * j
        v2 = v_step * (i + 1)

        x3 = (
            r
            * math.sin(step_height * (i + 1))
            * math.cos(step_angle * (j + 1))
        )
        y3 = (
            r
            * math.sin(step_height * (i + 1))
            * math.sin(step_angle * (j + 1))
        )
        z3 = r * math.cos(step_height * (i + 1))
        u3 = u_step * (j + 1)
        v3 = v_step * (i + 1)

        x4 = r * math.sin(step_height * i) * math.cos(step_angle * (j + 1))
        y4 = r * math.sin(step_height * i) * math.sin(step_angle * (j + 1))
        z4 = r * math.cos(step_height * i)
        u4 = u_step * (j + 1)
        v4 = v_step * i

        normal = plane_normal([x1, y1, z1], [x2, y2, z2], [x3, y3, z3])
        self._vertices.append([x1, y1, z1])
        self._vertices.append([x2, y2, z2])
        self._vertices.append([x3, y3, z3])
        self._vertices.append([x4, y4, z4])
        self._texcoords.append([u1, v1])
        self._texcoords.append([u2, v2])
        self._texcoords.append([u3, v3])
        self._texcoords.append([u4, v4])
        self._normals.append([normal[0], normal[1], normal[2]])
        self._normals.append([normal[0], normal[1], normal[2]])
        self._normals.append([normal[0], normal[1], normal[2]])
        self._normals.append([normal[0], normal[1], normal[2]])
        self._indices.append([indices, indices + 1, indices + 2])
        self._indices.append([indices, indices + 2, indices + 3])
        self.materials[DEFAULT]._indices.append(
            [indices, indices + 1, indices + 2]
        )
        self.materials[DEFAULT]._indices.append(
            [indices, indices + 2, indices + 3]
        )
        indices += 4
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.mesh.Mesh" href="mesh.html#payton.scene.geometry.mesh.Mesh">Mesh</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.mesh.Mesh.absolute_vertices" href="base.html#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_child" href="base.html#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_material" href="base.html#payton.scene.geometry.base.Object.add_material">add_material</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_triangle" href="mesh.html#payton.scene.geometry.mesh.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.bounding_radius" href="base.html#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.build" href="base.html#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.clear_triangles" href="mesh.html#payton.scene.geometry.mesh.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.destroy" href="base.html#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direct_to" href="base.html#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.direction" href="base.html#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_normals" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_texcoords" href="mesh.html#payton.scene.geometry.mesh.Mesh.fix_texcoords">fix_texcoords</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.forward" href="base.html#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.position" href="base.html#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.refresh" href="base.html#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.render" href="base.html#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_x" href="base.html#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_y" href="base.html#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.rotate_around_z" href="base.html#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.scale" href="mesh.html#payton.scene.geometry.mesh.Mesh.scale">scale</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.select" href="base.html#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.step_back" href="base.html#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.to_absolute" href="base.html#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.toggle_wireframe" href="base.html#payton.scene.geometry.base.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.track" href="base.html#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.update_matrix" href="base.html#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.visible" href="base.html#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="payton.scene" href="../index.html">payton.scene</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="payton.scene.geometry.base" href="base.html">payton.scene.geometry.base</a></code></li>
<li><code><a title="payton.scene.geometry.cube" href="cube.html">payton.scene.geometry.cube</a></code></li>
<li><code><a title="payton.scene.geometry.cylinder" href="cylinder.html">payton.scene.geometry.cylinder</a></code></li>
<li><code><a title="payton.scene.geometry.md2" href="md2.html">payton.scene.geometry.md2</a></code></li>
<li><code><a title="payton.scene.geometry.mesh" href="mesh.html">payton.scene.geometry.mesh</a></code></li>
<li><code><a title="payton.scene.geometry.plane" href="plane.html">payton.scene.geometry.plane</a></code></li>
<li><code><a title="payton.scene.geometry.point" href="point.html">payton.scene.geometry.point</a></code></li>
<li><code><a title="payton.scene.geometry.sphere" href="sphere.html">payton.scene.geometry.sphere</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="payton.scene.geometry.Cube" href="#payton.scene.geometry.Cube">Cube</a></code></h4>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Cylinder" href="#payton.scene.geometry.Cylinder">Cylinder</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.Cylinder.build_cylinder" href="#payton.scene.geometry.Cylinder.build_cylinder">build_cylinder</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Line" href="#payton.scene.geometry.Line">Line</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.Line.add_material" href="#payton.scene.geometry.Line.add_material">add_material</a></code></li>
<li><code><a title="payton.scene.geometry.Line.append" href="#payton.scene.geometry.Line.append">append</a></code></li>
<li><code><a title="payton.scene.geometry.Line.build_lines" href="#payton.scene.geometry.Line.build_lines">build_lines</a></code></li>
<li><code><a title="payton.scene.geometry.Line.toggle_wireframe" href="#payton.scene.geometry.Line.toggle_wireframe">toggle_wireframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.MD2" href="#payton.scene.geometry.MD2">MD2</a></code></h4>
<ul class="two-column">
<li><code><a title="payton.scene.geometry.MD2.animate" href="#payton.scene.geometry.MD2.animate">animate</a></code></li>
<li><code><a title="payton.scene.geometry.MD2.build_frame" href="#payton.scene.geometry.MD2.build_frame">build_frame</a></code></li>
<li><code><a title="payton.scene.geometry.MD2.compile" href="#payton.scene.geometry.MD2.compile">compile</a></code></li>
<li><code><a title="payton.scene.geometry.MD2.load_buffer" href="#payton.scene.geometry.MD2.load_buffer">load_buffer</a></code></li>
<li><code><a title="payton.scene.geometry.MD2.load_file" href="#payton.scene.geometry.MD2.load_file">load_file</a></code></li>
<li><code><a title="payton.scene.geometry.MD2.load_frames" href="#payton.scene.geometry.MD2.load_frames">load_frames</a></code></li>
<li><code><a title="payton.scene.geometry.MD2.read_frame" href="#payton.scene.geometry.MD2.read_frame">read_frame</a></code></li>
<li><code><a title="payton.scene.geometry.MD2.read_header" href="#payton.scene.geometry.MD2.read_header">read_header</a></code></li>
<li><code><a title="payton.scene.geometry.MD2.read_skin" href="#payton.scene.geometry.MD2.read_skin">read_skin</a></code></li>
<li><code><a title="payton.scene.geometry.MD2.read_tex_coords" href="#payton.scene.geometry.MD2.read_tex_coords">read_tex_coords</a></code></li>
<li><code><a title="payton.scene.geometry.MD2.read_triangles" href="#payton.scene.geometry.MD2.read_triangles">read_triangles</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.MatrixPlane" href="#payton.scene.geometry.MatrixPlane">MatrixPlane</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.MatrixPlane.populate_grid" href="#payton.scene.geometry.MatrixPlane.populate_grid">populate_grid</a></code></li>
<li><code><a title="payton.scene.geometry.MatrixPlane.update_grid" href="#payton.scene.geometry.MatrixPlane.update_grid">update_grid</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.Mesh.add_triangle" href="#payton.scene.geometry.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.clear_triangles" href="#payton.scene.geometry.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.fix_normals" href="#payton.scene.geometry.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.fix_texcoords" href="#payton.scene.geometry.Mesh.fix_texcoords">fix_texcoords</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.scale" href="#payton.scene.geometry.Mesh.scale">scale</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></code></h4>
<ul class="two-column">
<li><code><a title="payton.scene.geometry.Object.absolute_vertices" href="#payton.scene.geometry.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.Object.add_child" href="#payton.scene.geometry.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.Object.add_material" href="#payton.scene.geometry.Object.add_material">add_material</a></code></li>
<li><code><a title="payton.scene.geometry.Object.bounding_radius" href="#payton.scene.geometry.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.Object.build" href="#payton.scene.geometry.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.Object.destroy" href="#payton.scene.geometry.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.Object.direct_to" href="#payton.scene.geometry.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.Object.direction" href="#payton.scene.geometry.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.Object.forward" href="#payton.scene.geometry.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.Object.has_missing_vao" href="#payton.scene.geometry.Object.has_missing_vao">has_missing_vao</a></code></li>
<li><code><a title="payton.scene.geometry.Object.hide" href="#payton.scene.geometry.Object.hide">hide</a></code></li>
<li><code><a title="payton.scene.geometry.Object.material" href="#payton.scene.geometry.Object.material">material</a></code></li>
<li><code><a title="payton.scene.geometry.Object.position" href="#payton.scene.geometry.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.Object.refresh" href="#payton.scene.geometry.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.Object.render" href="#payton.scene.geometry.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_x" href="#payton.scene.geometry.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_y" href="#payton.scene.geometry.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_z" href="#payton.scene.geometry.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.Object.select" href="#payton.scene.geometry.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.Object.show" href="#payton.scene.geometry.Object.show">show</a></code></li>
<li><code><a title="payton.scene.geometry.Object.step_back" href="#payton.scene.geometry.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.Object.to_absolute" href="#payton.scene.geometry.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.Object.toggle_wireframe" href="#payton.scene.geometry.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.Object.track" href="#payton.scene.geometry.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.Object.update_matrix" href="#payton.scene.geometry.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.Object.visible" href="#payton.scene.geometry.Object.visible">visible</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Plane" href="#payton.scene.geometry.Plane">Plane</a></code></h4>
</li>
<li>
<h4><code><a title="payton.scene.geometry.PointCloud" href="#payton.scene.geometry.PointCloud">PointCloud</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.PointCloud.add" href="#payton.scene.geometry.PointCloud.add">add</a></code></li>
<li><code><a title="payton.scene.geometry.PointCloud.toggle_wireframe" href="#payton.scene.geometry.PointCloud.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.PointCloud.track" href="#payton.scene.geometry.PointCloud.track">track</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Sphere" href="#payton.scene.geometry.Sphere">Sphere</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.Sphere.build_sphere" href="#payton.scene.geometry.Sphere.build_sphere">build_sphere</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>