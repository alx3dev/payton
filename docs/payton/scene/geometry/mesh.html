<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>payton.scene.geometry.mesh API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{margin:40px auto;max-width:1000px;display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>payton.scene.geometry.mesh</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># pylama:ignore=C901
import logging
from typing import Any, Optional

from payton.scene.geometry import Object
from payton.math.vector import plane_normal, vector_angle
from payton.scene.types import VList


class Mesh(Object):
    &#34;&#34;&#34;Mesh Object

    Mesh is almost like the Object except with some extra methods to make
    things easier. If you want to have custom geometries/shapes, it is
    better to extend `payton.scene.geometry.mesh.Mesh` instead of
    `payton.scene.geometry.base.Object`. Because Mesh will give you better
    and easier constructing capabilities such as adding triangles on the fly
    or sub-division or cutting and so forth. It is a way of designing objects
    by code.


    Example use case:

        .. include:: ../../../examples/basics/09_mesh.py
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        super().__init__(**args)
        self.static = False

    def clear_triangles(self) -&gt; None:
        &#34;&#34;&#34;Clear all triangles inside the Mesh&#34;&#34;&#34;
        self._vertices = []
        self._indices = []
        self._normals = []
        self._texcoords = []
        self._vertex_colors = []
        self.refresh()

    def fix_normals(self) -&gt; None:
        &#34;&#34;&#34;Try to re-calculate Mesh normals, if your object has already perfect
        normals, do not call this method&#34;&#34;&#34;
        self._normals = [[0, 0, 1.0]] * len(self._vertices)

        for face in self._indices:
            v1, v2, v3 = (
                self._vertices[face[0]],
                self._vertices[face[1]],
                self._vertices[face[2]],
            )
            normal = plane_normal(v1, v2, v3)
            self._normals[face[0]] = normal
            self._normals[face[1]] = normal
            self._normals[face[2]] = normal

    def fix_texcoords(self, u: int = 1, v: int = 1) -&gt; None:
        &#34;&#34;&#34;Try to recalculate mesh texture coordinates by cube projection
        &#34;&#34;&#34;
        self._texcoords = []
        self._calc_bounds()
        bbox = self._bounding_box
        vmin, vmax = bbox[0], bbox[1]
        width = vmax[0] - vmin[0]
        depth = vmax[1] - vmin[1]
        height = vmax[2] - vmin[2]
        normals = [
            [0.0, -1.0, 0.0],  # front
            [1.0, 0.0, 0.0],  # right
            [-1.0, 0.0, 0.0],  # left
            [0.0, 1.0, 0.0],  # back
            [0.0, 0.0, 1.0],  # top
            [0.0, 0.0, -1.0],  # bottom
        ]
        for face in self._indices:
            v1, v2, v3 = (
                self._vertices[face[0]],
                self._vertices[face[1]],
                self._vertices[face[2]],
            )
            # find face normal
            normal = plane_normal(v1, v2, v3)
            # determine which face of the cube
            angles = [vector_angle(normal, n) for n in normals]
            face_dir = angles.index(min(angles))
            if face_dir == 0:
                t1 = (v1[0] - vmin[0]) / width
                s1 = (v1[2] - vmin[2]) / height
                t2 = (v2[0] - vmin[0]) / width
                s2 = (v2[2] - vmin[2]) / height
                t3 = (v3[0] - vmin[0]) / width
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 1:
                t1 = (v1[1] - vmin[1]) / depth
                s1 = (v1[2] - vmin[2]) / height
                t2 = (v2[1] - vmin[1]) / depth
                s2 = (v2[2] - vmin[2]) / height
                t3 = (v3[1] - vmin[1]) / depth
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 2:
                t1 = (vmax[1] - v1[1]) / depth
                s1 = (v1[2] - vmin[2]) / height
                t2 = (vmax[1] - v2[1]) / depth
                s2 = (v2[2] - vmin[2]) / height
                t3 = (vmax[1] - v3[1]) / depth
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 3:
                t1 = (vmax[0] - v1[0]) / width
                s1 = (v1[2] - vmin[2]) / height
                t2 = (vmax[0] - v2[0]) / width
                s2 = (v2[2] - vmin[2]) / height
                t3 = (vmax[0] - v3[0]) / width
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 4:
                t1 = (v1[0] - vmin[0]) / width
                s1 = (v1[1] - vmin[1]) / depth
                t2 = (v2[0] - vmin[0]) / width
                s2 = (v2[1] - vmin[1]) / depth
                t3 = (v3[0] - vmin[0]) / width
                s3 = (v3[1] - vmin[1]) / depth
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 5:
                t1 = (v1[0] - vmin[0]) / width
                s1 = (v1[1] - vmin[1]) / depth
                t2 = (v2[0] - vmin[0]) / width
                s2 = (v2[1] - vmin[1]) / depth
                t3 = (v3[0] - vmin[0]) / width
                s3 = (v3[1] - vmin[1]) / depth
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        self._texcoords = [[t[0] * u, t[1] * v] for t in self._texcoords]

    def scale(self, x: float, y: float, z: float) -&gt; None:
        &#34;&#34;&#34;Scale Mesh by given factors

        This does not create a scale matrix and multiply existing matrix
        with it. Instead, it will scale the vertices by given factors.
        &#34;&#34;&#34;
        self._vertices = list(
            map(lambda v: [v[0] * x, v[1] * y, v[2] * z], self._vertices)
        )
        self.fix_normals()
        self.refresh()

    def add_triangle(
        self,
        vertices: VList,
        normals: Optional[VList] = None,
        texcoords: Optional[VList] = None,
        colors: Optional[VList] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add triangle to Mesh

        Args:
          vertices: Vertices of the triangle. This is required. Ex:
                    `[[0, 0, 0], [2, 0, 0], [1, 1, 0]]`
          normals: Normals of the triangle. _(When left as None, Payton will
                   calculate the surface normal based on vertices and assign
                   it per given vertex.)_
          texcoords: Texture UV coordinates.
          colors: Per vertex colors (optional)
        &#34;&#34;&#34;
        if len(vertices) != 3:
            logging.error(&#34;A triangle must have 3 vertices&#34;)
            return

        if normals is not None and len(normals) != 3:
            logging.error(&#34;There must be one normal per vertex&#34;)
            return

        if texcoords is not None and len(texcoords) != 3:
            logging.error(&#34;There must be one texcoord per vertex&#34;)
            return

        if normals is None:
            v1, v2, v3 = vertices[0], vertices[1], vertices[2]
            normal = plane_normal(v1, v2, v3)
            normals = [normal, normal, normal]
        if texcoords is None:
            texcoords = [[0, 0], [1, 0], [1, 1]]
        if colors:
            for color in colors:
                self._vertex_colors.append(color)

        for v in vertices:
            self._vertices.append(v)

        i = len(self._indices) * 3
        self._indices.append([i, i + 1, i + 2])
        for normal in normals:
            self._normals.append(normal)
        for t in texcoords:
            self._texcoords.append(t)
        self.refresh()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="payton.scene.geometry.mesh.Mesh"><code class="flex name class">
<span>class <span class="ident">Mesh</span></span>
<span>(</span><span>**args)</span>
</code></dt>
<dd>
<section class="desc"><p>Mesh Object</p>
<p>Mesh is almost like the Object except with some extra methods to make
things easier. If you want to have custom geometries/shapes, it is
better to extend <a title="payton.scene.geometry.mesh.Mesh" href="#payton.scene.geometry.mesh.Mesh"><code>Mesh</code></a> instead of
<a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object"><code>Object</code></a>. Because Mesh will give you better
and easier constructing capabilities such as adding triangles on the fly
or sub-division or cutting and so forth. It is a way of designing objects
by code.</p>
<p>Example use case:</p>
<pre><code>import os
from payton.scene import Scene
from payton.scene.geometry import Mesh


scene = Scene()
mesh = Mesh()
mesh.add_triangle(
    [[0, 0, 0], [2, 0, 0], [2, 2, 0]], texcoords=[[0, 0], [1, 0], [1, 1]]
)
mesh.add_triangle(
    [[0, 0, 0], [2, 2, 0], [0, 2, 0]], texcoords=[[0, 0], [1, 1], [0, 1]]
)
texture_file = os.path.join(os.path.dirname(__file__), "cube.png")
mesh.material.texture = texture_file
scene.add_object("mesh", mesh)
scene.run()
</code></pre>
<p>Initialize the basic object properties.</p>
<h2 id="properties">Properties</h2>
<dl>
<dt><strong><code>children</code></strong></dt>
<dd>Children hash for object. Each child object follows parent
object. They take their parent object as origin and their
coordinate system is relative to their parent. This
behaviour resembles stars, planets and their moons.</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material definitions of the object.</dd>
<dt><strong><code>matrix</code></strong></dt>
<dd>Matrix definition of the object. This is a 4x4 Uniform Matrix
but data is set as an array for easier transformations. First
4 decimals are "Left" vector, second 4 are "Direction", third
4 are "Up" and last four decimals are "Position" vectors.</dd>
</dl>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track_motion</code></strong></dt>
<dd>Track object motion (default: false). Object tracking
is time independent. It just saves the object matrix
for every change. Uses matrix position for drawing the
motion path.</dd>
<dt><strong><code>static</code></strong></dt>
<dd>(Default <code>True</code>) Indicates if object geometry is expected
to be changed in the future. If object is not static, then
its' vertex buffer object references and vertex informations
will not be deleted to be used for future reference.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the object (optional, default '') Note that, when
object gets added to a Scene with a name, Scene will assign
that name to the object, overwriting any existing name of the
object.</dd>
<dt><strong><code>visible</code></strong></dt>
<dd>Is this object visible at the scene, default: <code>True</code>. To
hide an object, you can call <code>object.hide()</code> and to show
it again use: <code>object.show()</code></dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Mesh(Object):
    &#34;&#34;&#34;Mesh Object

    Mesh is almost like the Object except with some extra methods to make
    things easier. If you want to have custom geometries/shapes, it is
    better to extend `payton.scene.geometry.mesh.Mesh` instead of
    `payton.scene.geometry.base.Object`. Because Mesh will give you better
    and easier constructing capabilities such as adding triangles on the fly
    or sub-division or cutting and so forth. It is a way of designing objects
    by code.


    Example use case:

        .. include:: ../../../examples/basics/09_mesh.py
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        super().__init__(**args)
        self.static = False

    def clear_triangles(self) -&gt; None:
        &#34;&#34;&#34;Clear all triangles inside the Mesh&#34;&#34;&#34;
        self._vertices = []
        self._indices = []
        self._normals = []
        self._texcoords = []
        self._vertex_colors = []
        self.refresh()

    def fix_normals(self) -&gt; None:
        &#34;&#34;&#34;Try to re-calculate Mesh normals, if your object has already perfect
        normals, do not call this method&#34;&#34;&#34;
        self._normals = [[0, 0, 1.0]] * len(self._vertices)

        for face in self._indices:
            v1, v2, v3 = (
                self._vertices[face[0]],
                self._vertices[face[1]],
                self._vertices[face[2]],
            )
            normal = plane_normal(v1, v2, v3)
            self._normals[face[0]] = normal
            self._normals[face[1]] = normal
            self._normals[face[2]] = normal

    def fix_texcoords(self, u: int = 1, v: int = 1) -&gt; None:
        &#34;&#34;&#34;Try to recalculate mesh texture coordinates by cube projection
        &#34;&#34;&#34;
        self._texcoords = []
        self._calc_bounds()
        bbox = self._bounding_box
        vmin, vmax = bbox[0], bbox[1]
        width = vmax[0] - vmin[0]
        depth = vmax[1] - vmin[1]
        height = vmax[2] - vmin[2]
        normals = [
            [0.0, -1.0, 0.0],  # front
            [1.0, 0.0, 0.0],  # right
            [-1.0, 0.0, 0.0],  # left
            [0.0, 1.0, 0.0],  # back
            [0.0, 0.0, 1.0],  # top
            [0.0, 0.0, -1.0],  # bottom
        ]
        for face in self._indices:
            v1, v2, v3 = (
                self._vertices[face[0]],
                self._vertices[face[1]],
                self._vertices[face[2]],
            )
            # find face normal
            normal = plane_normal(v1, v2, v3)
            # determine which face of the cube
            angles = [vector_angle(normal, n) for n in normals]
            face_dir = angles.index(min(angles))
            if face_dir == 0:
                t1 = (v1[0] - vmin[0]) / width
                s1 = (v1[2] - vmin[2]) / height
                t2 = (v2[0] - vmin[0]) / width
                s2 = (v2[2] - vmin[2]) / height
                t3 = (v3[0] - vmin[0]) / width
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 1:
                t1 = (v1[1] - vmin[1]) / depth
                s1 = (v1[2] - vmin[2]) / height
                t2 = (v2[1] - vmin[1]) / depth
                s2 = (v2[2] - vmin[2]) / height
                t3 = (v3[1] - vmin[1]) / depth
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 2:
                t1 = (vmax[1] - v1[1]) / depth
                s1 = (v1[2] - vmin[2]) / height
                t2 = (vmax[1] - v2[1]) / depth
                s2 = (v2[2] - vmin[2]) / height
                t3 = (vmax[1] - v3[1]) / depth
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 3:
                t1 = (vmax[0] - v1[0]) / width
                s1 = (v1[2] - vmin[2]) / height
                t2 = (vmax[0] - v2[0]) / width
                s2 = (v2[2] - vmin[2]) / height
                t3 = (vmax[0] - v3[0]) / width
                s3 = (v3[2] - vmin[2]) / height
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 4:
                t1 = (v1[0] - vmin[0]) / width
                s1 = (v1[1] - vmin[1]) / depth
                t2 = (v2[0] - vmin[0]) / width
                s2 = (v2[1] - vmin[1]) / depth
                t3 = (v3[0] - vmin[0]) / width
                s3 = (v3[1] - vmin[1]) / depth
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
            if face_dir == 5:
                t1 = (v1[0] - vmin[0]) / width
                s1 = (v1[1] - vmin[1]) / depth
                t2 = (v2[0] - vmin[0]) / width
                s2 = (v2[1] - vmin[1]) / depth
                t3 = (v3[0] - vmin[0]) / width
                s3 = (v3[1] - vmin[1]) / depth
                self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        self._texcoords = [[t[0] * u, t[1] * v] for t in self._texcoords]

    def scale(self, x: float, y: float, z: float) -&gt; None:
        &#34;&#34;&#34;Scale Mesh by given factors

        This does not create a scale matrix and multiply existing matrix
        with it. Instead, it will scale the vertices by given factors.
        &#34;&#34;&#34;
        self._vertices = list(
            map(lambda v: [v[0] * x, v[1] * y, v[2] * z], self._vertices)
        )
        self.fix_normals()
        self.refresh()

    def add_triangle(
        self,
        vertices: VList,
        normals: Optional[VList] = None,
        texcoords: Optional[VList] = None,
        colors: Optional[VList] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add triangle to Mesh

        Args:
          vertices: Vertices of the triangle. This is required. Ex:
                    `[[0, 0, 0], [2, 0, 0], [1, 1, 0]]`
          normals: Normals of the triangle. _(When left as None, Payton will
                   calculate the surface normal based on vertices and assign
                   it per given vertex.)_
          texcoords: Texture UV coordinates.
          colors: Per vertex colors (optional)
        &#34;&#34;&#34;
        if len(vertices) != 3:
            logging.error(&#34;A triangle must have 3 vertices&#34;)
            return

        if normals is not None and len(normals) != 3:
            logging.error(&#34;There must be one normal per vertex&#34;)
            return

        if texcoords is not None and len(texcoords) != 3:
            logging.error(&#34;There must be one texcoord per vertex&#34;)
            return

        if normals is None:
            v1, v2, v3 = vertices[0], vertices[1], vertices[2]
            normal = plane_normal(v1, v2, v3)
            normals = [normal, normal, normal]
        if texcoords is None:
            texcoords = [[0, 0], [1, 0], [1, 1]]
        if colors:
            for color in colors:
                self._vertex_colors.append(color)

        for v in vertices:
            self._vertices.append(v)

        i = len(self._indices) * 3
        self._indices.append([i, i + 1, i + 2])
        for normal in normals:
            self._normals.append(normal)
        for t in texcoords:
            self._texcoords.append(t)
        self.refresh()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.cylinder.Cylinder" href="cylinder.html#payton.scene.geometry.cylinder.Cylinder">Cylinder</a></li>
<li><a title="payton.scene.geometry.cube.Cube" href="cube.html#payton.scene.geometry.cube.Cube">Cube</a></li>
<li><a title="payton.scene.geometry.plane.Plane" href="plane.html#payton.scene.geometry.plane.Plane">Plane</a></li>
<li><a title="payton.scene.geometry.plane.MatrixPlane" href="plane.html#payton.scene.geometry.plane.MatrixPlane">MatrixPlane</a></li>
<li><a title="payton.scene.geometry.sphere.Sphere" href="sphere.html#payton.scene.geometry.sphere.Sphere">Sphere</a></li>
<li><a title="payton.scene.gui.Shape2D" href="../gui.html#payton.scene.gui.Shape2D">Shape2D</a></li>
<li><a title="payton.scene.wavefront.Wavefront" href="../wavefront.html#payton.scene.wavefront.Wavefront">Wavefront</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.mesh.Mesh.add_triangle"><code class="name flex">
<span>def <span class="ident">add_triangle</span></span>(<span>self, vertices, normals=None, texcoords=None, colors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add triangle to Mesh</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertices of the triangle. This is required. Ex:
<code>[[0, 0, 0], [2, 0, 0], [1, 1, 0]]</code></dd>
<dt><strong><code>normals</code></strong></dt>
<dd>Normals of the triangle. <em>(When left as None, Payton will
calculate the surface normal based on vertices and assign
it per given vertex.)</em></dd>
<dt><strong><code>texcoords</code></strong></dt>
<dd>Texture UV coordinates.</dd>
<dt><strong><code>colors</code></strong></dt>
<dd>Per vertex colors (optional)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_triangle(
    self,
    vertices: VList,
    normals: Optional[VList] = None,
    texcoords: Optional[VList] = None,
    colors: Optional[VList] = None,
) -&gt; None:
    &#34;&#34;&#34;Add triangle to Mesh

    Args:
      vertices: Vertices of the triangle. This is required. Ex:
                `[[0, 0, 0], [2, 0, 0], [1, 1, 0]]`
      normals: Normals of the triangle. _(When left as None, Payton will
               calculate the surface normal based on vertices and assign
               it per given vertex.)_
      texcoords: Texture UV coordinates.
      colors: Per vertex colors (optional)
    &#34;&#34;&#34;
    if len(vertices) != 3:
        logging.error(&#34;A triangle must have 3 vertices&#34;)
        return

    if normals is not None and len(normals) != 3:
        logging.error(&#34;There must be one normal per vertex&#34;)
        return

    if texcoords is not None and len(texcoords) != 3:
        logging.error(&#34;There must be one texcoord per vertex&#34;)
        return

    if normals is None:
        v1, v2, v3 = vertices[0], vertices[1], vertices[2]
        normal = plane_normal(v1, v2, v3)
        normals = [normal, normal, normal]
    if texcoords is None:
        texcoords = [[0, 0], [1, 0], [1, 1]]
    if colors:
        for color in colors:
            self._vertex_colors.append(color)

    for v in vertices:
        self._vertices.append(v)

    i = len(self._indices) * 3
    self._indices.append([i, i + 1, i + 2])
    for normal in normals:
        self._normals.append(normal)
    for t in texcoords:
        self._texcoords.append(t)
    self.refresh()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.mesh.Mesh.clear_triangles"><code class="name flex">
<span>def <span class="ident">clear_triangles</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Clear all triangles inside the Mesh</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def clear_triangles(self) -&gt; None:
    &#34;&#34;&#34;Clear all triangles inside the Mesh&#34;&#34;&#34;
    self._vertices = []
    self._indices = []
    self._normals = []
    self._texcoords = []
    self._vertex_colors = []
    self.refresh()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.mesh.Mesh.fix_normals"><code class="name flex">
<span>def <span class="ident">fix_normals</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Try to re-calculate Mesh normals, if your object has already perfect
normals, do not call this method</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fix_normals(self) -&gt; None:
    &#34;&#34;&#34;Try to re-calculate Mesh normals, if your object has already perfect
    normals, do not call this method&#34;&#34;&#34;
    self._normals = [[0, 0, 1.0]] * len(self._vertices)

    for face in self._indices:
        v1, v2, v3 = (
            self._vertices[face[0]],
            self._vertices[face[1]],
            self._vertices[face[2]],
        )
        normal = plane_normal(v1, v2, v3)
        self._normals[face[0]] = normal
        self._normals[face[1]] = normal
        self._normals[face[2]] = normal</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.mesh.Mesh.fix_texcoords"><code class="name flex">
<span>def <span class="ident">fix_texcoords</span></span>(<span>self, u=1, v=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Try to recalculate mesh texture coordinates by cube projection</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fix_texcoords(self, u: int = 1, v: int = 1) -&gt; None:
    &#34;&#34;&#34;Try to recalculate mesh texture coordinates by cube projection
    &#34;&#34;&#34;
    self._texcoords = []
    self._calc_bounds()
    bbox = self._bounding_box
    vmin, vmax = bbox[0], bbox[1]
    width = vmax[0] - vmin[0]
    depth = vmax[1] - vmin[1]
    height = vmax[2] - vmin[2]
    normals = [
        [0.0, -1.0, 0.0],  # front
        [1.0, 0.0, 0.0],  # right
        [-1.0, 0.0, 0.0],  # left
        [0.0, 1.0, 0.0],  # back
        [0.0, 0.0, 1.0],  # top
        [0.0, 0.0, -1.0],  # bottom
    ]
    for face in self._indices:
        v1, v2, v3 = (
            self._vertices[face[0]],
            self._vertices[face[1]],
            self._vertices[face[2]],
        )
        # find face normal
        normal = plane_normal(v1, v2, v3)
        # determine which face of the cube
        angles = [vector_angle(normal, n) for n in normals]
        face_dir = angles.index(min(angles))
        if face_dir == 0:
            t1 = (v1[0] - vmin[0]) / width
            s1 = (v1[2] - vmin[2]) / height
            t2 = (v2[0] - vmin[0]) / width
            s2 = (v2[2] - vmin[2]) / height
            t3 = (v3[0] - vmin[0]) / width
            s3 = (v3[2] - vmin[2]) / height
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        if face_dir == 1:
            t1 = (v1[1] - vmin[1]) / depth
            s1 = (v1[2] - vmin[2]) / height
            t2 = (v2[1] - vmin[1]) / depth
            s2 = (v2[2] - vmin[2]) / height
            t3 = (v3[1] - vmin[1]) / depth
            s3 = (v3[2] - vmin[2]) / height
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        if face_dir == 2:
            t1 = (vmax[1] - v1[1]) / depth
            s1 = (v1[2] - vmin[2]) / height
            t2 = (vmax[1] - v2[1]) / depth
            s2 = (v2[2] - vmin[2]) / height
            t3 = (vmax[1] - v3[1]) / depth
            s3 = (v3[2] - vmin[2]) / height
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        if face_dir == 3:
            t1 = (vmax[0] - v1[0]) / width
            s1 = (v1[2] - vmin[2]) / height
            t2 = (vmax[0] - v2[0]) / width
            s2 = (v2[2] - vmin[2]) / height
            t3 = (vmax[0] - v3[0]) / width
            s3 = (v3[2] - vmin[2]) / height
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        if face_dir == 4:
            t1 = (v1[0] - vmin[0]) / width
            s1 = (v1[1] - vmin[1]) / depth
            t2 = (v2[0] - vmin[0]) / width
            s2 = (v2[1] - vmin[1]) / depth
            t3 = (v3[0] - vmin[0]) / width
            s3 = (v3[1] - vmin[1]) / depth
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
        if face_dir == 5:
            t1 = (v1[0] - vmin[0]) / width
            s1 = (v1[1] - vmin[1]) / depth
            t2 = (v2[0] - vmin[0]) / width
            s2 = (v2[1] - vmin[1]) / depth
            t3 = (v3[0] - vmin[0]) / width
            s3 = (v3[1] - vmin[1]) / depth
            self._texcoords.extend([[t1, s1], [t2, s2], [t3, s3]])
    self._texcoords = [[t[0] * u, t[1] * v] for t in self._texcoords]</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.mesh.Mesh.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<section class="desc"><p>Scale Mesh by given factors</p>
<p>This does not create a scale matrix and multiply existing matrix
with it. Instead, it will scale the vertices by given factors.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def scale(self, x: float, y: float, z: float) -&gt; None:
    &#34;&#34;&#34;Scale Mesh by given factors

    This does not create a scale matrix and multiply existing matrix
    with it. Instead, it will scale the vertices by given factors.
    &#34;&#34;&#34;
    self._vertices = list(
        map(lambda v: [v[0] * x, v[1] * y, v[2] * z], self._vertices)
    )
    self.fix_normals()
    self.refresh()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.base.Object" href="base.html#payton.scene.geometry.base.Object">Object</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.base.Object.absolute_vertices" href="base.html#payton.scene.geometry.base.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.add_child" href="base.html#payton.scene.geometry.base.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.bounding_radius" href="base.html#payton.scene.geometry.base.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.build" href="base.html#payton.scene.geometry.base.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.destroy" href="base.html#payton.scene.geometry.base.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direct_to" href="base.html#payton.scene.geometry.base.Object.direct_to">direct_to</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.direction" href="base.html#payton.scene.geometry.base.Object.direction">direction</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.forward" href="base.html#payton.scene.geometry.base.Object.forward">forward</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.has_vao" href="base.html#payton.scene.geometry.base.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.position" href="base.html#payton.scene.geometry.base.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.refresh" href="base.html#payton.scene.geometry.base.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.render" href="base.html#payton.scene.geometry.base.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_x" href="base.html#payton.scene.geometry.base.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_y" href="base.html#payton.scene.geometry.base.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.rotate_around_z" href="base.html#payton.scene.geometry.base.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.select" href="base.html#payton.scene.geometry.base.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.step_back" href="base.html#payton.scene.geometry.base.Object.step_back">step_back</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.to_absolute" href="base.html#payton.scene.geometry.base.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.toggle_wireframe" href="base.html#payton.scene.geometry.base.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.track" href="base.html#payton.scene.geometry.base.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.update_matrix" href="base.html#payton.scene.geometry.base.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.base.Object.visible" href="base.html#payton.scene.geometry.base.Object.visible">visible</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="payton.scene.geometry" href="index.html">payton.scene.geometry</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="payton.scene.geometry.mesh.Mesh" href="#payton.scene.geometry.mesh.Mesh">Mesh</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.mesh.Mesh.add_triangle" href="#payton.scene.geometry.mesh.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.clear_triangles" href="#payton.scene.geometry.mesh.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_normals" href="#payton.scene.geometry.mesh.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.fix_texcoords" href="#payton.scene.geometry.mesh.Mesh.fix_texcoords">fix_texcoords</a></code></li>
<li><code><a title="payton.scene.geometry.mesh.Mesh.scale" href="#payton.scene.geometry.mesh.Mesh.scale">scale</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>