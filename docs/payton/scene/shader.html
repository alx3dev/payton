<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>payton.scene.shader API documentation</title>
<meta name="description" content="Payton Shader â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{margin:40px auto;max-width:1000px;display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>payton.scene.shader</code></h1>
</header>
<section id="section-intro">
<p>Payton Shader</p>
<p>Payton Shader is an OpenGL 3.3 Compatible GLSL (330) module. Basic principle
is to be be able to compile vertex and fragment shaders and hold basic
ready-to-use shaders.</p>
<p>A usual user should not be aware of this shading system. Basic shaders defined
should be enough for simple simulations. Our intention is not to create a
graphics library. We want to create a simulation platform and let developers
to focus on mathematics rather than OpenGL Stuff.</p>
<p>Also, keep in mind that, this is NOT a generic-purpose shader class which can
be used at common OpenGL apps. This shader class is just enough of what is
essential to Payton Library. That is all.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;Payton Shader

Payton Shader is an OpenGL 3.3 Compatible GLSL (330) module. Basic principle
is to be be able to compile vertex and fragment shaders and hold basic
ready-to-use shaders.

A usual user should not be aware of this shading system. Basic shaders defined
should be enough for simple simulations. Our intention is not to create a
graphics library. We want to create a simulation platform and let developers
to focus on mathematics rather than OpenGL Stuff.

Also, keep in mind that, this is NOT a generic-purpose shader class which can
be used at common OpenGL apps. This shader class is just enough of what is
essential to Payton Library. That is all.

&#34;&#34;&#34;

import ctypes
import numpy as np  # type: ignore
import logging

from typing import Any, List, Dict, Optional

from OpenGL.GL import (
    GL_VERTEX_SHADER,
    GL_FRAGMENT_SHADER,
    glEnable,
    glDisable,
    GL_PROGRAM_POINT_SIZE,
    glGetUniformLocation,
    glUseProgram,
    GL_TRUE,
    GL_FALSE,
    glUniformMatrix4fv,
    glUniform1i,
    glUniform1f,
    glUniform3fv,
    glUniform4fv,
)

from OpenGL.GL import shaders

default_fragment_shader = &#34;&#34;&#34;
#version 330 core
out vec4 FragColor;

in vec3 l_normal;
in vec3 l_fragpos;

in vec2 tex_coords;
in vec3 frag_color;

uniform vec3 light_pos[100]; // assume 100 lights max.
uniform vec3 light_color[100];
uniform int LIGHT_COUNT;

uniform vec3 object_color;
uniform int material_mode;
uniform float opacity;

uniform sampler2D tex_unit;


void main()
{
    if (material_mode == 0) {
        // lightless material with color
        FragColor = vec4(object_color, opacity);
    }
    if (material_mode == 1) {
        // lightless material with texture
        FragColor = texture(tex_unit, tex_coords);
    }
    if (material_mode == 2 || material_mode == 3) {
        // light material
        FragColor = vec4(0, 0, 0, 0);
        // ambient
        float ambientStrength = 0.2;

        for (int i = 0; i &lt; LIGHT_COUNT; i++) {
            vec3 ambient = ambientStrength * light_color[i];

            // diffuse
            vec3 norm = normalize(l_normal);

            vec3 lightDir = normalize(light_pos[i] - l_fragpos);
            float diff = max(dot(norm, lightDir), 0.0);
            vec3 diffuse = diff * light_color[i];
            if (material_mode == 2) {
                // color material
                FragColor += vec4((ambient + diffuse) * object_color, opacity);
            }else{
                // texture material
                FragColor += (vec4(ambient + diffuse, 1.0) *
                              texture(tex_unit, tex_coords));
            }
        }
    }
    if (material_mode == 4) {
        // Lightless per vertex color
        FragColor = vec4(frag_color, opacity);
    }
}&#34;&#34;&#34;  # type: str


default_vertex_shader = &#34;&#34;&#34;
#version 330 core
layout ( location = 0 ) in vec3 position;
layout ( location = 1 ) in vec3 normal;
layout ( location = 2 ) in vec2 texCoords;
layout ( location = 3 ) in vec3 colors; // optional

out vec2 tex_coords;
out vec3 frag_color;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform int view_mode;

out vec3 l_fragpos;
out vec3 l_normal;

void main()
{
    l_fragpos = vec3(model * vec4(position, 1.0));
    l_normal = mat3(transpose(inverse(model))) * normal;

    if (view_mode == 0) {
        gl_Position = projection * view * model * vec4(position, 1.0f);
    }
    if (view_mode == 1) {
        gl_Position = (projection * (vec4(position, 1.0f)
                        + vec4(model[3].xyz, 0.0f)));
    }
    gl_PointSize = 2.0;

    tex_coords = texCoords;
    frag_color = colors;
}
&#34;&#34;&#34;  # type: str


background_vertex_shader = &#34;&#34;&#34;
#version 330 core
out vec2 v_uv;

void main()
{
  // uint idx = gl_VertexID;
  gl_Position = (vec4( gl_VertexID &amp; 1, gl_VertexID &gt;&gt; 1, 0.0, 0.5 )
                 * 4.0 - 1.0);
  v_uv = vec2( gl_Position.xy * 0.5 + 0.5 );
}
&#34;&#34;&#34;  # type: str

background_fragment_shader = &#34;&#34;&#34;
#version 330 core
uniform vec4 top_color;
uniform vec4 bot_color;
in vec2 v_uv;

out vec4 frag_color;
void main()
{
  frag_color = bot_color * (1 - v_uv.y) + top_color * v_uv.y;
}
&#34;&#34;&#34;  # type: str


class Shader(object):
    &#34;&#34;&#34;Payton shader class. Creates shaders / programs

    For better performance, Shader aims to reduce the number of
    `glGetUniformlocation` function calls. For this purpose, `__init__` and
    `build` functions accept a list of variable names as `variables` argument.

    If variable not found in `self.variables` then the system will try to
    locate the variable location and store it in `self.variables` for
    future reference.

    This way, Shader goes through this list of variables after compiling the
    shader program and stores their locations in memory for future use.

    If you provide the list of variable names in build function call then
    it will overwrite the existing list.
    &#34;&#34;&#34;

    NO_LIGHT_COLOR = 0  # type: int
    NO_LIGHT_TEXTURE = 1  # type: int
    LIGHT_COLOR = 2  # type: int
    LIGHT_TEXTURE = 3  # type: int
    PER_VERTEX_COLOR = 4  # type:int
    HUD = 5  # type: int

    def __init__(self, **args: Any):
        &#34;&#34;&#34;Initialize Shader.

        Args:
          fragment: Fragment shader code
          vertex: Vertex shader code
          variables: List of in/out/uniform variable names.
        &#34;&#34;&#34;
        global default_fragment_shader, default_vertex_shader
        self.fragment_shader_source: str = args.get(
            &#34;fragment&#34;, default_fragment_shader
        )
        self.vertex_shader_source: str = args.get(
            &#34;vertex&#34;, default_vertex_shader
        )

        self.variables: List[str] = args.get(&#34;variables&#34;, [])
        self._stack: Dict[str, int] = {}  # Variable stack.
        self._mode: int = self.NO_LIGHT_COLOR  # Lightless color material

        self.program: int = -1

    def build(self, variables: Optional[List[str]] = None) -&gt; int:
        &#34;&#34;&#34;Build GLSL Shader
        Compile shaders and compile glsl program
        Args:
          variables: List of in/out/uniform variable names.
        Return:
            self.program
        &#34;&#34;&#34;
        vertex_shader = shaders.compileShader(
            self.vertex_shader_source, GL_VERTEX_SHADER
        )
        fragment_shader = shaders.compileShader(
            self.fragment_shader_source, GL_FRAGMENT_SHADER
        )
        self.program = shaders.compileProgram(vertex_shader, fragment_shader)
        if variables:
            self.variables = variables

        for v in self.variables:
            location = glGetUniformLocation(self.program, v)
            self._stack[v] = location

        return self.program

    def use(self) -&gt; bool:
        &#34;&#34;&#34;Use GLSL Program.
        This method should be called before setting any variables or rendering
        any entities
        &#34;&#34;&#34;
        if self.program == -1:
            logging.error(&#34;Shader not compiled&#34;)
            return False
        glUseProgram(self.program)
        glEnable(GL_PROGRAM_POINT_SIZE)
        return True

    def end(self) -&gt; None:
        &#34;&#34;&#34;Set the active GLSL program to 0
        &#34;&#34;&#34;
        glUseProgram(0)
        glDisable(GL_PROGRAM_POINT_SIZE)

    def set_matrix4x4_np(
        self, variable: str, value: np.ndarray, transpose: bool = False
    ) -&gt; bool:
        &#34;&#34;&#34;Set 4x4 Numpy matrix value

        Some elements like Observer and Light can pass their matrices directly
        as numpy array to reduce number of object conversions. This is the
        ideal way if possible.

        Args:
          variable: Variable name to set
          value: Matrix to set. (Numpy matrix)
          transpose: Transpose matrix.
        &#34;&#34;&#34;
        g_transpose = GL_TRUE if transpose else GL_FALSE
        location = self.get_location(variable)
        if location == -1:
            return False

        glUniformMatrix4fv(
            location,
            1,
            g_transpose,
            np.asfortranarray(value, dtype=np.float32),
        )
        return True

    def get_location(self, variable: str) -&gt; int:
        &#34;&#34;&#34;Get location of a given variable within the shader&#34;&#34;&#34;
        if variable in self._stack:
            return self._stack[variable]
        location = glGetUniformLocation(self.program, variable)
        if location == -1:
            logging.error(f&#34;Variable not found in program [{variable}]&#34;)
        self._stack[variable] = location
        return location

    def set_matrix4x4(
        self, variable: str, value: List[List[float]], transpose: bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Set 4x4 Matrix value

        This method will simply convert `value` into numpy array and call
        `payton.scene.shader.Shader.set_matrix4x4_np` method.

        Args:
          variable: Variable name to set
          value: Matrix to set. (Numpy matrix)
          transpose: Transpose matrix.
        &#34;&#34;&#34;
        self.set_matrix4x4_np(variable, np.array(value, np.float32), transpose)

    def set_vector3_array_np(
        self, variable: str, value: np.ndarray, count: int
    ) -&gt; bool:
        &#34;&#34;&#34;Set array of vec3 as numpy array value&#34;&#34;&#34;
        value = value.flatten()
        location = self.get_location(variable)
        if location == -1:
            return False
        glUniform3fv(location, count, value)
        return True

    def set_vector3_np(self, variable: str, value: np.ndarray) -&gt; bool:
        &#34;&#34;&#34;Set Vector 3 as numpy array value

        Some elements like Light or pre-set materials can pass their
        vertices directly as numpy array to reduce number of object
        conversions.

        Args:
          variable: Variable name to set
          value: Vector 3 to set. (Numpy array with 3 elemenets)
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location == -1:
            return False
        glUniform3fv(location, 1, value)
        return True

    def set_vector4_np(self, variable: str, value: np.ndarray) -&gt; bool:
        &#34;&#34;&#34;Set Vector 4 as numpy array value

        Some elements like Light or pre-set materials can pass their vertices
        directly as numpy array to reduce number of object conversions.

        Args:
          variable: Variable name to set
          value: Vector 4 to set. (Numpy array with 4 elemenets)
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location == -1:
            return False
        glUniform4fv(location, 1, value)
        return True

    def set_vector3(self, variable: str, value: List[float]) -&gt; None:
        &#34;&#34;&#34;Set Vector 3 as array value

        This method will simply convert `value` into numpy array and call
        `payton.scene.shader.Shader.set_vector3_np` method.

        Args:
          variable: Variable name to set
          value: Vector 3 to set. (Numpy array with 3 elemenets)
        &#34;&#34;&#34;
        self.set_vector3_np(variable, np.array(value, dtype=np.float32))

    def set_int(self, variable: str, value: int) -&gt; bool:
        &#34;&#34;&#34;Set Integer value

        Args:
          variable: Variable name to set
          value: Integer value to set
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location == -1:
            return False

        glUniform1i(location, ctypes.c_int(value))
        return True

    def set_float(self, variable: str, value: float) -&gt; bool:
        &#34;&#34;&#34;Set Float value

        Args:
          variable: Variable name to set
          value: Floaf value to set
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location == -1:
            return False

        glUniform1f(location, ctypes.c_float(value))
        return True</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="payton.scene.shader.Shader"><code class="flex name class">
<span>class <span class="ident">Shader</span></span>
<span>(</span><span>**args)</span>
</code></dt>
<dd>
<section class="desc"><p>Payton shader class. Creates shaders / programs</p>
<p>For better performance, Shader aims to reduce the number of
<code>glGetUniformlocation</code> function calls. For this purpose, <code>__init__</code> and
<code>build</code> functions accept a list of variable names as <code>variables</code> argument.</p>
<p>If variable not found in <code>self.variables</code> then the system will try to
locate the variable location and store it in <code>self.variables</code> for
future reference.</p>
<p>This way, Shader goes through this list of variables after compiling the
shader program and stores their locations in memory for future use.</p>
<p>If you provide the list of variable names in build function call then
it will overwrite the existing list.</p>
<p>Initialize Shader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fragment</code></strong></dt>
<dd>Fragment shader code</dd>
<dt><strong><code>vertex</code></strong></dt>
<dd>Vertex shader code</dd>
<dt><strong><code>variables</code></strong></dt>
<dd>List of in/out/uniform variable names.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Shader(object):
    &#34;&#34;&#34;Payton shader class. Creates shaders / programs

    For better performance, Shader aims to reduce the number of
    `glGetUniformlocation` function calls. For this purpose, `__init__` and
    `build` functions accept a list of variable names as `variables` argument.

    If variable not found in `self.variables` then the system will try to
    locate the variable location and store it in `self.variables` for
    future reference.

    This way, Shader goes through this list of variables after compiling the
    shader program and stores their locations in memory for future use.

    If you provide the list of variable names in build function call then
    it will overwrite the existing list.
    &#34;&#34;&#34;

    NO_LIGHT_COLOR = 0  # type: int
    NO_LIGHT_TEXTURE = 1  # type: int
    LIGHT_COLOR = 2  # type: int
    LIGHT_TEXTURE = 3  # type: int
    PER_VERTEX_COLOR = 4  # type:int
    HUD = 5  # type: int

    def __init__(self, **args: Any):
        &#34;&#34;&#34;Initialize Shader.

        Args:
          fragment: Fragment shader code
          vertex: Vertex shader code
          variables: List of in/out/uniform variable names.
        &#34;&#34;&#34;
        global default_fragment_shader, default_vertex_shader
        self.fragment_shader_source: str = args.get(
            &#34;fragment&#34;, default_fragment_shader
        )
        self.vertex_shader_source: str = args.get(
            &#34;vertex&#34;, default_vertex_shader
        )

        self.variables: List[str] = args.get(&#34;variables&#34;, [])
        self._stack: Dict[str, int] = {}  # Variable stack.
        self._mode: int = self.NO_LIGHT_COLOR  # Lightless color material

        self.program: int = -1

    def build(self, variables: Optional[List[str]] = None) -&gt; int:
        &#34;&#34;&#34;Build GLSL Shader
        Compile shaders and compile glsl program
        Args:
          variables: List of in/out/uniform variable names.
        Return:
            self.program
        &#34;&#34;&#34;
        vertex_shader = shaders.compileShader(
            self.vertex_shader_source, GL_VERTEX_SHADER
        )
        fragment_shader = shaders.compileShader(
            self.fragment_shader_source, GL_FRAGMENT_SHADER
        )
        self.program = shaders.compileProgram(vertex_shader, fragment_shader)
        if variables:
            self.variables = variables

        for v in self.variables:
            location = glGetUniformLocation(self.program, v)
            self._stack[v] = location

        return self.program

    def use(self) -&gt; bool:
        &#34;&#34;&#34;Use GLSL Program.
        This method should be called before setting any variables or rendering
        any entities
        &#34;&#34;&#34;
        if self.program == -1:
            logging.error(&#34;Shader not compiled&#34;)
            return False
        glUseProgram(self.program)
        glEnable(GL_PROGRAM_POINT_SIZE)
        return True

    def end(self) -&gt; None:
        &#34;&#34;&#34;Set the active GLSL program to 0
        &#34;&#34;&#34;
        glUseProgram(0)
        glDisable(GL_PROGRAM_POINT_SIZE)

    def set_matrix4x4_np(
        self, variable: str, value: np.ndarray, transpose: bool = False
    ) -&gt; bool:
        &#34;&#34;&#34;Set 4x4 Numpy matrix value

        Some elements like Observer and Light can pass their matrices directly
        as numpy array to reduce number of object conversions. This is the
        ideal way if possible.

        Args:
          variable: Variable name to set
          value: Matrix to set. (Numpy matrix)
          transpose: Transpose matrix.
        &#34;&#34;&#34;
        g_transpose = GL_TRUE if transpose else GL_FALSE
        location = self.get_location(variable)
        if location == -1:
            return False

        glUniformMatrix4fv(
            location,
            1,
            g_transpose,
            np.asfortranarray(value, dtype=np.float32),
        )
        return True

    def get_location(self, variable: str) -&gt; int:
        &#34;&#34;&#34;Get location of a given variable within the shader&#34;&#34;&#34;
        if variable in self._stack:
            return self._stack[variable]
        location = glGetUniformLocation(self.program, variable)
        if location == -1:
            logging.error(f&#34;Variable not found in program [{variable}]&#34;)
        self._stack[variable] = location
        return location

    def set_matrix4x4(
        self, variable: str, value: List[List[float]], transpose: bool = False
    ) -&gt; None:
        &#34;&#34;&#34;Set 4x4 Matrix value

        This method will simply convert `value` into numpy array and call
        `payton.scene.shader.Shader.set_matrix4x4_np` method.

        Args:
          variable: Variable name to set
          value: Matrix to set. (Numpy matrix)
          transpose: Transpose matrix.
        &#34;&#34;&#34;
        self.set_matrix4x4_np(variable, np.array(value, np.float32), transpose)

    def set_vector3_array_np(
        self, variable: str, value: np.ndarray, count: int
    ) -&gt; bool:
        &#34;&#34;&#34;Set array of vec3 as numpy array value&#34;&#34;&#34;
        value = value.flatten()
        location = self.get_location(variable)
        if location == -1:
            return False
        glUniform3fv(location, count, value)
        return True

    def set_vector3_np(self, variable: str, value: np.ndarray) -&gt; bool:
        &#34;&#34;&#34;Set Vector 3 as numpy array value

        Some elements like Light or pre-set materials can pass their
        vertices directly as numpy array to reduce number of object
        conversions.

        Args:
          variable: Variable name to set
          value: Vector 3 to set. (Numpy array with 3 elemenets)
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location == -1:
            return False
        glUniform3fv(location, 1, value)
        return True

    def set_vector4_np(self, variable: str, value: np.ndarray) -&gt; bool:
        &#34;&#34;&#34;Set Vector 4 as numpy array value

        Some elements like Light or pre-set materials can pass their vertices
        directly as numpy array to reduce number of object conversions.

        Args:
          variable: Variable name to set
          value: Vector 4 to set. (Numpy array with 4 elemenets)
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location == -1:
            return False
        glUniform4fv(location, 1, value)
        return True

    def set_vector3(self, variable: str, value: List[float]) -&gt; None:
        &#34;&#34;&#34;Set Vector 3 as array value

        This method will simply convert `value` into numpy array and call
        `payton.scene.shader.Shader.set_vector3_np` method.

        Args:
          variable: Variable name to set
          value: Vector 3 to set. (Numpy array with 3 elemenets)
        &#34;&#34;&#34;
        self.set_vector3_np(variable, np.array(value, dtype=np.float32))

    def set_int(self, variable: str, value: int) -&gt; bool:
        &#34;&#34;&#34;Set Integer value

        Args:
          variable: Variable name to set
          value: Integer value to set
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location == -1:
            return False

        glUniform1i(location, ctypes.c_int(value))
        return True

    def set_float(self, variable: str, value: float) -&gt; bool:
        &#34;&#34;&#34;Set Float value

        Args:
          variable: Variable name to set
          value: Floaf value to set
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location == -1:
            return False

        glUniform1f(location, ctypes.c_float(value))
        return True</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="payton.scene.shader.Shader.HUD"><code class="name">var <span class="ident">HUD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="payton.scene.shader.Shader.LIGHT_COLOR"><code class="name">var <span class="ident">LIGHT_COLOR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="payton.scene.shader.Shader.LIGHT_TEXTURE"><code class="name">var <span class="ident">LIGHT_TEXTURE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="payton.scene.shader.Shader.NO_LIGHT_COLOR"><code class="name">var <span class="ident">NO_LIGHT_COLOR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="payton.scene.shader.Shader.NO_LIGHT_TEXTURE"><code class="name">var <span class="ident">NO_LIGHT_TEXTURE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="payton.scene.shader.Shader.PER_VERTEX_COLOR"><code class="name">var <span class="ident">PER_VERTEX_COLOR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.shader.Shader.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, variables=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Build GLSL Shader
Compile shaders and compile glsl program</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variables</code></strong></dt>
<dd>List of in/out/uniform variable names.</dd>
</dl>
<h2 id="return">Return</h2>
<p>self.program</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build(self, variables: Optional[List[str]] = None) -&gt; int:
    &#34;&#34;&#34;Build GLSL Shader
    Compile shaders and compile glsl program
    Args:
      variables: List of in/out/uniform variable names.
    Return:
        self.program
    &#34;&#34;&#34;
    vertex_shader = shaders.compileShader(
        self.vertex_shader_source, GL_VERTEX_SHADER
    )
    fragment_shader = shaders.compileShader(
        self.fragment_shader_source, GL_FRAGMENT_SHADER
    )
    self.program = shaders.compileProgram(vertex_shader, fragment_shader)
    if variables:
        self.variables = variables

    for v in self.variables:
        location = glGetUniformLocation(self.program, v)
        self._stack[v] = location

    return self.program</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the active GLSL program to 0</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def end(self) -&gt; None:
    &#34;&#34;&#34;Set the active GLSL program to 0
    &#34;&#34;&#34;
    glUseProgram(0)
    glDisable(GL_PROGRAM_POINT_SIZE)</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.get_location"><code class="name flex">
<span>def <span class="ident">get_location</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<section class="desc"><p>Get location of a given variable within the shader</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_location(self, variable: str) -&gt; int:
    &#34;&#34;&#34;Get location of a given variable within the shader&#34;&#34;&#34;
    if variable in self._stack:
        return self._stack[variable]
    location = glGetUniformLocation(self.program, variable)
    if location == -1:
        logging.error(f&#34;Variable not found in program [{variable}]&#34;)
    self._stack[variable] = location
    return location</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_float"><code class="name flex">
<span>def <span class="ident">set_float</span></span>(<span>self, variable, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Set Float value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Floaf value to set</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_float(self, variable: str, value: float) -&gt; bool:
    &#34;&#34;&#34;Set Float value

    Args:
      variable: Variable name to set
      value: Floaf value to set
    &#34;&#34;&#34;
    location = self.get_location(variable)
    if location == -1:
        return False

    glUniform1f(location, ctypes.c_float(value))
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_int"><code class="name flex">
<span>def <span class="ident">set_int</span></span>(<span>self, variable, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Set Integer value</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Integer value to set</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_int(self, variable: str, value: int) -&gt; bool:
    &#34;&#34;&#34;Set Integer value

    Args:
      variable: Variable name to set
      value: Integer value to set
    &#34;&#34;&#34;
    location = self.get_location(variable)
    if location == -1:
        return False

    glUniform1i(location, ctypes.c_int(value))
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_matrix4x4"><code class="name flex">
<span>def <span class="ident">set_matrix4x4</span></span>(<span>self, variable, value, transpose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Set 4x4 Matrix value</p>
<p>This method will simply convert <code>value</code> into numpy array and call
<a title="payton.scene.shader.Shader.set_matrix4x4_np" href="#payton.scene.shader.Shader.set_matrix4x4_np"><code>Shader.set_matrix4x4_np()</code></a> method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Matrix to set. (Numpy matrix)</dd>
<dt><strong><code>transpose</code></strong></dt>
<dd>Transpose matrix.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_matrix4x4(
    self, variable: str, value: List[List[float]], transpose: bool = False
) -&gt; None:
    &#34;&#34;&#34;Set 4x4 Matrix value

    This method will simply convert `value` into numpy array and call
    `payton.scene.shader.Shader.set_matrix4x4_np` method.

    Args:
      variable: Variable name to set
      value: Matrix to set. (Numpy matrix)
      transpose: Transpose matrix.
    &#34;&#34;&#34;
    self.set_matrix4x4_np(variable, np.array(value, np.float32), transpose)</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_matrix4x4_np"><code class="name flex">
<span>def <span class="ident">set_matrix4x4_np</span></span>(<span>self, variable, value, transpose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Set 4x4 Numpy matrix value</p>
<p>Some elements like Observer and Light can pass their matrices directly
as numpy array to reduce number of object conversions. This is the
ideal way if possible.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Matrix to set. (Numpy matrix)</dd>
<dt><strong><code>transpose</code></strong></dt>
<dd>Transpose matrix.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_matrix4x4_np(
    self, variable: str, value: np.ndarray, transpose: bool = False
) -&gt; bool:
    &#34;&#34;&#34;Set 4x4 Numpy matrix value

    Some elements like Observer and Light can pass their matrices directly
    as numpy array to reduce number of object conversions. This is the
    ideal way if possible.

    Args:
      variable: Variable name to set
      value: Matrix to set. (Numpy matrix)
      transpose: Transpose matrix.
    &#34;&#34;&#34;
    g_transpose = GL_TRUE if transpose else GL_FALSE
    location = self.get_location(variable)
    if location == -1:
        return False

    glUniformMatrix4fv(
        location,
        1,
        g_transpose,
        np.asfortranarray(value, dtype=np.float32),
    )
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_vector3"><code class="name flex">
<span>def <span class="ident">set_vector3</span></span>(<span>self, variable, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Set Vector 3 as array value</p>
<p>This method will simply convert <code>value</code> into numpy array and call
<a title="payton.scene.shader.Shader.set_vector3_np" href="#payton.scene.shader.Shader.set_vector3_np"><code>Shader.set_vector3_np()</code></a> method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Vector 3 to set. (Numpy array with 3 elemenets)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_vector3(self, variable: str, value: List[float]) -&gt; None:
    &#34;&#34;&#34;Set Vector 3 as array value

    This method will simply convert `value` into numpy array and call
    `payton.scene.shader.Shader.set_vector3_np` method.

    Args:
      variable: Variable name to set
      value: Vector 3 to set. (Numpy array with 3 elemenets)
    &#34;&#34;&#34;
    self.set_vector3_np(variable, np.array(value, dtype=np.float32))</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_vector3_array_np"><code class="name flex">
<span>def <span class="ident">set_vector3_array_np</span></span>(<span>self, variable, value, count)</span>
</code></dt>
<dd>
<section class="desc"><p>Set array of vec3 as numpy array value</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_vector3_array_np(
    self, variable: str, value: np.ndarray, count: int
) -&gt; bool:
    &#34;&#34;&#34;Set array of vec3 as numpy array value&#34;&#34;&#34;
    value = value.flatten()
    location = self.get_location(variable)
    if location == -1:
        return False
    glUniform3fv(location, count, value)
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_vector3_np"><code class="name flex">
<span>def <span class="ident">set_vector3_np</span></span>(<span>self, variable, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Set Vector 3 as numpy array value</p>
<p>Some elements like Light or pre-set materials can pass their
vertices directly as numpy array to reduce number of object
conversions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Vector 3 to set. (Numpy array with 3 elemenets)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_vector3_np(self, variable: str, value: np.ndarray) -&gt; bool:
    &#34;&#34;&#34;Set Vector 3 as numpy array value

    Some elements like Light or pre-set materials can pass their
    vertices directly as numpy array to reduce number of object
    conversions.

    Args:
      variable: Variable name to set
      value: Vector 3 to set. (Numpy array with 3 elemenets)
    &#34;&#34;&#34;
    location = self.get_location(variable)
    if location == -1:
        return False
    glUniform3fv(location, 1, value)
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_vector4_np"><code class="name flex">
<span>def <span class="ident">set_vector4_np</span></span>(<span>self, variable, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Set Vector 4 as numpy array value</p>
<p>Some elements like Light or pre-set materials can pass their vertices
directly as numpy array to reduce number of object conversions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Vector 4 to set. (Numpy array with 4 elemenets)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_vector4_np(self, variable: str, value: np.ndarray) -&gt; bool:
    &#34;&#34;&#34;Set Vector 4 as numpy array value

    Some elements like Light or pre-set materials can pass their vertices
    directly as numpy array to reduce number of object conversions.

    Args:
      variable: Variable name to set
      value: Vector 4 to set. (Numpy array with 4 elemenets)
    &#34;&#34;&#34;
    location = self.get_location(variable)
    if location == -1:
        return False
    glUniform4fv(location, 1, value)
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.use"><code class="name flex">
<span>def <span class="ident">use</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use GLSL Program.
This method should be called before setting any variables or rendering
any entities</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def use(self) -&gt; bool:
    &#34;&#34;&#34;Use GLSL Program.
    This method should be called before setting any variables or rendering
    any entities
    &#34;&#34;&#34;
    if self.program == -1:
        logging.error(&#34;Shader not compiled&#34;)
        return False
    glUseProgram(self.program)
    glEnable(GL_PROGRAM_POINT_SIZE)
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="payton.scene" href="index.html">payton.scene</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="payton.scene.shader.Shader" href="#payton.scene.shader.Shader">Shader</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.shader.Shader.HUD" href="#payton.scene.shader.Shader.HUD">HUD</a></code></li>
<li><code><a title="payton.scene.shader.Shader.LIGHT_COLOR" href="#payton.scene.shader.Shader.LIGHT_COLOR">LIGHT_COLOR</a></code></li>
<li><code><a title="payton.scene.shader.Shader.LIGHT_TEXTURE" href="#payton.scene.shader.Shader.LIGHT_TEXTURE">LIGHT_TEXTURE</a></code></li>
<li><code><a title="payton.scene.shader.Shader.NO_LIGHT_COLOR" href="#payton.scene.shader.Shader.NO_LIGHT_COLOR">NO_LIGHT_COLOR</a></code></li>
<li><code><a title="payton.scene.shader.Shader.NO_LIGHT_TEXTURE" href="#payton.scene.shader.Shader.NO_LIGHT_TEXTURE">NO_LIGHT_TEXTURE</a></code></li>
<li><code><a title="payton.scene.shader.Shader.PER_VERTEX_COLOR" href="#payton.scene.shader.Shader.PER_VERTEX_COLOR">PER_VERTEX_COLOR</a></code></li>
<li><code><a title="payton.scene.shader.Shader.build" href="#payton.scene.shader.Shader.build">build</a></code></li>
<li><code><a title="payton.scene.shader.Shader.end" href="#payton.scene.shader.Shader.end">end</a></code></li>
<li><code><a title="payton.scene.shader.Shader.get_location" href="#payton.scene.shader.Shader.get_location">get_location</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_float" href="#payton.scene.shader.Shader.set_float">set_float</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_int" href="#payton.scene.shader.Shader.set_int">set_int</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_matrix4x4" href="#payton.scene.shader.Shader.set_matrix4x4">set_matrix4x4</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_matrix4x4_np" href="#payton.scene.shader.Shader.set_matrix4x4_np">set_matrix4x4_np</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_vector3" href="#payton.scene.shader.Shader.set_vector3">set_vector3</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_vector3_array_np" href="#payton.scene.shader.Shader.set_vector3_array_np">set_vector3_array_np</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_vector3_np" href="#payton.scene.shader.Shader.set_vector3_np">set_vector3_np</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_vector4_np" href="#payton.scene.shader.Shader.set_vector4_np">set_vector4_np</a></code></li>
<li><code><a title="payton.scene.shader.Shader.use" href="#payton.scene.shader.Shader.use">use</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>