<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.2" />
<title>payton.scene.geometry API documentation</title>
<meta name="description" content="Payton main geometry module â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>payton.scene.geometry</code></h1>
</header>
<section id="section-intro">
<p>Payton main geometry module</p>
<p>Geometry module holds the basic geometry shapes. They are all inherited
from <a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object"><code>Object</code></a> class. They are as simple as possible.</p>
<p>Their face informations are generated at the initialization but vertex array
object is not generated until it arrives in render pipeline.</p>
<ul>
<li>Object</li>
<li>Material (<a title="payton.scene.material" href="material.html"><code>payton.scene.material</code></a>)<ul>
<li>Shader (<a title="payton.scene.shader" href="shader.html"><code>payton.scene.shader</code></a>)</li>
</ul>
</li>
</ul>
<details class="source">
<summary>Source code</summary>
<pre><code class="python"># pylama:ignore=C901
&#34;&#34;&#34;
Payton main geometry module

Geometry module holds the basic geometry shapes. They are all inherited
from `payton.scene.geometry.Object` class. They are as simple as possible.

Their face informations are generated at the initialization but vertex array
object is not generated until it arrives in render pipeline.

* Object
  * Material (`payton.scene.material`)
    * Shader (`payton.scene.shader`)
&#34;&#34;&#34;

import pyrr
import math
import numpy as np  # type: ignore
import ctypes
import logging
from typing import Union, List, Dict, Type, Any, Iterator, Optional

from OpenGL.GL import (
    glDeleteVertexArrays,
    glIsVertexArray,
    glBindVertexArray,
    GL_LINE,
    GL_FILL,
    GL_TRIANGLES,
    glPolygonMode,
    GL_LINE_STRIP,
    glGenVertexArrays,
    glGenBuffers,
    GL_ARRAY_BUFFER,
    glEnableVertexAttribArray,
    glVertexAttribPointer,
    GL_FLOAT,
    GL_STATIC_DRAW,
    GL_DYNAMIC_DRAW,
    glBindBuffer,
    glBufferData,
    glBufferSubData,
    GL_ELEMENT_ARRAY_BUFFER,
    glDeleteBuffers,
    GL_POINT,
    GL_POINTS,
    GL_FRONT_AND_BACK,
    glDrawElements,
    GL_UNSIGNED_INT,
)

from payton.math.geometry import raycast_sphere_intersect
from payton.math.vector import plane_normal, vector_transform
from payton.math.matrix import create_rotation_matrix
from payton.scene.material import Material, SOLID, POINTS, WIREFRAME
from payton.scene.shader import Shader
from payton.scene.light import Light
from payton.scene.types import VList, IList


class Object(object):
    &#34;&#34;&#34;Main Payton Object.

    This is an abstract class to define common properties and methods between
    Mesh / Cube / Sphere/ Shape2D / PointCloud and etc.

    Objects are not actually built as 3D vertex arrays until they are rendered.
    Render function calls `build` function if needed. Build function creates
    the OpenGL Vertex Array Object. VAO is a static data so, once the object
    is built, changing vertices or indices will not take effect at the scene.

    You need to call `payton.scene.geometry.Object.build` function to refresh
    Vertex Array Object.

    OpenGL can not magically extend a memory buffer, so for every new vertices
    added to the object, OpenGL needs to re-create the buffer area. This is
    not an efficitient technique if number of vertices increase in time.
    As a result Payton allocates buffer for 500 vertices in the beginning and
    uses a part of it. If object exceeds 500 vertices, a new buffer is created
    with 500 more vertices, copies existing vertices to new and old buffer
    is deleted.

    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;
        Initialize the basic object properties.

        Properties:
          children: Children hash for object. Each child object follows parent
                    object. They take their parent object as origin and their
                    coordinate system is relative to their parent. This
                    behaviour resembles stars, planets and their moons.
          material: Material definitions of the object.
          matrix: Matrix definition of the object. This is a 4x4 Uniform Matrix
                  But data is set as an array for easier transformations. First
                  4 decimals are &#34;Left&#34; vector, Second 4 are &#34;Direction&#34;, Third
                  4 are &#34;Up&#34; and last four decimals are &#34;Position&#34; vectors.

        Args:
          track_motion: Track object motion (default: false). Object tracking
                        is time independent. It just saves the object matrix
                        for every change. Uses matrix position for drawing the
                        motion path.
          static: (Default `True`) Indicates if object geometry is expected
                  to be changed in the future. If object is not static, then
                  its&#39; vertex buffer object references and vertex informations
                  will not be deleted to be used for future reference.
          name: Name of the object (optional, default &#39;&#39;) Note that, when
                object gets added to a Scene with a name, Scene will assign
                that name to the object, overwriting any existing name of the
                object.
          visible: Is this object visible at the scene, default: True. To hid
                   an object, you can call `object.hide()` and to show it again
                   use: `object.show()`
        &#34;&#34;&#34;
        self.children: Dict[str, Object] = {}
        self.material: Material = Material()
        self.static = args.get(&#34;static&#34;, True)
        self.name = args.get(&#34;name&#34;, &#34;&#34;)
        self._visible = args.get(&#34;visible&#34;, True)
        self.matrix: VList = [
            [1.0, 0.0, 0.0, 0.0],
            [0.0, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.0],
            [0.0, 0.0, 0.0, 1.0],
        ]
        # Object vertices. Each vertex has 3 decimals (X, Y, Z). Vertices
        # are continuous. [X, Y, Z, X, Y, Z, X, Y, Z, X, ... ]
        #                  -- 1 --  -- 2 --  -- 3 --  -- 4 --

        self._vertices: VList = []  # Object vertex list
        self._normals: List[
            List[float]
        ] = []  # Vertex normals, 1 normal coordinate for 1 Vertex
        self._texcoords: List[
            List[float]
        ] = []  # Texture coordinates, 1 coordinate per Vertex
        self._vertex_colors: List[
            List[float]
        ] = []  # per-vertex colors, optional.
        self._has_vertex_colors: bool = False  # flag for using vertex colors

        # Vertices do not mean anything unless we define how to use them.
        # For instance, 3 vertices make a triangle or 2 vertices define a line
        # order of vertices are defined in self._indices.
        self._indices: IList = []
        self._vertex_count: int = 0  # Number of vertices to report to OpenGL.

        # This is an optimization technique for dynamic objects where there are
        # increasing number of vertices. We allocate some buffer before-hand
        # and if we fill all of it, we resize it.
        self._buffer_size: float = 500 * 12
        self._t_buffer_size: float = 500 * 8
        self._model_matrix: np.ndarray = []  # Model matrix.
        # Check if buffer size allocated for the object has changed.
        self._buffer_size_changed: bool = True
        self._t_buffer_size_changed: bool = True

        # Track object motion
        self.track_motion = args.get(&#34;track_motion&#34;, False)
        # Motion path, stores every matrix change.
        self._motion_path: List[VList] = []
        if not isinstance(self, Line):
            # _motion_path_line is used to display the motion path in scene
            self._motion_path_line = Line()
        self._previous_matrix: Union[np.ndarray, None] = None

        # For raycast tests - bounding radius is the radius of the bounding
        # sphere.
        self._bounding_radius: float = 0
        self._bounding_box: VList = []
        self._selected: bool = False

        # Vertex Array Object pointer
        self._vao: int = -1
        self._needs_update: bool = False  # Object geometry has changed.
        self._hit: bool = False
        &#34;&#34;&#34; I personally prefer not to delete vbos as in some cases I need to
        # refer to VBOs to update them partially. I don&#39;t want to loose
        # their reference and make things harder. I am not naming them
        # anyways.
        &#34;&#34;&#34;
        self._vbos: List[int] = []

    def refresh(self) -&gt; None:
        &#34;&#34;&#34;Refresh object

        Forces object to get built again
        &#34;&#34;&#34;
        self._needs_update = True

    def yaw(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Yaw - Rotate around Z Axis

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([0, 0, 1], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def rotate_around_z(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Rotate around Z axis, alias for yaw function&#34;&#34;&#34;
        return self.yaw(angle)

    def rotate_around_x(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Pitch - Rotate around X axis

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([1, 0, 0], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def rotate_around_y(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Roll - Rotate around Y Axis (Direction)

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([0, 1, 0], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def select(self, start: np.ndarray, vector: np.ndarray) -&gt; bool:
        &#34;&#34;&#34;Select test for object using bounding Sphere.

        Note: this method is not 100% accurate as it is based on a rough
        assumption. Sphere area will be larger than actual object.

        If you want to have a more accurate way to handle this, try
        using raycast triangle intersect

        Args:
          start: Starting point of the ray (such as eye position)
          vector: Ray direction. This is not the end point of a line! This is
        a unit vector showing the ray direction.
        &#34;&#34;&#34;
        self._selected = raycast_sphere_intersect(
            start,
            vector,
            np.array(self.matrix[3], dtype=np.float32),
            self._bounding_radius,
        )

        for obj in self.children:
            x = self.children[obj].select(start, vector)
            if not self._selected and x:
                self._selected = True

        return self._selected

    def destroy(self) -&gt; bool:
        &#34;&#34;&#34;
        Destroy objects self

        Returns: bool
        &#34;&#34;&#34;
        if self.has_vao:
            glDeleteVertexArrays(1, [self._vao])
            self._vao = -1
        return True

    def update_matrix(
        self, parent_matrix: Optional[np.ndarray] = None
    ) -&gt; None:
        &#34;&#34;&#34;Update matrix

        Turn object matrix into numpy array.

        Args:
          parent_matrix: Parent objects matrix
        &#34;&#34;&#34;
        # Turn matrix into numpy array. Numpy arrays are C Type arrays
        # suitable for OpenGL Pipeline
        self._model_matrix = np.array(self.matrix, dtype=np.float32)

        # When there is a parent object, child object follows parents matrix
        if parent_matrix is not None and len(parent_matrix) &gt; 0:
            self._model_matrix = parent_matrix.dot(self._model_matrix)

    def track(self) -&gt; bool:
        &#34;&#34;&#34;
        Track object motion

        Returns:
          bool
        &#34;&#34;&#34;
        if not self.track_motion:
            return False
        if self._previous_matrix == self.matrix[3]:
            return True

        # Add the new matrix to motion path records
        self._motion_path.append(self.matrix)
        # Add the matrix position to motion math line for visualisation
        if self._motion_path_line is not None:
            self._motion_path_line.append(
                [[self.matrix[3][0], self.matrix[3][1], self.matrix[3][2]]]
            )

        # Python trick here! need to .copy or it will pass reference.
        self._previous_matrix = self.matrix[3].copy()
        return True

    @property
    def has_vao(self) -&gt; bool:
        &#34;&#34;&#34;Check if this object has an active Vertex Array Object

        Returns:
            bool
        &#34;&#34;&#34;
        return self._vao &gt; -1

    @property
    def visible(self) -&gt; bool:
        &#34;&#34;&#34;Check if object is visible&#34;&#34;&#34;
        return self._visible

    def show(self) -&gt; None:
        self._visible = True

    def hide(self) -&gt; None:
        self._visible = False

    def render(
        self,
        proj: np.ndarray,
        view: np.ndarray,
        lights: List[Light],
        parent_matrix: Optional[np.ndarray] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Virtual function for rendering the object. Some objects can overwrite
        this function.

        Args:
          proj: Camera projection matrix.
          view: Camera location/view matrix.
          lights: Light objects in the scene
          parent_matrix: Parent matrix is the matrix of the parent. Parent can
                         be the scene itself or another object. In case of
                         another object, object will position itself relative
                         to its parent object.
        &#34;&#34;&#34;
        if not self._visible:
            return

        if not self.has_vao or self._needs_update:
            self.build()

        if self._vertex_count == 0:
            return

        self.update_matrix(parent_matrix=parent_matrix)
        self.track()

        # Material shading mode.
        mode = None
        if self._has_vertex_colors:
            mode = Shader.PER_VERTEX_COLOR

        self.material.render(proj, view, self._model_matrix, lights, mode)

        # Actual rendering
        if glIsVertexArray(self._vao):
            glBindVertexArray(self._vao)
            pmode = GL_LINE
            primitive = GL_LINE_STRIP
            if self.material.display == SOLID:
                pmode = GL_FILL
                primitive = GL_TRIANGLES
            if self.material.display == POINTS:
                pmode = GL_POINT
                primitive = GL_POINTS
            glPolygonMode(GL_FRONT_AND_BACK, pmode)

            glDrawElements(
                primitive,
                self._vertex_count,
                GL_UNSIGNED_INT,
                ctypes.c_void_p(0),
            )
            if pmode != GL_FILL:
                glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
            glBindVertexArray(0)

        # End using the shader program.
        self.material.end()

        # Render motion path
        if self.track_motion:
            self._motion_path_line.render(proj, view, lights, parent_matrix)

        # render children
        for child in self.children:
            self.children[child].render(proj, view, lights, self._model_matrix)

    @property
    def position(self) -&gt; List[float]:
        &#34;&#34;&#34;Get position of the Object.

        Return matrix position list

        Returns:
          List[float]
        &#34;&#34;&#34;
        return self.matrix[3][:3]

    @position.setter
    def position(self, pos: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Shortcut function for explicitly modifying matrix indices.

        Basically just sets x, y, z of the matrix. Does not change its
        direction or up vectors.

        Args:
          pos: Position list ([x, y, z])
        &#34;&#34;&#34;
        if len(pos) == 2:
            pos = [pos[0], pos[1], 0.0]
        self.matrix[3][0] = pos[0]
        self.matrix[3][1] = pos[1]
        self.matrix[3][2] = pos[2]

    def add_child(self, name: str, obj: Type[&#34;Object&#34;]) -&gt; bool:
        &#34;&#34;&#34;Add child to this object.

        In a basic example:

            .. include:: ../../examples/basics/05_children.py

        Args:
          name: Name of the object, must be unique within its siblings
          obj: Object. Must be an instance of `payton.scene.geometry.Object`

        Returns:
          bool: False in case of an error
        &#34;&#34;&#34;
        if name in self.children:
            logging.error(f&#34;Name {name} exists in object children&#34;)
            return False
        if not isinstance(obj, Object):
            logging.error(&#34;Object type is not valid&#34;)
            return False
        self.children[name] = obj
        return True

    def to_absolute(self, coordinates: List[float]) -&gt; List[float]:
        &#34;&#34;&#34;
        Return local coordinates (tuple, list) into absolute coordinates in
        space.

        Args:
          coordinates: List[float] (x, y, z)

        Returns:
          List[float] (x&#39;, y&#39;, z&#39;)
        &#34;&#34;&#34;
        return vector_transform(coordinates, self.matrix)

    def absolute_vertices(self) -&gt; Iterator[List[float]]:
        &#34;&#34;&#34;Return a map of all local vertices as absolute coordinates.

        Imagine that object B is a child of object A. In this case, B will
        always stand (follow) relative to A. If you want to know the exact
        world coordinates of all vertices in B, this method will return them.

        **Important!** This is a costly operation so use with caution!

        Returns:
          map(List[List[float]])
        &#34;&#34;&#34;
        return map(lambda v: self.to_absolute(v), self._vertices)

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle wireframe view of the Object&#34;&#34;&#34;
        d = self.material.display
        d += 1
        d = d % 3

        self.material.display = d
        for n in self.children:
            self.children[n].toggle_wireframe()

    def _calc_bounds(self) -&gt; float:
        &#34;&#34;&#34;Calculate the bounding sphere radius

        Returns:
          float
        &#34;&#34;&#34;
        vertices = np.array(self._vertices, dtype=np.float32)

        bmin: Optional[List[float]] = None
        bmax: Optional[List[float]] = None
        for v in vertices:
            if bmin is None:
                bmin = [0, 0, 0]
                bmin[0], bmin[1], bmin[2] = v[0], v[1], v[2]
            if bmax is None:
                bmax = [0, 0, 0]
                bmax[0], bmax[1], bmax[2] = v[0], v[1], v[2]
            if v[0] &lt; bmin[0]:
                bmin[0] = v[0]
            if v[1] &lt; bmin[1]:
                bmin[1] = v[1]
            if v[2] &lt; bmin[2]:
                bmin[2] = v[2]
            if v[0] &gt; bmax[0]:
                bmax[0] = v[0]
            if v[1] &gt; bmax[1]:
                bmax[1] = v[1]
            if v[2] &gt; bmax[2]:
                bmax[2] = v[2]

            d = pyrr.vector3.length(v)
            if d &gt; self._bounding_radius:
                self._bounding_radius = d
        if bmin is None:
            bmin = [0.0, 0.0, 0.0]
        if bmax is None:
            bmax = [0.0, 0.0, 0.0]
        self._bounding_box = [bmin, bmax]
        return self._bounding_radius

    @property
    def bounding_radius(self) -&gt; float:
        &#34;&#34;&#34;Return bounding radius

        Note: This property function *WILL NOT* update the previously
        calculated value. If you add vertices to the object, you must call
        `payton.scene.geometry.Object.refresh` function to get radius
        and the whole object updated.

        Returns:
          float
        &#34;&#34;&#34;

        if self._bounding_radius &gt; 0:
            return self._bounding_radius
        return self._calc_bounds()

    def build(self) -&gt; bool:
        &#34;&#34;&#34;
        Build OpenGL Vertex Array for the object

        This function gets automatically called if `self._vao` does not
        exists in the first render cycle. Once the vba is built,
        geometry changes or material display mode changes will not be
        automatically effected. So, in every geometry or display mode
        change, a `build` call is necessary.

        if `self.static` is `True`, then system assumes that another update
        call is not expected, thus frees `_normals&#39;, `_textcoords`,
        `_vertices` and `_indices` lists to free memory.
        So in this case, calling `build` function twice will result with
        an invisible object (will not be drawn)

        Returns:
          bool
        &#34;&#34;&#34;
        if len(self._indices) == 0:
            return False

        # If we don&#39;t have a VAO yet, we need to create one
        if not self.has_vao:
            # Generate Vertex Array
            self._vao = glGenVertexArrays(1)
            # We need 5 buffers (vertex, normal, texcoord, color, indices)
            self._vbos = glGenBuffers(5)
            glBindVertexArray(self._vao)
            # Material shader must be built when there is an active binding
            # to vertex array
            self.material.build_shader()
        else:
            # Ok, we already have vertex array object, just bind it to modify
            glBindVertexArray(self._vao)

        # Turn python arrays into C type arrays using Numpy.
        # This is required for OpenGL. Python memory model is a bit
        # different than raw memory model of C (OpenGL)
        vertices = np.array(self._vertices, dtype=np.float32).flatten()
        normals = np.array(self._normals, dtype=np.float32).flatten()
        texcoords = np.array(self._texcoords, dtype=np.float32).flatten()
        colors = np.array(self._vertex_colors, dtype=np.float32).flatten()
        indices = np.array(self._indices, dtype=np.int32).flatten()
        self._calc_bounds()

        # OpenGL allocates buffers in different mechanisms between
        # STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL
        # will assume that object buffer will not change and allocate it in a
        # more suitable way.
        draw = GL_STATIC_DRAW
        if not self.static:
            draw = GL_DYNAMIC_DRAW

        # Buffer overflow, we need more space.
        if self._buffer_size &lt; vertices.nbytes:
            self._buffer_size = vertices.nbytes
            self._buffer_size_changed = True
        if self._t_buffer_size &lt; texcoords.nbytes:
            self._t_buffer_size = texcoords.nbytes
            self._t_buffer_size_changed = True

        # Bind Vertices
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[0])
        glEnableVertexAttribArray(0)  # shader layout location
        glVertexAttribPointer(0, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        if self._buffer_size_changed:
            # glBufferData creates a new data area
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, vertices, draw)
        else:
            # glBufferSubData just replaces memory area in buffer so it is
            # much more efficient way to handle things.
            glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.nbytes, vertices)

        # Bind Normals
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[1])
        glEnableVertexAttribArray(1)  # shader layout location
        glVertexAttribPointer(1, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        if self._buffer_size_changed:
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, normals, draw)
        else:
            glBufferSubData(GL_ARRAY_BUFFER, 0, normals.nbytes, normals)

        # Bind TexCoords
        if len(self._texcoords) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[2])
            glEnableVertexAttribArray(2)  # shader layout location
            glVertexAttribPointer(2, 2, GL_FLOAT, False, 0, ctypes.c_void_p(0))
            if self._t_buffer_size_changed:
                glBufferData(
                    GL_ARRAY_BUFFER, self._t_buffer_size, texcoords, draw
                )
            else:
                glBufferSubData(
                    GL_ARRAY_BUFFER, 0, texcoords.nbytes, texcoords
                )

        # Bind Vertex Colors
        if len(self._vertex_colors) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[4])
            glEnableVertexAttribArray(3)  # shader layout location
            glVertexAttribPointer(3, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
            self._has_vertex_colors = True
            if self._buffer_size_changed:
                glBufferData(GL_ARRAY_BUFFER, self._buffer_size, colors, draw)
            else:
                glBufferSubData(GL_ARRAY_BUFFER, 0, colors.nbytes, colors)

        self._buffer_size_changed = False
        self._t_buffer_size_changed = False

        # Bind Indices
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self._vbos[3])
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.nbytes, indices, draw)
        self._vertex_count = len(indices)

        glBindVertexArray(0)
        glBindBuffer(GL_ARRAY_BUFFER, 0)

        if self.static:
            # we can clear this data to free some more memory
            glDeleteBuffers(4, self._vbos)
            self._vbos = []

        self._needs_update = False

        return True


class Mesh(Object):
    &#34;&#34;&#34;Mesh Object

    Mesh is almost like the Object except with some extra methods to make
    things easier. If you want to have custom geometries/shapes, it is
    better to extend `payton.scene.geometry.Mesh` instead of
    `payton.scene.geometry.Object`. Because Mesh will give you better
    and easier constructing capabilities such as adding triangles on the fly
    or sub-division or cutting and so forth. It is a way of designing objects
    by code.


    Example use case:

        .. include:: ../../examples/basics/09_mesh.py
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        super().__init__(**args)
        self.static = False

    def clear_triangles(self) -&gt; None:
        &#34;&#34;&#34;Clear all triangles inside the Mesh&#34;&#34;&#34;
        self._vertices = []
        self._indices = []
        self._normals = []
        self._texcoords = []
        self._vertex_colors = []
        self.refresh()

    def fix_normals(self) -&gt; None:
        &#34;&#34;&#34;Try to re-calculate Mesh normals, if your object has already perfect
        normals, do not call this method&#34;&#34;&#34;
        self._normals = []
        for face in self._indices:
            v1, v2, v3 = (
                self._vertices[face[0]],
                self._vertices[face[1]],
                self._vertices[face[2]],
            )
            normal = plane_normal(v1, v2, v3)
            self._normals.extend([normal, normal, normal])

    def scale(self, x: float, y: float, z: float) -&gt; None:
        &#34;&#34;&#34;Scale Mesh by given factors

        Note: This does not create a scale matrix and multiply existing matrix
              with it. Instead, it will scale the vertices by given factors.
        &#34;&#34;&#34;
        self._vertices = list(
            map(lambda v: [v[0] * x, v[1] * y, v[2] * z], self._vertices)
        )
        self.fix_normals()
        self.refresh()

    def add_triangle(
        self,
        vertices: VList,
        normals: Optional[VList] = None,
        texcoords: Optional[VList] = None,
        colors: Optional[VList] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add triangle to Mesh

        Args:
          vertices: Vertices of the triangle. This is required. Ex:
                    `[[0, 0, 0], [2, 0, 0], [1, 1, 0]]`
          normals: Normals of the triangle. _(When left as None, Payton will
                   calculate the surface normal based on vertices and assign
                   it per given vertex.)_
          texcoords: Texture UV coordinates.
          colors: Per vertex colors (optional)
        &#34;&#34;&#34;
        if len(vertices) != 3:
            logging.error(&#34;A triangle must have 3 vertices&#34;)
            return

        if normals is not None and len(normals) != 3:
            logging.error(&#34;There must be one normal per vertex&#34;)
            return

        if texcoords is not None and len(texcoords) != 3:
            logging.error(&#34;There must be one texcoord per vertex&#34;)
            return

        if normals is None:
            v1, v2, v3 = vertices[0], vertices[1], vertices[2]
            normal = plane_normal(v1, v2, v3)
            normals = [normal, normal, normal]
        if texcoords is None:
            texcoords = [[0, 0], [1, 0], [1, 1]]
        if colors:
            for color in colors:
                self._vertex_colors.append(color)

        for v in vertices:
            self._vertices.append(v)

        i = len(self._indices) * 3
        self._indices.append([i, i + 1, i + 2])
        for normal in normals:
            self._normals.append(normal)
        for t in texcoords:
            self._texcoords.append(t)
        self.refresh()


class Cube(Mesh):
    &#34;&#34;&#34;
    Cube object

    This is a simple Cube object with width, height and depth.

    Cube object use case:

        .. include:: ../../examples/basics/03_cubes.py

    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Initialize Cube

        Args:
          width: Width of the cube (size X)
          depth: Depth of the cube (size Y)
          height: Height of the cube (size Z)
        &#34;&#34;&#34;
        super().__init__(**args)
        width = args.get(&#34;width&#34;, 1.0) * 0.5
        depth = args.get(&#34;depth&#34;, 1.0) * 0.5
        height = args.get(&#34;height&#34;, 1.0) * 0.5

        self._vertices = [
            [-width, -depth, height],
            [width, -depth, height],
            [-width, depth, height],
            [width, depth, height],
            [-width, depth, height],
            [width, depth, height],
            [-width, depth, -height],
            [width, depth, -height],
            [-width, depth, -height],
            [width, depth, -height],
            [-width, -depth, -height],
            [width, -depth, -height],
            [-width, -depth, -height],
            [width, -depth, -height],
            [-width, -depth, height],
            [width, -depth, height],
            [width, -depth, height],
            [width, -depth, -height],
            [width, depth, height],
            [width, depth, height],
            [width, depth, -height],
            [-width, -depth, -height],
            [-width, -depth, height],
            [-width, depth, -height],
            [-width, depth, -height],
            [-width, -depth, height],
            [-width, depth, height],
        ]

        self._normals = [
            [0.0, 0.0, 1.0],
            [0.0, 0.0, 1.0],
            [0.0, 0.0, 1.0],
            [0.0, 0.0, 1.0],
            [0.0, 1.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 0.0, -1.0],
            [0.0, 0.0, -1.0],
            [0.0, 0.0, -1.0],
            [0.0, 0.0, -1.0],
            [0.0, -1.0, 0.0],
            [0.0, -1.0, 0.0],
            [0.0, -1.0, 0.0],
            [0.0, -1.0, 0.0],
            [1.0, 0.0, 0.0],
            [1.0, 0.0, 0.0],
            [1.0, 0.0, 0.0],
            [1.0, 0.0, 0.0],
            [1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [-1.0, 0.0, 0],
        ]

        self._texcoords = [
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 1.0],
            [1.0, 1.0],
            [0.0, 0.0],
            [0.0, 0.0],
            [1.0, 1.0],
            [1.0, 0.0],
        ]

        self._indices = [
            [0, 1, 2],
            [2, 1, 3],
            [4, 5, 6],
            [6, 5, 7],
            [8, 9, 10],
            [10, 9, 11],
            [12, 13, 14],
            [14, 13, 15],
            [16, 17, 18],
            [19, 17, 20],
            [21, 22, 23],
            [24, 25, 26],
        ]

        return None


class Sphere(Mesh):
    &#34;&#34;&#34;
    Sphere object.

    This object is generated using basic Spherical coordinates.
    Beware of using high values for parallels and meridians. You might end up
    with excessive number of vertices to render and a performance trouble.

    Parameters:

    - `radius` default: `0.5`
    - `parallels` default: `12`
    - `meridians` default: `12`

    Sphere object use case

        .. include:: ../../examples/basics/05_children.py

    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Initialize the sphere

        Args:
          radius: Radius of the sphere (default: 0.5, making it a unit sphere)
          parallels: Number of parallels (as in geography). (default: 12, 30
                     degrees of arcs)
          meridians: Number of meridians (as in geography). (default: 12)
        &#34;&#34;&#34;
        super().__init__(**args)
        self.radius: float = args.get(&#34;radius&#34;, 0.5)
        self.parallels: int = args.get(&#34;parallels&#34;, 12)
        self.meridians: int = args.get(&#34;meridians&#34;, 12)
        self.build_sphere()

    def build_sphere(self) -&gt; bool:
        &#34;&#34;&#34;
        Generate the sphere

        Returns:
          bool
        &#34;&#34;&#34;
        r = self.radius
        # step angle is the rotational angle to build the sphere
        step_angle = math.radians(360.0 / self.meridians)
        # step height is the arc in height
        step_height = math.radians(180.0 / self.parallels)
        indices = 0
        u_step = 1.0 / self.meridians
        v_step = 1.0 / self.parallels

        for i in range(self.parallels):
            for j in range(self.meridians):
                x1 = r * math.sin(step_height * i) * math.cos(step_angle * j)
                y1 = r * math.sin(step_height * i) * math.sin(step_angle * j)
                z1 = r * math.cos(step_height * i)
                u1 = u_step * j
                v1 = v_step * i

                x2 = (
                    r
                    * math.sin(step_height * (i + 1))
                    * math.cos(step_angle * j)
                )
                y2 = (
                    r
                    * math.sin(step_height * (i + 1))
                    * math.sin(step_angle * j)
                )
                z2 = r * math.cos(step_height * (i + 1))
                u2 = u_step * j
                v2 = v_step * (i + 1)

                x3 = (
                    r
                    * math.sin(step_height * (i + 1))
                    * math.cos(step_angle * (j + 1))
                )
                y3 = (
                    r
                    * math.sin(step_height * (i + 1))
                    * math.sin(step_angle * (j + 1))
                )
                z3 = r * math.cos(step_height * (i + 1))
                u3 = u_step * (j + 1)
                v3 = v_step * (i + 1)

                x4 = (
                    r
                    * math.sin(step_height * i)
                    * math.cos(step_angle * (j + 1))
                )
                y4 = (
                    r
                    * math.sin(step_height * i)
                    * math.sin(step_angle * (j + 1))
                )
                z4 = r * math.cos(step_height * i)
                u4 = u_step * (j + 1)
                v4 = v_step * i

                normal = plane_normal([x1, y1, z1], [x2, y2, z2], [x3, y3, z3])
                self._vertices.append([x1, y1, z1])
                self._vertices.append([x2, y2, z2])
                self._vertices.append([x3, y3, z3])
                self._vertices.append([x4, y4, z4])
                self._texcoords.append([u1, v1])
                self._texcoords.append([u2, v2])
                self._texcoords.append([u3, v3])
                self._texcoords.append([u4, v4])
                self._normals.append([normal[0], normal[1], normal[2]])
                self._normals.append([normal[0], normal[1], normal[2]])
                self._normals.append([normal[0], normal[1], normal[2]])
                self._normals.append([normal[0], normal[1], normal[2]])
                self._indices.append([indices, indices + 1, indices + 2])
                self._indices.append([indices, indices + 2, indices + 3])
                indices += 4
        return True


class Cylinder(Mesh):
    &#34;&#34;&#34;Cylinder Object

    Beware of using high values for number of meridians. You might end up with
    excessive number of vertices to render.
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Iniitalize the cylinder

        Args:
          bottom_radius: Radius at the bottom of the cylinder
          top_radius: Radius at the top of the cylinder
          meridians: Number of meridians/edges (as in geography)
          height: Height of the cylinder
        &#34;&#34;&#34;
        super().__init__(**args)
        self._bottom_radius: float = args.get(&#34;bottom_radius&#34;, 0.5)
        self._top_radius: float = args.get(&#34;top_radius&#34;, 0.5)
        self._meridians: int = args.get(&#34;meridians&#34;, 12)
        self._height: float = args.get(&#34;height&#34;, 1.0)
        self.build_cylinder()

    def build_cylinder(self) -&gt; bool:
        step_angle = math.radians(360 / self._meridians)

        u_step = 1.0 / self._meridians
        r_bot = self._bottom_radius
        r_top = self._top_radius
        h_2 = self._height / 2.0
        for i in range(self._meridians):
            x1 = r_bot * math.cos(step_angle * i)
            y1 = r_bot * math.sin(step_angle * i)
            x2 = r_top * math.cos(step_angle * i)
            y2 = r_top * math.sin(step_angle * i)

            u1 = u_step * i
            v1 = 1.0
            u2 = u1
            v2 = 0.0

            x3 = r_bot * math.cos(step_angle * (i + 1))
            y3 = r_bot * math.sin(step_angle * (i + 1))
            x4 = r_top * math.cos(step_angle * (i + 1))
            y4 = r_top * math.sin(step_angle * (i + 1))

            u3 = u_step * (i + 1)
            v3 = 1.0
            u4 = u3
            v4 = 0.0

            self.add_triangle(
                [[x1, y1, -h_2], [x2, y2, h_2], [x3, y3, -h_2]],
                texcoords=[[u1, v1], [u2, v2], [u3, v3]],
            )

            self.add_triangle(
                [[x3, y3, -h_2], [x2, y2, h_2], [x4, y4, h_2]],
                texcoords=[[u3, v3], [u2, v2], [u4, v4]],
            )

            self.add_triangle(
                [[x1, y1, -h_2], [0.0, 0.0, -h_2], [x3, y3, -h_2]],
                texcoords=[[u1, v1], [0.0, 0.0], [u3, v3]],
            )

            self.add_triangle(
                [[x4, y4, h_2], [0.0, 0.0, h_2], [x2, y2, h_2]],
                texcoords=[[u4, v4], [0.0, 0.0], [u2, v2]],
            )

        self.fix_normals()
        return True


class Line(Object):
    &#34;&#34;&#34;Line object
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Iniitalize line

        Args:
          vertices: Vertices array for list of points.
          color: Color of the line

        Example use case:

            .. include:: ../../examples/basics/17_line.py
        &#34;&#34;&#34;
        super().__init__(**args)
        self._vertices: VList = args.get(&#34;vertices&#34;, [])
        self.material.color = args.get(&#34;color&#34;, [1.0, 1.0, 1.0])

        self.static: bool = False  # Do not clear the vertices each time.
        self.material.display = WIREFRAME
        self.build_lines()

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle Wireframe overwrite to disable mode change&#34;&#34;&#34;
        pass

    def append(self, vertices: VList) -&gt; None:
        &#34;&#34;&#34;Append vertex or vertices to line.

        Args:
          vertice: Vertex array of points.
        &#34;&#34;&#34;

        diff = len(vertices)  # Number of vertices added
        last_index = len(self._vertices)
        self._vertices += vertices

        self._texcoords += [[0, 0]] * diff
        self._normals += [[0, 0, 0]] * diff
        self._vertex_count = len(self._vertices)
        indices = list(map(lambda x: x + last_index, range(diff)))
        self._indices.extend([indices])

        if self.has_vao:
            self._needs_update = True

    def build_lines(
        self,
        vertices: Optional[VList] = None,
        color: Optional[List[float]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Build lines

        Build line vertex array object.
        &#34;&#34;&#34;
        if vertices is not None:
            self._vertices = vertices
        if color is not None:
            self.material.color = color
        self._vertex_count = len(self._vertices)
        for i in range(self._vertex_count - 1):
            self._indices.append([i, i + 1])

        for i in range(self._vertex_count):
            self._normals.append([0, 0, 0])
            self._texcoords.append([0, 0])

        if self.has_vao:
            # This is a dynamic object, destroying the object is not a good
            # idea so we just update the buffer here.
            self.build()


class PointCloud(Object):
    &#34;&#34;&#34;Point cloud

    Note: If you change the vertices, do not forget to do a `refresh` to take
    effect.

    Example use case:

        .. include:: ../../examples/basics/11_point_cloud.py
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Initialize Point Cloud

        Args:
          vertices: List of point vertices
          colors: List of colors per vertex, follows the same index as vertices
        &#34;&#34;&#34;
        super().__init__(**args)
        self._vertices: VList = args.get(&#34;vertices&#34;, [])
        # Expose vertices by reference for modification
        self.vertices: VList = self._vertices
        self._vertex_colors: VList = args.get(&#34;colors&#34;, [])
        self._vertex_history: VList = []
        self.material.display = POINTS
        self.static: bool = False

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle wireframe overwrite to disable mode change&#34;&#34;&#34;
        pass

    def track(self) -&gt; bool:
        &#34;&#34;&#34;Tracking point cloud is not possible at the moment
        &#34;&#34;&#34;
        return False

    def add(self, vertices: VList, colors: Optional[VList] = None) -&gt; None:
        &#34;&#34;&#34;Add a point to the cloud

        Args:
          vertices: Vertices to add
          colors: Colors of the vertices in the same order. (Optional)
        &#34;&#34;&#34;
        i = len(self._indices)
        for vertex in vertices:
            self._vertices.append(vertex)
            self._indices.append([i])
            i += 1

        if colors is not None:
            if len(colors) != len(vertices):
                logging.error(&#34;len(colors) != len(vertices)&#34;)
                return
            for color in colors:
                self._vertex_colors.append(color)

        self._needs_update = True


class Plane(Mesh):
    &#34;&#34;&#34;Plane object

    This is a 2D Plane in 3D World. Has a width in X and height in Y.
    If you need to place it in another axis, try modifying its matrix.

    Example use case:

        .. include:: ../../examples/basics/13_plane.py
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Initialize plane

        Args:
          width: Width of the plane
          height: Height of the plane
        &#34;&#34;&#34;
        super().__init__(**args)
        width = args.get(&#34;width&#34;, 1.0) * 0.5
        height = args.get(&#34;height&#34;, 1.0) * 0.5
        self._vertices = [
            [-width, -height, 0],
            [width, -height, 0],
            [width, height, 0],
            [-width, height, 0],
        ]
        self._normals = [[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]]
        self._texcoords = [[-1, -1], [1, -1], [1, 1], [-1, 1]]
        self._indices = [[0, 1, 2], [0, 2, 3]]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="payton.scene.geometry.Cube"><code class="flex name class">
<span>class <span class="ident">Cube</span></span>
<span>(</span><span>**args)</span>
</code></dt>
<dd>
<section class="desc"><p>Cube object</p>
<p>This is a simple Cube object with width, height and depth.</p>
<p>Cube object use case:</p>
<pre><code>import random
from payton.scene import Scene
from payton.scene.geometry import Cube

scene = Scene()

for i in range(100):
    x = random.randint(-10, 10)
    y = random.randint(-10, 10)
    z = random.randint(-10, 10)
    r = random.randint(0, 255) / 255.0
    g = random.randint(0, 255) / 255.0
    b = random.randint(0, 255) / 255.0
    cube = Cube()
    cube.material.color = [r, g, b]
    cube.material.opacity = random.randint(0, 255) / 255.0
    cube.position = [x, y, z]
    scene.add_object("cube_{}".format(i), cube)

scene.run()
</code></pre>
<p>Initialize Cube</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong></dt>
<dd>Width of the cube (size X)</dd>
<dt><strong><code>depth</code></strong></dt>
<dd>Depth of the cube (size Y)</dd>
<dt><strong><code>height</code></strong></dt>
<dd>Height of the cube (size Z)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Cube(Mesh):
    &#34;&#34;&#34;
    Cube object

    This is a simple Cube object with width, height and depth.

    Cube object use case:

        .. include:: ../../examples/basics/03_cubes.py

    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Initialize Cube

        Args:
          width: Width of the cube (size X)
          depth: Depth of the cube (size Y)
          height: Height of the cube (size Z)
        &#34;&#34;&#34;
        super().__init__(**args)
        width = args.get(&#34;width&#34;, 1.0) * 0.5
        depth = args.get(&#34;depth&#34;, 1.0) * 0.5
        height = args.get(&#34;height&#34;, 1.0) * 0.5

        self._vertices = [
            [-width, -depth, height],
            [width, -depth, height],
            [-width, depth, height],
            [width, depth, height],
            [-width, depth, height],
            [width, depth, height],
            [-width, depth, -height],
            [width, depth, -height],
            [-width, depth, -height],
            [width, depth, -height],
            [-width, -depth, -height],
            [width, -depth, -height],
            [-width, -depth, -height],
            [width, -depth, -height],
            [-width, -depth, height],
            [width, -depth, height],
            [width, -depth, height],
            [width, -depth, -height],
            [width, depth, height],
            [width, depth, height],
            [width, depth, -height],
            [-width, -depth, -height],
            [-width, -depth, height],
            [-width, depth, -height],
            [-width, depth, -height],
            [-width, -depth, height],
            [-width, depth, height],
        ]

        self._normals = [
            [0.0, 0.0, 1.0],
            [0.0, 0.0, 1.0],
            [0.0, 0.0, 1.0],
            [0.0, 0.0, 1.0],
            [0.0, 1.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 1.0, 0.0],
            [0.0, 0.0, -1.0],
            [0.0, 0.0, -1.0],
            [0.0, 0.0, -1.0],
            [0.0, 0.0, -1.0],
            [0.0, -1.0, 0.0],
            [0.0, -1.0, 0.0],
            [0.0, -1.0, 0.0],
            [0.0, -1.0, 0.0],
            [1.0, 0.0, 0.0],
            [1.0, 0.0, 0.0],
            [1.0, 0.0, 0.0],
            [1.0, 0.0, 0.0],
            [1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [-1.0, 0.0, 0.0],
            [-1.0, 0.0, 0],
        ]

        self._texcoords = [
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 0.0],
            [0.0, 1.0],
            [1.0, 0.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 1.0],
            [1.0, 1.0],
            [0.0, 0.0],
            [0.0, 0.0],
            [1.0, 1.0],
            [1.0, 0.0],
        ]

        self._indices = [
            [0, 1, 2],
            [2, 1, 3],
            [4, 5, 6],
            [6, 5, 7],
            [8, 9, 10],
            [10, 9, 11],
            [12, 13, 14],
            [14, 13, 15],
            [16, 17, 18],
            [19, 17, 20],
            [21, 22, 23],
            [24, 25, 26],
        ]

        return None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.Mesh.absolute_vertices" href="#payton.scene.geometry.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.add_child" href="#payton.scene.geometry.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.add_triangle" href="#payton.scene.geometry.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.bounding_radius" href="#payton.scene.geometry.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.build" href="#payton.scene.geometry.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.clear_triangles" href="#payton.scene.geometry.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.destroy" href="#payton.scene.geometry.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.fix_normals" href="#payton.scene.geometry.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.has_vao" href="#payton.scene.geometry.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.position" href="#payton.scene.geometry.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.refresh" href="#payton.scene.geometry.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.render" href="#payton.scene.geometry.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_x" href="#payton.scene.geometry.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_y" href="#payton.scene.geometry.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_z" href="#payton.scene.geometry.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.scale" href="#payton.scene.geometry.Mesh.scale">scale</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.select" href="#payton.scene.geometry.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.to_absolute" href="#payton.scene.geometry.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.toggle_wireframe" href="#payton.scene.geometry.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.track" href="#payton.scene.geometry.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.update_matrix" href="#payton.scene.geometry.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.visible" href="#payton.scene.geometry.Object.visible">visible</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.yaw" href="#payton.scene.geometry.Object.yaw">yaw</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.Cylinder"><code class="flex name class">
<span>class <span class="ident">Cylinder</span></span>
<span>(</span><span>**args)</span>
</code></dt>
<dd>
<section class="desc"><p>Cylinder Object</p>
<p>Beware of using high values for number of meridians. You might end up with
excessive number of vertices to render.</p>
<p>Iniitalize the cylinder</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bottom_radius</code></strong></dt>
<dd>Radius at the bottom of the cylinder</dd>
<dt><strong><code>top_radius</code></strong></dt>
<dd>Radius at the top of the cylinder</dd>
<dt><strong><code>meridians</code></strong></dt>
<dd>Number of meridians/edges (as in geography)</dd>
<dt><strong><code>height</code></strong></dt>
<dd>Height of the cylinder</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Cylinder(Mesh):
    &#34;&#34;&#34;Cylinder Object

    Beware of using high values for number of meridians. You might end up with
    excessive number of vertices to render.
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Iniitalize the cylinder

        Args:
          bottom_radius: Radius at the bottom of the cylinder
          top_radius: Radius at the top of the cylinder
          meridians: Number of meridians/edges (as in geography)
          height: Height of the cylinder
        &#34;&#34;&#34;
        super().__init__(**args)
        self._bottom_radius: float = args.get(&#34;bottom_radius&#34;, 0.5)
        self._top_radius: float = args.get(&#34;top_radius&#34;, 0.5)
        self._meridians: int = args.get(&#34;meridians&#34;, 12)
        self._height: float = args.get(&#34;height&#34;, 1.0)
        self.build_cylinder()

    def build_cylinder(self) -&gt; bool:
        step_angle = math.radians(360 / self._meridians)

        u_step = 1.0 / self._meridians
        r_bot = self._bottom_radius
        r_top = self._top_radius
        h_2 = self._height / 2.0
        for i in range(self._meridians):
            x1 = r_bot * math.cos(step_angle * i)
            y1 = r_bot * math.sin(step_angle * i)
            x2 = r_top * math.cos(step_angle * i)
            y2 = r_top * math.sin(step_angle * i)

            u1 = u_step * i
            v1 = 1.0
            u2 = u1
            v2 = 0.0

            x3 = r_bot * math.cos(step_angle * (i + 1))
            y3 = r_bot * math.sin(step_angle * (i + 1))
            x4 = r_top * math.cos(step_angle * (i + 1))
            y4 = r_top * math.sin(step_angle * (i + 1))

            u3 = u_step * (i + 1)
            v3 = 1.0
            u4 = u3
            v4 = 0.0

            self.add_triangle(
                [[x1, y1, -h_2], [x2, y2, h_2], [x3, y3, -h_2]],
                texcoords=[[u1, v1], [u2, v2], [u3, v3]],
            )

            self.add_triangle(
                [[x3, y3, -h_2], [x2, y2, h_2], [x4, y4, h_2]],
                texcoords=[[u3, v3], [u2, v2], [u4, v4]],
            )

            self.add_triangle(
                [[x1, y1, -h_2], [0.0, 0.0, -h_2], [x3, y3, -h_2]],
                texcoords=[[u1, v1], [0.0, 0.0], [u3, v3]],
            )

            self.add_triangle(
                [[x4, y4, h_2], [0.0, 0.0, h_2], [x2, y2, h_2]],
                texcoords=[[u4, v4], [0.0, 0.0], [u2, v2]],
            )

        self.fix_normals()
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.Cylinder.build_cylinder"><code class="name flex">
<span>def <span class="ident">build_cylinder</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build_cylinder(self) -&gt; bool:
    step_angle = math.radians(360 / self._meridians)

    u_step = 1.0 / self._meridians
    r_bot = self._bottom_radius
    r_top = self._top_radius
    h_2 = self._height / 2.0
    for i in range(self._meridians):
        x1 = r_bot * math.cos(step_angle * i)
        y1 = r_bot * math.sin(step_angle * i)
        x2 = r_top * math.cos(step_angle * i)
        y2 = r_top * math.sin(step_angle * i)

        u1 = u_step * i
        v1 = 1.0
        u2 = u1
        v2 = 0.0

        x3 = r_bot * math.cos(step_angle * (i + 1))
        y3 = r_bot * math.sin(step_angle * (i + 1))
        x4 = r_top * math.cos(step_angle * (i + 1))
        y4 = r_top * math.sin(step_angle * (i + 1))

        u3 = u_step * (i + 1)
        v3 = 1.0
        u4 = u3
        v4 = 0.0

        self.add_triangle(
            [[x1, y1, -h_2], [x2, y2, h_2], [x3, y3, -h_2]],
            texcoords=[[u1, v1], [u2, v2], [u3, v3]],
        )

        self.add_triangle(
            [[x3, y3, -h_2], [x2, y2, h_2], [x4, y4, h_2]],
            texcoords=[[u3, v3], [u2, v2], [u4, v4]],
        )

        self.add_triangle(
            [[x1, y1, -h_2], [0.0, 0.0, -h_2], [x3, y3, -h_2]],
            texcoords=[[u1, v1], [0.0, 0.0], [u3, v3]],
        )

        self.add_triangle(
            [[x4, y4, h_2], [0.0, 0.0, h_2], [x2, y2, h_2]],
            texcoords=[[u4, v4], [0.0, 0.0], [u2, v2]],
        )

    self.fix_normals()
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.Mesh.absolute_vertices" href="#payton.scene.geometry.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.add_child" href="#payton.scene.geometry.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.add_triangle" href="#payton.scene.geometry.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.bounding_radius" href="#payton.scene.geometry.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.build" href="#payton.scene.geometry.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.clear_triangles" href="#payton.scene.geometry.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.destroy" href="#payton.scene.geometry.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.fix_normals" href="#payton.scene.geometry.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.has_vao" href="#payton.scene.geometry.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.position" href="#payton.scene.geometry.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.refresh" href="#payton.scene.geometry.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.render" href="#payton.scene.geometry.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_x" href="#payton.scene.geometry.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_y" href="#payton.scene.geometry.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_z" href="#payton.scene.geometry.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.scale" href="#payton.scene.geometry.Mesh.scale">scale</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.select" href="#payton.scene.geometry.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.to_absolute" href="#payton.scene.geometry.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.toggle_wireframe" href="#payton.scene.geometry.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.track" href="#payton.scene.geometry.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.update_matrix" href="#payton.scene.geometry.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.visible" href="#payton.scene.geometry.Object.visible">visible</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.yaw" href="#payton.scene.geometry.Object.yaw">yaw</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.Line"><code class="flex name class">
<span>class <span class="ident">Line</span></span>
<span>(</span><span>**args)</span>
</code></dt>
<dd>
<section class="desc"><p>Line object</p>
<p>Iniitalize line</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertices array for list of points.</dd>
<dt><strong><code>color</code></strong></dt>
<dd>Color of the line</dd>
</dl>
<p>Example use case:</p>
<pre><code>from payton.scene import Scene
from payton.scene.geometry import Line


scene = Scene()

line = Line(
    vertices=[
        [0, 0, 0],
        [0, 0, 1],
        [0.5, 0, 1.5],
        [1, 0, 1],
        [0, 0, 1],
        [1, 0, 0],
        [0, 0, 0],
        [1, 0, 1],
        [1, 0, 0],
    ]
)

scene.add_object("line", line)
scene.run()
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Line(Object):
    &#34;&#34;&#34;Line object
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Iniitalize line

        Args:
          vertices: Vertices array for list of points.
          color: Color of the line

        Example use case:

            .. include:: ../../examples/basics/17_line.py
        &#34;&#34;&#34;
        super().__init__(**args)
        self._vertices: VList = args.get(&#34;vertices&#34;, [])
        self.material.color = args.get(&#34;color&#34;, [1.0, 1.0, 1.0])

        self.static: bool = False  # Do not clear the vertices each time.
        self.material.display = WIREFRAME
        self.build_lines()

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle Wireframe overwrite to disable mode change&#34;&#34;&#34;
        pass

    def append(self, vertices: VList) -&gt; None:
        &#34;&#34;&#34;Append vertex or vertices to line.

        Args:
          vertice: Vertex array of points.
        &#34;&#34;&#34;

        diff = len(vertices)  # Number of vertices added
        last_index = len(self._vertices)
        self._vertices += vertices

        self._texcoords += [[0, 0]] * diff
        self._normals += [[0, 0, 0]] * diff
        self._vertex_count = len(self._vertices)
        indices = list(map(lambda x: x + last_index, range(diff)))
        self._indices.extend([indices])

        if self.has_vao:
            self._needs_update = True

    def build_lines(
        self,
        vertices: Optional[VList] = None,
        color: Optional[List[float]] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Build lines

        Build line vertex array object.
        &#34;&#34;&#34;
        if vertices is not None:
            self._vertices = vertices
        if color is not None:
            self.material.color = color
        self._vertex_count = len(self._vertices)
        for i in range(self._vertex_count - 1):
            self._indices.append([i, i + 1])

        for i in range(self._vertex_count):
            self._normals.append([0, 0, 0])
            self._texcoords.append([0, 0])

        if self.has_vao:
            # This is a dynamic object, destroying the object is not a good
            # idea so we just update the buffer here.
            self.build()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.Line.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, vertices)</span>
</code></dt>
<dd>
<section class="desc"><p>Append vertex or vertices to line.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertice</code></strong></dt>
<dd>Vertex array of points.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def append(self, vertices: VList) -&gt; None:
    &#34;&#34;&#34;Append vertex or vertices to line.

    Args:
      vertice: Vertex array of points.
    &#34;&#34;&#34;

    diff = len(vertices)  # Number of vertices added
    last_index = len(self._vertices)
    self._vertices += vertices

    self._texcoords += [[0, 0]] * diff
    self._normals += [[0, 0, 0]] * diff
    self._vertex_count = len(self._vertices)
    indices = list(map(lambda x: x + last_index, range(diff)))
    self._indices.extend([indices])

    if self.has_vao:
        self._needs_update = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Line.build_lines"><code class="name flex">
<span>def <span class="ident">build_lines</span></span>(<span>self, vertices=None, color=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Build lines</p>
<p>Build line vertex array object.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build_lines(
    self,
    vertices: Optional[VList] = None,
    color: Optional[List[float]] = None,
) -&gt; None:
    &#34;&#34;&#34;Build lines

    Build line vertex array object.
    &#34;&#34;&#34;
    if vertices is not None:
        self._vertices = vertices
    if color is not None:
        self.material.color = color
    self._vertex_count = len(self._vertices)
    for i in range(self._vertex_count - 1):
        self._indices.append([i, i + 1])

    for i in range(self._vertex_count):
        self._normals.append([0, 0, 0])
        self._texcoords.append([0, 0])

    if self.has_vao:
        # This is a dynamic object, destroying the object is not a good
        # idea so we just update the buffer here.
        self.build()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Line.toggle_wireframe"><code class="name flex">
<span>def <span class="ident">toggle_wireframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Toggle Wireframe overwrite to disable mode change</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def toggle_wireframe(self) -&gt; None:
    &#34;&#34;&#34;Toggle Wireframe overwrite to disable mode change&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.Object.absolute_vertices" href="#payton.scene.geometry.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.Object.add_child" href="#payton.scene.geometry.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.Object.bounding_radius" href="#payton.scene.geometry.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.Object.build" href="#payton.scene.geometry.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.Object.destroy" href="#payton.scene.geometry.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.Object.has_vao" href="#payton.scene.geometry.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.Object.position" href="#payton.scene.geometry.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.Object.refresh" href="#payton.scene.geometry.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.Object.render" href="#payton.scene.geometry.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_x" href="#payton.scene.geometry.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_y" href="#payton.scene.geometry.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_z" href="#payton.scene.geometry.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.Object.select" href="#payton.scene.geometry.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.Object.to_absolute" href="#payton.scene.geometry.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.Object.track" href="#payton.scene.geometry.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.Object.update_matrix" href="#payton.scene.geometry.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.Object.visible" href="#payton.scene.geometry.Object.visible">visible</a></code></li>
<li><code><a title="payton.scene.geometry.Object.yaw" href="#payton.scene.geometry.Object.yaw">yaw</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.Mesh"><code class="flex name class">
<span>class <span class="ident">Mesh</span></span>
<span>(</span><span>**args)</span>
</code></dt>
<dd>
<section class="desc"><p>Mesh Object</p>
<p>Mesh is almost like the Object except with some extra methods to make
things easier. If you want to have custom geometries/shapes, it is
better to extend <a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh"><code>Mesh</code></a> instead of
<a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object"><code>Object</code></a>. Because Mesh will give you better
and easier constructing capabilities such as adding triangles on the fly
or sub-division or cutting and so forth. It is a way of designing objects
by code.</p>
<p>Example use case:</p>
<pre><code>import os
from payton.scene import Scene
from payton.scene.geometry import Mesh


scene = Scene()
mesh = Mesh()
mesh.add_triangle(
    [[0, 0, 0], [2, 0, 0], [2, 2, 0]], texcoords=[[0, 0], [1, 0], [1, 1]]
)
mesh.add_triangle(
    [[0, 0, 0], [2, 2, 0], [0, 2, 0]], texcoords=[[0, 0], [1, 1], [0, 1]]
)
texture_file = os.path.join(os.path.dirname(__file__), "cube.png")
mesh.material.texture = texture_file
scene.add_object("mesh", mesh)
scene.run()
</code></pre>
<p>Initialize the basic object properties.</p>
<h2 id="properties">Properties</h2>
<dl>
<dt><strong><code>children</code></strong></dt>
<dd>Children hash for object. Each child object follows parent
object. They take their parent object as origin and their
coordinate system is relative to their parent. This
behaviour resembles stars, planets and their moons.</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material definitions of the object.</dd>
<dt><strong><code>matrix</code></strong></dt>
<dd>Matrix definition of the object. This is a 4x4 Uniform Matrix
But data is set as an array for easier transformations. First
4 decimals are "Left" vector, Second 4 are "Direction", Third
4 are "Up" and last four decimals are "Position" vectors.</dd>
</dl>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track_motion</code></strong></dt>
<dd>Track object motion (default: false). Object tracking
is time independent. It just saves the object matrix
for every change. Uses matrix position for drawing the
motion path.</dd>
<dt><strong><code>static</code></strong></dt>
<dd>(Default <code>True</code>) Indicates if object geometry is expected
to be changed in the future. If object is not static, then
its' vertex buffer object references and vertex informations
will not be deleted to be used for future reference.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the object (optional, default '') Note that, when
object gets added to a Scene with a name, Scene will assign
that name to the object, overwriting any existing name of the
object.</dd>
<dt><strong><code>visible</code></strong></dt>
<dd>Is this object visible at the scene, default: True. To hid
an object, you can call <code>object.hide()</code> and to show it again
use: <code>object.show()</code></dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Mesh(Object):
    &#34;&#34;&#34;Mesh Object

    Mesh is almost like the Object except with some extra methods to make
    things easier. If you want to have custom geometries/shapes, it is
    better to extend `payton.scene.geometry.Mesh` instead of
    `payton.scene.geometry.Object`. Because Mesh will give you better
    and easier constructing capabilities such as adding triangles on the fly
    or sub-division or cutting and so forth. It is a way of designing objects
    by code.


    Example use case:

        .. include:: ../../examples/basics/09_mesh.py
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        super().__init__(**args)
        self.static = False

    def clear_triangles(self) -&gt; None:
        &#34;&#34;&#34;Clear all triangles inside the Mesh&#34;&#34;&#34;
        self._vertices = []
        self._indices = []
        self._normals = []
        self._texcoords = []
        self._vertex_colors = []
        self.refresh()

    def fix_normals(self) -&gt; None:
        &#34;&#34;&#34;Try to re-calculate Mesh normals, if your object has already perfect
        normals, do not call this method&#34;&#34;&#34;
        self._normals = []
        for face in self._indices:
            v1, v2, v3 = (
                self._vertices[face[0]],
                self._vertices[face[1]],
                self._vertices[face[2]],
            )
            normal = plane_normal(v1, v2, v3)
            self._normals.extend([normal, normal, normal])

    def scale(self, x: float, y: float, z: float) -&gt; None:
        &#34;&#34;&#34;Scale Mesh by given factors

        Note: This does not create a scale matrix and multiply existing matrix
              with it. Instead, it will scale the vertices by given factors.
        &#34;&#34;&#34;
        self._vertices = list(
            map(lambda v: [v[0] * x, v[1] * y, v[2] * z], self._vertices)
        )
        self.fix_normals()
        self.refresh()

    def add_triangle(
        self,
        vertices: VList,
        normals: Optional[VList] = None,
        texcoords: Optional[VList] = None,
        colors: Optional[VList] = None,
    ) -&gt; None:
        &#34;&#34;&#34;Add triangle to Mesh

        Args:
          vertices: Vertices of the triangle. This is required. Ex:
                    `[[0, 0, 0], [2, 0, 0], [1, 1, 0]]`
          normals: Normals of the triangle. _(When left as None, Payton will
                   calculate the surface normal based on vertices and assign
                   it per given vertex.)_
          texcoords: Texture UV coordinates.
          colors: Per vertex colors (optional)
        &#34;&#34;&#34;
        if len(vertices) != 3:
            logging.error(&#34;A triangle must have 3 vertices&#34;)
            return

        if normals is not None and len(normals) != 3:
            logging.error(&#34;There must be one normal per vertex&#34;)
            return

        if texcoords is not None and len(texcoords) != 3:
            logging.error(&#34;There must be one texcoord per vertex&#34;)
            return

        if normals is None:
            v1, v2, v3 = vertices[0], vertices[1], vertices[2]
            normal = plane_normal(v1, v2, v3)
            normals = [normal, normal, normal]
        if texcoords is None:
            texcoords = [[0, 0], [1, 0], [1, 1]]
        if colors:
            for color in colors:
                self._vertex_colors.append(color)

        for v in vertices:
            self._vertices.append(v)

        i = len(self._indices) * 3
        self._indices.append([i, i + 1, i + 2])
        for normal in normals:
            self._normals.append(normal)
        for t in texcoords:
            self._texcoords.append(t)
        self.refresh()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.Cube" href="#payton.scene.geometry.Cube">Cube</a></li>
<li><a title="payton.scene.geometry.Sphere" href="#payton.scene.geometry.Sphere">Sphere</a></li>
<li><a title="payton.scene.geometry.Cylinder" href="#payton.scene.geometry.Cylinder">Cylinder</a></li>
<li><a title="payton.scene.geometry.Plane" href="#payton.scene.geometry.Plane">Plane</a></li>
<li><a title="payton.scene.gui.Shape2D" href="gui.html#payton.scene.gui.Shape2D">Shape2D</a></li>
<li><a title="payton.scene.wavefront.Wavefront" href="wavefront.html#payton.scene.wavefront.Wavefront">Wavefront</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.Mesh.add_triangle"><code class="name flex">
<span>def <span class="ident">add_triangle</span></span>(<span>self, vertices, normals=None, texcoords=None, colors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add triangle to Mesh</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertices of the triangle. This is required. Ex:
<code>[[0, 0, 0], [2, 0, 0], [1, 1, 0]]</code></dd>
<dt><strong><code>normals</code></strong></dt>
<dd>Normals of the triangle. <em>(When left as None, Payton will
calculate the surface normal based on vertices and assign
it per given vertex.)</em></dd>
<dt><strong><code>texcoords</code></strong></dt>
<dd>Texture UV coordinates.</dd>
<dt><strong><code>colors</code></strong></dt>
<dd>Per vertex colors (optional)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_triangle(
    self,
    vertices: VList,
    normals: Optional[VList] = None,
    texcoords: Optional[VList] = None,
    colors: Optional[VList] = None,
) -&gt; None:
    &#34;&#34;&#34;Add triangle to Mesh

    Args:
      vertices: Vertices of the triangle. This is required. Ex:
                `[[0, 0, 0], [2, 0, 0], [1, 1, 0]]`
      normals: Normals of the triangle. _(When left as None, Payton will
               calculate the surface normal based on vertices and assign
               it per given vertex.)_
      texcoords: Texture UV coordinates.
      colors: Per vertex colors (optional)
    &#34;&#34;&#34;
    if len(vertices) != 3:
        logging.error(&#34;A triangle must have 3 vertices&#34;)
        return

    if normals is not None and len(normals) != 3:
        logging.error(&#34;There must be one normal per vertex&#34;)
        return

    if texcoords is not None and len(texcoords) != 3:
        logging.error(&#34;There must be one texcoord per vertex&#34;)
        return

    if normals is None:
        v1, v2, v3 = vertices[0], vertices[1], vertices[2]
        normal = plane_normal(v1, v2, v3)
        normals = [normal, normal, normal]
    if texcoords is None:
        texcoords = [[0, 0], [1, 0], [1, 1]]
    if colors:
        for color in colors:
            self._vertex_colors.append(color)

    for v in vertices:
        self._vertices.append(v)

    i = len(self._indices) * 3
    self._indices.append([i, i + 1, i + 2])
    for normal in normals:
        self._normals.append(normal)
    for t in texcoords:
        self._texcoords.append(t)
    self.refresh()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Mesh.clear_triangles"><code class="name flex">
<span>def <span class="ident">clear_triangles</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Clear all triangles inside the Mesh</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def clear_triangles(self) -&gt; None:
    &#34;&#34;&#34;Clear all triangles inside the Mesh&#34;&#34;&#34;
    self._vertices = []
    self._indices = []
    self._normals = []
    self._texcoords = []
    self._vertex_colors = []
    self.refresh()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Mesh.fix_normals"><code class="name flex">
<span>def <span class="ident">fix_normals</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Try to re-calculate Mesh normals, if your object has already perfect
normals, do not call this method</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def fix_normals(self) -&gt; None:
    &#34;&#34;&#34;Try to re-calculate Mesh normals, if your object has already perfect
    normals, do not call this method&#34;&#34;&#34;
    self._normals = []
    for face in self._indices:
        v1, v2, v3 = (
            self._vertices[face[0]],
            self._vertices[face[1]],
            self._vertices[face[2]],
        )
        normal = plane_normal(v1, v2, v3)
        self._normals.extend([normal, normal, normal])</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Mesh.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, x, y, z)</span>
</code></dt>
<dd>
<section class="desc"><p>Scale Mesh by given factors</p>
<p>Note: This does not create a scale matrix and multiply existing matrix
with it. Instead, it will scale the vertices by given factors.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def scale(self, x: float, y: float, z: float) -&gt; None:
    &#34;&#34;&#34;Scale Mesh by given factors

    Note: This does not create a scale matrix and multiply existing matrix
          with it. Instead, it will scale the vertices by given factors.
    &#34;&#34;&#34;
    self._vertices = list(
        map(lambda v: [v[0] * x, v[1] * y, v[2] * z], self._vertices)
    )
    self.fix_normals()
    self.refresh()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.Object.absolute_vertices" href="#payton.scene.geometry.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.Object.add_child" href="#payton.scene.geometry.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.Object.bounding_radius" href="#payton.scene.geometry.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.Object.build" href="#payton.scene.geometry.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.Object.destroy" href="#payton.scene.geometry.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.Object.has_vao" href="#payton.scene.geometry.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.Object.position" href="#payton.scene.geometry.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.Object.refresh" href="#payton.scene.geometry.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.Object.render" href="#payton.scene.geometry.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_x" href="#payton.scene.geometry.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_y" href="#payton.scene.geometry.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_z" href="#payton.scene.geometry.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.Object.select" href="#payton.scene.geometry.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.Object.to_absolute" href="#payton.scene.geometry.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.Object.toggle_wireframe" href="#payton.scene.geometry.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.Object.track" href="#payton.scene.geometry.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.Object.update_matrix" href="#payton.scene.geometry.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.Object.visible" href="#payton.scene.geometry.Object.visible">visible</a></code></li>
<li><code><a title="payton.scene.geometry.Object.yaw" href="#payton.scene.geometry.Object.yaw">yaw</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.Object"><code class="flex name class">
<span>class <span class="ident">Object</span></span>
<span>(</span><span>**args)</span>
</code></dt>
<dd>
<section class="desc"><p>Main Payton Object.</p>
<p>This is an abstract class to define common properties and methods between
Mesh / Cube / Sphere/ Shape2D / PointCloud and etc.</p>
<p>Objects are not actually built as 3D vertex arrays until they are rendered.
Render function calls <code>build</code> function if needed. Build function creates
the OpenGL Vertex Array Object. VAO is a static data so, once the object
is built, changing vertices or indices will not take effect at the scene.</p>
<p>You need to call <a title="payton.scene.geometry.Object.build" href="#payton.scene.geometry.Object.build"><code>Object.build()</code></a> function to refresh
Vertex Array Object.</p>
<p>OpenGL can not magically extend a memory buffer, so for every new vertices
added to the object, OpenGL needs to re-create the buffer area. This is
not an efficitient technique if number of vertices increase in time.
As a result Payton allocates buffer for 500 vertices in the beginning and
uses a part of it. If object exceeds 500 vertices, a new buffer is created
with 500 more vertices, copies existing vertices to new and old buffer
is deleted.</p>
<p>Initialize the basic object properties.</p>
<h2 id="properties">Properties</h2>
<dl>
<dt><strong><code>children</code></strong></dt>
<dd>Children hash for object. Each child object follows parent
object. They take their parent object as origin and their
coordinate system is relative to their parent. This
behaviour resembles stars, planets and their moons.</dd>
<dt><strong><code>material</code></strong></dt>
<dd>Material definitions of the object.</dd>
<dt><strong><code>matrix</code></strong></dt>
<dd>Matrix definition of the object. This is a 4x4 Uniform Matrix
But data is set as an array for easier transformations. First
4 decimals are "Left" vector, Second 4 are "Direction", Third
4 are "Up" and last four decimals are "Position" vectors.</dd>
</dl>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>track_motion</code></strong></dt>
<dd>Track object motion (default: false). Object tracking
is time independent. It just saves the object matrix
for every change. Uses matrix position for drawing the
motion path.</dd>
<dt><strong><code>static</code></strong></dt>
<dd>(Default <code>True</code>) Indicates if object geometry is expected
to be changed in the future. If object is not static, then
its' vertex buffer object references and vertex informations
will not be deleted to be used for future reference.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the object (optional, default '') Note that, when
object gets added to a Scene with a name, Scene will assign
that name to the object, overwriting any existing name of the
object.</dd>
<dt><strong><code>visible</code></strong></dt>
<dd>Is this object visible at the scene, default: True. To hid
an object, you can call <code>object.hide()</code> and to show it again
use: <code>object.show()</code></dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Object(object):
    &#34;&#34;&#34;Main Payton Object.

    This is an abstract class to define common properties and methods between
    Mesh / Cube / Sphere/ Shape2D / PointCloud and etc.

    Objects are not actually built as 3D vertex arrays until they are rendered.
    Render function calls `build` function if needed. Build function creates
    the OpenGL Vertex Array Object. VAO is a static data so, once the object
    is built, changing vertices or indices will not take effect at the scene.

    You need to call `payton.scene.geometry.Object.build` function to refresh
    Vertex Array Object.

    OpenGL can not magically extend a memory buffer, so for every new vertices
    added to the object, OpenGL needs to re-create the buffer area. This is
    not an efficitient technique if number of vertices increase in time.
    As a result Payton allocates buffer for 500 vertices in the beginning and
    uses a part of it. If object exceeds 500 vertices, a new buffer is created
    with 500 more vertices, copies existing vertices to new and old buffer
    is deleted.

    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;
        Initialize the basic object properties.

        Properties:
          children: Children hash for object. Each child object follows parent
                    object. They take their parent object as origin and their
                    coordinate system is relative to their parent. This
                    behaviour resembles stars, planets and their moons.
          material: Material definitions of the object.
          matrix: Matrix definition of the object. This is a 4x4 Uniform Matrix
                  But data is set as an array for easier transformations. First
                  4 decimals are &#34;Left&#34; vector, Second 4 are &#34;Direction&#34;, Third
                  4 are &#34;Up&#34; and last four decimals are &#34;Position&#34; vectors.

        Args:
          track_motion: Track object motion (default: false). Object tracking
                        is time independent. It just saves the object matrix
                        for every change. Uses matrix position for drawing the
                        motion path.
          static: (Default `True`) Indicates if object geometry is expected
                  to be changed in the future. If object is not static, then
                  its&#39; vertex buffer object references and vertex informations
                  will not be deleted to be used for future reference.
          name: Name of the object (optional, default &#39;&#39;) Note that, when
                object gets added to a Scene with a name, Scene will assign
                that name to the object, overwriting any existing name of the
                object.
          visible: Is this object visible at the scene, default: True. To hid
                   an object, you can call `object.hide()` and to show it again
                   use: `object.show()`
        &#34;&#34;&#34;
        self.children: Dict[str, Object] = {}
        self.material: Material = Material()
        self.static = args.get(&#34;static&#34;, True)
        self.name = args.get(&#34;name&#34;, &#34;&#34;)
        self._visible = args.get(&#34;visible&#34;, True)
        self.matrix: VList = [
            [1.0, 0.0, 0.0, 0.0],
            [0.0, 1.0, 0.0, 0.0],
            [0.0, 0.0, 1.0, 0.0],
            [0.0, 0.0, 0.0, 1.0],
        ]
        # Object vertices. Each vertex has 3 decimals (X, Y, Z). Vertices
        # are continuous. [X, Y, Z, X, Y, Z, X, Y, Z, X, ... ]
        #                  -- 1 --  -- 2 --  -- 3 --  -- 4 --

        self._vertices: VList = []  # Object vertex list
        self._normals: List[
            List[float]
        ] = []  # Vertex normals, 1 normal coordinate for 1 Vertex
        self._texcoords: List[
            List[float]
        ] = []  # Texture coordinates, 1 coordinate per Vertex
        self._vertex_colors: List[
            List[float]
        ] = []  # per-vertex colors, optional.
        self._has_vertex_colors: bool = False  # flag for using vertex colors

        # Vertices do not mean anything unless we define how to use them.
        # For instance, 3 vertices make a triangle or 2 vertices define a line
        # order of vertices are defined in self._indices.
        self._indices: IList = []
        self._vertex_count: int = 0  # Number of vertices to report to OpenGL.

        # This is an optimization technique for dynamic objects where there are
        # increasing number of vertices. We allocate some buffer before-hand
        # and if we fill all of it, we resize it.
        self._buffer_size: float = 500 * 12
        self._t_buffer_size: float = 500 * 8
        self._model_matrix: np.ndarray = []  # Model matrix.
        # Check if buffer size allocated for the object has changed.
        self._buffer_size_changed: bool = True
        self._t_buffer_size_changed: bool = True

        # Track object motion
        self.track_motion = args.get(&#34;track_motion&#34;, False)
        # Motion path, stores every matrix change.
        self._motion_path: List[VList] = []
        if not isinstance(self, Line):
            # _motion_path_line is used to display the motion path in scene
            self._motion_path_line = Line()
        self._previous_matrix: Union[np.ndarray, None] = None

        # For raycast tests - bounding radius is the radius of the bounding
        # sphere.
        self._bounding_radius: float = 0
        self._bounding_box: VList = []
        self._selected: bool = False

        # Vertex Array Object pointer
        self._vao: int = -1
        self._needs_update: bool = False  # Object geometry has changed.
        self._hit: bool = False
        &#34;&#34;&#34; I personally prefer not to delete vbos as in some cases I need to
        # refer to VBOs to update them partially. I don&#39;t want to loose
        # their reference and make things harder. I am not naming them
        # anyways.
        &#34;&#34;&#34;
        self._vbos: List[int] = []

    def refresh(self) -&gt; None:
        &#34;&#34;&#34;Refresh object

        Forces object to get built again
        &#34;&#34;&#34;
        self._needs_update = True

    def yaw(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Yaw - Rotate around Z Axis

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([0, 0, 1], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def rotate_around_z(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Rotate around Z axis, alias for yaw function&#34;&#34;&#34;
        return self.yaw(angle)

    def rotate_around_x(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Pitch - Rotate around X axis

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([1, 0, 0], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def rotate_around_y(self, angle: float) -&gt; None:
        &#34;&#34;&#34;Roll - Rotate around Y Axis (Direction)

        Args:
          angle: Angle in radians
        &#34;&#34;&#34;
        rot_matrix = create_rotation_matrix([0, 1, 0], angle)
        local_matrix = np.array(self.matrix, dtype=np.float32)
        local_matrix = rot_matrix.dot(local_matrix)
        self.matrix = local_matrix.tolist()

    def select(self, start: np.ndarray, vector: np.ndarray) -&gt; bool:
        &#34;&#34;&#34;Select test for object using bounding Sphere.

        Note: this method is not 100% accurate as it is based on a rough
        assumption. Sphere area will be larger than actual object.

        If you want to have a more accurate way to handle this, try
        using raycast triangle intersect

        Args:
          start: Starting point of the ray (such as eye position)
          vector: Ray direction. This is not the end point of a line! This is
        a unit vector showing the ray direction.
        &#34;&#34;&#34;
        self._selected = raycast_sphere_intersect(
            start,
            vector,
            np.array(self.matrix[3], dtype=np.float32),
            self._bounding_radius,
        )

        for obj in self.children:
            x = self.children[obj].select(start, vector)
            if not self._selected and x:
                self._selected = True

        return self._selected

    def destroy(self) -&gt; bool:
        &#34;&#34;&#34;
        Destroy objects self

        Returns: bool
        &#34;&#34;&#34;
        if self.has_vao:
            glDeleteVertexArrays(1, [self._vao])
            self._vao = -1
        return True

    def update_matrix(
        self, parent_matrix: Optional[np.ndarray] = None
    ) -&gt; None:
        &#34;&#34;&#34;Update matrix

        Turn object matrix into numpy array.

        Args:
          parent_matrix: Parent objects matrix
        &#34;&#34;&#34;
        # Turn matrix into numpy array. Numpy arrays are C Type arrays
        # suitable for OpenGL Pipeline
        self._model_matrix = np.array(self.matrix, dtype=np.float32)

        # When there is a parent object, child object follows parents matrix
        if parent_matrix is not None and len(parent_matrix) &gt; 0:
            self._model_matrix = parent_matrix.dot(self._model_matrix)

    def track(self) -&gt; bool:
        &#34;&#34;&#34;
        Track object motion

        Returns:
          bool
        &#34;&#34;&#34;
        if not self.track_motion:
            return False
        if self._previous_matrix == self.matrix[3]:
            return True

        # Add the new matrix to motion path records
        self._motion_path.append(self.matrix)
        # Add the matrix position to motion math line for visualisation
        if self._motion_path_line is not None:
            self._motion_path_line.append(
                [[self.matrix[3][0], self.matrix[3][1], self.matrix[3][2]]]
            )

        # Python trick here! need to .copy or it will pass reference.
        self._previous_matrix = self.matrix[3].copy()
        return True

    @property
    def has_vao(self) -&gt; bool:
        &#34;&#34;&#34;Check if this object has an active Vertex Array Object

        Returns:
            bool
        &#34;&#34;&#34;
        return self._vao &gt; -1

    @property
    def visible(self) -&gt; bool:
        &#34;&#34;&#34;Check if object is visible&#34;&#34;&#34;
        return self._visible

    def show(self) -&gt; None:
        self._visible = True

    def hide(self) -&gt; None:
        self._visible = False

    def render(
        self,
        proj: np.ndarray,
        view: np.ndarray,
        lights: List[Light],
        parent_matrix: Optional[np.ndarray] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        Virtual function for rendering the object. Some objects can overwrite
        this function.

        Args:
          proj: Camera projection matrix.
          view: Camera location/view matrix.
          lights: Light objects in the scene
          parent_matrix: Parent matrix is the matrix of the parent. Parent can
                         be the scene itself or another object. In case of
                         another object, object will position itself relative
                         to its parent object.
        &#34;&#34;&#34;
        if not self._visible:
            return

        if not self.has_vao or self._needs_update:
            self.build()

        if self._vertex_count == 0:
            return

        self.update_matrix(parent_matrix=parent_matrix)
        self.track()

        # Material shading mode.
        mode = None
        if self._has_vertex_colors:
            mode = Shader.PER_VERTEX_COLOR

        self.material.render(proj, view, self._model_matrix, lights, mode)

        # Actual rendering
        if glIsVertexArray(self._vao):
            glBindVertexArray(self._vao)
            pmode = GL_LINE
            primitive = GL_LINE_STRIP
            if self.material.display == SOLID:
                pmode = GL_FILL
                primitive = GL_TRIANGLES
            if self.material.display == POINTS:
                pmode = GL_POINT
                primitive = GL_POINTS
            glPolygonMode(GL_FRONT_AND_BACK, pmode)

            glDrawElements(
                primitive,
                self._vertex_count,
                GL_UNSIGNED_INT,
                ctypes.c_void_p(0),
            )
            if pmode != GL_FILL:
                glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
            glBindVertexArray(0)

        # End using the shader program.
        self.material.end()

        # Render motion path
        if self.track_motion:
            self._motion_path_line.render(proj, view, lights, parent_matrix)

        # render children
        for child in self.children:
            self.children[child].render(proj, view, lights, self._model_matrix)

    @property
    def position(self) -&gt; List[float]:
        &#34;&#34;&#34;Get position of the Object.

        Return matrix position list

        Returns:
          List[float]
        &#34;&#34;&#34;
        return self.matrix[3][:3]

    @position.setter
    def position(self, pos: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Shortcut function for explicitly modifying matrix indices.

        Basically just sets x, y, z of the matrix. Does not change its
        direction or up vectors.

        Args:
          pos: Position list ([x, y, z])
        &#34;&#34;&#34;
        if len(pos) == 2:
            pos = [pos[0], pos[1], 0.0]
        self.matrix[3][0] = pos[0]
        self.matrix[3][1] = pos[1]
        self.matrix[3][2] = pos[2]

    def add_child(self, name: str, obj: Type[&#34;Object&#34;]) -&gt; bool:
        &#34;&#34;&#34;Add child to this object.

        In a basic example:

            .. include:: ../../examples/basics/05_children.py

        Args:
          name: Name of the object, must be unique within its siblings
          obj: Object. Must be an instance of `payton.scene.geometry.Object`

        Returns:
          bool: False in case of an error
        &#34;&#34;&#34;
        if name in self.children:
            logging.error(f&#34;Name {name} exists in object children&#34;)
            return False
        if not isinstance(obj, Object):
            logging.error(&#34;Object type is not valid&#34;)
            return False
        self.children[name] = obj
        return True

    def to_absolute(self, coordinates: List[float]) -&gt; List[float]:
        &#34;&#34;&#34;
        Return local coordinates (tuple, list) into absolute coordinates in
        space.

        Args:
          coordinates: List[float] (x, y, z)

        Returns:
          List[float] (x&#39;, y&#39;, z&#39;)
        &#34;&#34;&#34;
        return vector_transform(coordinates, self.matrix)

    def absolute_vertices(self) -&gt; Iterator[List[float]]:
        &#34;&#34;&#34;Return a map of all local vertices as absolute coordinates.

        Imagine that object B is a child of object A. In this case, B will
        always stand (follow) relative to A. If you want to know the exact
        world coordinates of all vertices in B, this method will return them.

        **Important!** This is a costly operation so use with caution!

        Returns:
          map(List[List[float]])
        &#34;&#34;&#34;
        return map(lambda v: self.to_absolute(v), self._vertices)

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle wireframe view of the Object&#34;&#34;&#34;
        d = self.material.display
        d += 1
        d = d % 3

        self.material.display = d
        for n in self.children:
            self.children[n].toggle_wireframe()

    def _calc_bounds(self) -&gt; float:
        &#34;&#34;&#34;Calculate the bounding sphere radius

        Returns:
          float
        &#34;&#34;&#34;
        vertices = np.array(self._vertices, dtype=np.float32)

        bmin: Optional[List[float]] = None
        bmax: Optional[List[float]] = None
        for v in vertices:
            if bmin is None:
                bmin = [0, 0, 0]
                bmin[0], bmin[1], bmin[2] = v[0], v[1], v[2]
            if bmax is None:
                bmax = [0, 0, 0]
                bmax[0], bmax[1], bmax[2] = v[0], v[1], v[2]
            if v[0] &lt; bmin[0]:
                bmin[0] = v[0]
            if v[1] &lt; bmin[1]:
                bmin[1] = v[1]
            if v[2] &lt; bmin[2]:
                bmin[2] = v[2]
            if v[0] &gt; bmax[0]:
                bmax[0] = v[0]
            if v[1] &gt; bmax[1]:
                bmax[1] = v[1]
            if v[2] &gt; bmax[2]:
                bmax[2] = v[2]

            d = pyrr.vector3.length(v)
            if d &gt; self._bounding_radius:
                self._bounding_radius = d
        if bmin is None:
            bmin = [0.0, 0.0, 0.0]
        if bmax is None:
            bmax = [0.0, 0.0, 0.0]
        self._bounding_box = [bmin, bmax]
        return self._bounding_radius

    @property
    def bounding_radius(self) -&gt; float:
        &#34;&#34;&#34;Return bounding radius

        Note: This property function *WILL NOT* update the previously
        calculated value. If you add vertices to the object, you must call
        `payton.scene.geometry.Object.refresh` function to get radius
        and the whole object updated.

        Returns:
          float
        &#34;&#34;&#34;

        if self._bounding_radius &gt; 0:
            return self._bounding_radius
        return self._calc_bounds()

    def build(self) -&gt; bool:
        &#34;&#34;&#34;
        Build OpenGL Vertex Array for the object

        This function gets automatically called if `self._vao` does not
        exists in the first render cycle. Once the vba is built,
        geometry changes or material display mode changes will not be
        automatically effected. So, in every geometry or display mode
        change, a `build` call is necessary.

        if `self.static` is `True`, then system assumes that another update
        call is not expected, thus frees `_normals&#39;, `_textcoords`,
        `_vertices` and `_indices` lists to free memory.
        So in this case, calling `build` function twice will result with
        an invisible object (will not be drawn)

        Returns:
          bool
        &#34;&#34;&#34;
        if len(self._indices) == 0:
            return False

        # If we don&#39;t have a VAO yet, we need to create one
        if not self.has_vao:
            # Generate Vertex Array
            self._vao = glGenVertexArrays(1)
            # We need 5 buffers (vertex, normal, texcoord, color, indices)
            self._vbos = glGenBuffers(5)
            glBindVertexArray(self._vao)
            # Material shader must be built when there is an active binding
            # to vertex array
            self.material.build_shader()
        else:
            # Ok, we already have vertex array object, just bind it to modify
            glBindVertexArray(self._vao)

        # Turn python arrays into C type arrays using Numpy.
        # This is required for OpenGL. Python memory model is a bit
        # different than raw memory model of C (OpenGL)
        vertices = np.array(self._vertices, dtype=np.float32).flatten()
        normals = np.array(self._normals, dtype=np.float32).flatten()
        texcoords = np.array(self._texcoords, dtype=np.float32).flatten()
        colors = np.array(self._vertex_colors, dtype=np.float32).flatten()
        indices = np.array(self._indices, dtype=np.int32).flatten()
        self._calc_bounds()

        # OpenGL allocates buffers in different mechanisms between
        # STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL
        # will assume that object buffer will not change and allocate it in a
        # more suitable way.
        draw = GL_STATIC_DRAW
        if not self.static:
            draw = GL_DYNAMIC_DRAW

        # Buffer overflow, we need more space.
        if self._buffer_size &lt; vertices.nbytes:
            self._buffer_size = vertices.nbytes
            self._buffer_size_changed = True
        if self._t_buffer_size &lt; texcoords.nbytes:
            self._t_buffer_size = texcoords.nbytes
            self._t_buffer_size_changed = True

        # Bind Vertices
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[0])
        glEnableVertexAttribArray(0)  # shader layout location
        glVertexAttribPointer(0, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        if self._buffer_size_changed:
            # glBufferData creates a new data area
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, vertices, draw)
        else:
            # glBufferSubData just replaces memory area in buffer so it is
            # much more efficient way to handle things.
            glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.nbytes, vertices)

        # Bind Normals
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[1])
        glEnableVertexAttribArray(1)  # shader layout location
        glVertexAttribPointer(1, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        if self._buffer_size_changed:
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, normals, draw)
        else:
            glBufferSubData(GL_ARRAY_BUFFER, 0, normals.nbytes, normals)

        # Bind TexCoords
        if len(self._texcoords) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[2])
            glEnableVertexAttribArray(2)  # shader layout location
            glVertexAttribPointer(2, 2, GL_FLOAT, False, 0, ctypes.c_void_p(0))
            if self._t_buffer_size_changed:
                glBufferData(
                    GL_ARRAY_BUFFER, self._t_buffer_size, texcoords, draw
                )
            else:
                glBufferSubData(
                    GL_ARRAY_BUFFER, 0, texcoords.nbytes, texcoords
                )

        # Bind Vertex Colors
        if len(self._vertex_colors) == len(self._vertices):
            glBindBuffer(GL_ARRAY_BUFFER, self._vbos[4])
            glEnableVertexAttribArray(3)  # shader layout location
            glVertexAttribPointer(3, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
            self._has_vertex_colors = True
            if self._buffer_size_changed:
                glBufferData(GL_ARRAY_BUFFER, self._buffer_size, colors, draw)
            else:
                glBufferSubData(GL_ARRAY_BUFFER, 0, colors.nbytes, colors)

        self._buffer_size_changed = False
        self._t_buffer_size_changed = False

        # Bind Indices
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self._vbos[3])
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.nbytes, indices, draw)
        self._vertex_count = len(indices)

        glBindVertexArray(0)
        glBindBuffer(GL_ARRAY_BUFFER, 0)

        if self.static:
            # we can clear this data to free some more memory
            glDeleteBuffers(4, self._vbos)
            self._vbos = []

        self._needs_update = False

        return True</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.Line" href="#payton.scene.geometry.Line">Line</a></li>
<li><a title="payton.scene.geometry.PointCloud" href="#payton.scene.geometry.PointCloud">PointCloud</a></li>
<li><a title="payton.scene.gui.Hud" href="gui.html#payton.scene.gui.Hud">Hud</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="payton.scene.geometry.Object.bounding_radius"><code class="name">var <span class="ident">bounding_radius</span></code></dt>
<dd>
<section class="desc"><p>Return bounding radius</p>
<p>Note: This property function <em>WILL NOT</em> update the previously
calculated value. If you add vertices to the object, you must call
<a title="payton.scene.geometry.Object.refresh" href="#payton.scene.geometry.Object.refresh"><code>Object.refresh()</code></a> function to get radius
and the whole object updated.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def bounding_radius(self) -&gt; float:
    &#34;&#34;&#34;Return bounding radius

    Note: This property function *WILL NOT* update the previously
    calculated value. If you add vertices to the object, you must call
    `payton.scene.geometry.Object.refresh` function to get radius
    and the whole object updated.

    Returns:
      float
    &#34;&#34;&#34;

    if self._bounding_radius &gt; 0:
        return self._bounding_radius
    return self._calc_bounds()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.has_vao"><code class="name">var <span class="ident">has_vao</span></code></dt>
<dd>
<section class="desc"><p>Check if this object has an active Vertex Array Object</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def has_vao(self) -&gt; bool:
    &#34;&#34;&#34;Check if this object has an active Vertex Array Object

    Returns:
        bool
    &#34;&#34;&#34;
    return self._vao &gt; -1</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.position"><code class="name">var <span class="ident">position</span></code></dt>
<dd>
<section class="desc"><p>Get position of the Object.</p>
<p>Return matrix position list</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code>[<code>float</code>]</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def position(self) -&gt; List[float]:
    &#34;&#34;&#34;Get position of the Object.

    Return matrix position list

    Returns:
      List[float]
    &#34;&#34;&#34;
    return self.matrix[3][:3]</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.visible"><code class="name">var <span class="ident">visible</span></code></dt>
<dd>
<section class="desc"><p>Check if object is visible</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">@property
def visible(self) -&gt; bool:
    &#34;&#34;&#34;Check if object is visible&#34;&#34;&#34;
    return self._visible</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.Object.absolute_vertices"><code class="name flex">
<span>def <span class="ident">absolute_vertices</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a map of all local vertices as absolute coordinates.</p>
<p>Imagine that object B is a child of object A. In this case, B will
always stand (follow) relative to A. If you want to know the exact
world coordinates of all vertices in B, this method will return them.</p>
<p><strong>Important!</strong> This is a costly operation so use with caution!</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>map</code>(<code>List</code>[<code>List</code>[<code>float</code>]])</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def absolute_vertices(self) -&gt; Iterator[List[float]]:
    &#34;&#34;&#34;Return a map of all local vertices as absolute coordinates.

    Imagine that object B is a child of object A. In this case, B will
    always stand (follow) relative to A. If you want to know the exact
    world coordinates of all vertices in B, this method will return them.

    **Important!** This is a costly operation so use with caution!

    Returns:
      map(List[List[float]])
    &#34;&#34;&#34;
    return map(lambda v: self.to_absolute(v), self._vertices)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.add_child"><code class="name flex">
<span>def <span class="ident">add_child</span></span>(<span>self, name, obj)</span>
</code></dt>
<dd>
<section class="desc"><p>Add child to this object.</p>
<p>In a basic example:</p>
<pre><code>import os
import math
from payton.scene import Scene
from payton.scene.geometry import Sphere
from payton.scene.light import Light


def motion(name, scene, period, total):
    angle = (total * 10) % 360
    px = math.cos(math.radians(angle)) * 8
    py = math.sin(math.radians(angle)) * 8
    scene.objects["nucleus"].children["particle"].position = [px, py, 0]

    sx = math.cos(math.radians(angle * 10)) * 2  # 10 times faster
    sy = math.sin(math.radians(angle * 10)) * 2
    scene.objects["nucleus"].children["particle"].children[
        "sub_particle"
    ].position = [sx, sy, 0]
    scene.lights[0].position = [px, py, 0]
    scene.lights[1].position = [-px, -py, 0]


space = Scene()
space.lights.append(Light())
space.observers[0].position = [20, 20, 20]
space.grid.resize(40, 40, 1)

texture_file = os.path.join(os.path.dirname(__file__), "map.png")

nucleus = Sphere(radius=5, parallels=36, meridians=36)
nucleus.material.texture = texture_file
particle = Sphere()
particle.position = [8, 0, 0]

sub_particle = Sphere(radius=0.5)
sub_particle.position = [0, 2, 0]

nucleus.add_child("particle", particle)
particle.add_child("sub_particle", sub_particle)

space.add_object("nucleus", nucleus)

space.create_clock("motion", 0.01, motion)
print("Hit SPACE to continue animation")
space.run()
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the object, must be unique within its siblings</dd>
<dt><strong><code>obj</code></strong></dt>
<dd>Object. Must be an instance of <a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object"><code>Object</code></a></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bool</code></strong></dt>
<dd>False in case of an error</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add_child(self, name: str, obj: Type[&#34;Object&#34;]) -&gt; bool:
    &#34;&#34;&#34;Add child to this object.

    In a basic example:

        .. include:: ../../examples/basics/05_children.py

    Args:
      name: Name of the object, must be unique within its siblings
      obj: Object. Must be an instance of `payton.scene.geometry.Object`

    Returns:
      bool: False in case of an error
    &#34;&#34;&#34;
    if name in self.children:
        logging.error(f&#34;Name {name} exists in object children&#34;)
        return False
    if not isinstance(obj, Object):
        logging.error(&#34;Object type is not valid&#34;)
        return False
    self.children[name] = obj
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Build OpenGL Vertex Array for the object</p>
<p>This function gets automatically called if <code>self._vao</code> does not
exists in the first render cycle. Once the vba is built,
geometry changes or material display mode changes will not be
automatically effected. So, in every geometry or display mode
change, a <code>build</code> call is necessary.</p>
<p>if <code>self.static</code> is <code>True</code>, then system assumes that another update
call is not expected, thus frees <code>_normals',</code>_textcoords<code>,</code>_vertices<code>and</code>_indices<code>lists to free memory.
So in this case, calling</code>build` function twice will result with
an invisible object (will not be drawn)</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build(self) -&gt; bool:
    &#34;&#34;&#34;
    Build OpenGL Vertex Array for the object

    This function gets automatically called if `self._vao` does not
    exists in the first render cycle. Once the vba is built,
    geometry changes or material display mode changes will not be
    automatically effected. So, in every geometry or display mode
    change, a `build` call is necessary.

    if `self.static` is `True`, then system assumes that another update
    call is not expected, thus frees `_normals&#39;, `_textcoords`,
    `_vertices` and `_indices` lists to free memory.
    So in this case, calling `build` function twice will result with
    an invisible object (will not be drawn)

    Returns:
      bool
    &#34;&#34;&#34;
    if len(self._indices) == 0:
        return False

    # If we don&#39;t have a VAO yet, we need to create one
    if not self.has_vao:
        # Generate Vertex Array
        self._vao = glGenVertexArrays(1)
        # We need 5 buffers (vertex, normal, texcoord, color, indices)
        self._vbos = glGenBuffers(5)
        glBindVertexArray(self._vao)
        # Material shader must be built when there is an active binding
        # to vertex array
        self.material.build_shader()
    else:
        # Ok, we already have vertex array object, just bind it to modify
        glBindVertexArray(self._vao)

    # Turn python arrays into C type arrays using Numpy.
    # This is required for OpenGL. Python memory model is a bit
    # different than raw memory model of C (OpenGL)
    vertices = np.array(self._vertices, dtype=np.float32).flatten()
    normals = np.array(self._normals, dtype=np.float32).flatten()
    texcoords = np.array(self._texcoords, dtype=np.float32).flatten()
    colors = np.array(self._vertex_colors, dtype=np.float32).flatten()
    indices = np.array(self._indices, dtype=np.int32).flatten()
    self._calc_bounds()

    # OpenGL allocates buffers in different mechanisms between
    # STATIC and DYNAMIC draw modes. If you select STATIC, then OpenGL
    # will assume that object buffer will not change and allocate it in a
    # more suitable way.
    draw = GL_STATIC_DRAW
    if not self.static:
        draw = GL_DYNAMIC_DRAW

    # Buffer overflow, we need more space.
    if self._buffer_size &lt; vertices.nbytes:
        self._buffer_size = vertices.nbytes
        self._buffer_size_changed = True
    if self._t_buffer_size &lt; texcoords.nbytes:
        self._t_buffer_size = texcoords.nbytes
        self._t_buffer_size_changed = True

    # Bind Vertices
    glBindBuffer(GL_ARRAY_BUFFER, self._vbos[0])
    glEnableVertexAttribArray(0)  # shader layout location
    glVertexAttribPointer(0, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
    if self._buffer_size_changed:
        # glBufferData creates a new data area
        glBufferData(GL_ARRAY_BUFFER, self._buffer_size, vertices, draw)
    else:
        # glBufferSubData just replaces memory area in buffer so it is
        # much more efficient way to handle things.
        glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.nbytes, vertices)

    # Bind Normals
    glBindBuffer(GL_ARRAY_BUFFER, self._vbos[1])
    glEnableVertexAttribArray(1)  # shader layout location
    glVertexAttribPointer(1, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
    if self._buffer_size_changed:
        glBufferData(GL_ARRAY_BUFFER, self._buffer_size, normals, draw)
    else:
        glBufferSubData(GL_ARRAY_BUFFER, 0, normals.nbytes, normals)

    # Bind TexCoords
    if len(self._texcoords) == len(self._vertices):
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[2])
        glEnableVertexAttribArray(2)  # shader layout location
        glVertexAttribPointer(2, 2, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        if self._t_buffer_size_changed:
            glBufferData(
                GL_ARRAY_BUFFER, self._t_buffer_size, texcoords, draw
            )
        else:
            glBufferSubData(
                GL_ARRAY_BUFFER, 0, texcoords.nbytes, texcoords
            )

    # Bind Vertex Colors
    if len(self._vertex_colors) == len(self._vertices):
        glBindBuffer(GL_ARRAY_BUFFER, self._vbos[4])
        glEnableVertexAttribArray(3)  # shader layout location
        glVertexAttribPointer(3, 3, GL_FLOAT, False, 0, ctypes.c_void_p(0))
        self._has_vertex_colors = True
        if self._buffer_size_changed:
            glBufferData(GL_ARRAY_BUFFER, self._buffer_size, colors, draw)
        else:
            glBufferSubData(GL_ARRAY_BUFFER, 0, colors.nbytes, colors)

    self._buffer_size_changed = False
    self._t_buffer_size_changed = False

    # Bind Indices
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, self._vbos[3])
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.nbytes, indices, draw)
    self._vertex_count = len(indices)

    glBindVertexArray(0)
    glBindBuffer(GL_ARRAY_BUFFER, 0)

    if self.static:
        # we can clear this data to free some more memory
        glDeleteBuffers(4, self._vbos)
        self._vbos = []

    self._needs_update = False

    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Destroy objects self</p>
<p>Returns: bool</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def destroy(self) -&gt; bool:
    &#34;&#34;&#34;
    Destroy objects self

    Returns: bool
    &#34;&#34;&#34;
    if self.has_vao:
        glDeleteVertexArrays(1, [self._vao])
        self._vao = -1
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.hide"><code class="name flex">
<span>def <span class="ident">hide</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def hide(self) -&gt; None:
    self._visible = False</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Refresh object</p>
<p>Forces object to get built again</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def refresh(self) -&gt; None:
    &#34;&#34;&#34;Refresh object

    Forces object to get built again
    &#34;&#34;&#34;
    self._needs_update = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.render"><code class="name flex">
<span>def <span class="ident">render</span></span>(<span>self, proj, view, lights, parent_matrix=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Virtual function for rendering the object. Some objects can overwrite
this function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>proj</code></strong></dt>
<dd>Camera projection matrix.</dd>
<dt><strong><code>view</code></strong></dt>
<dd>Camera location/view matrix.</dd>
<dt><strong><code>lights</code></strong></dt>
<dd>Light objects in the scene</dd>
<dt><strong><code>parent_matrix</code></strong></dt>
<dd>Parent matrix is the matrix of the parent. Parent can
be the scene itself or another object. In case of
another object, object will position itself relative
to its parent object.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def render(
    self,
    proj: np.ndarray,
    view: np.ndarray,
    lights: List[Light],
    parent_matrix: Optional[np.ndarray] = None,
) -&gt; None:
    &#34;&#34;&#34;
    Virtual function for rendering the object. Some objects can overwrite
    this function.

    Args:
      proj: Camera projection matrix.
      view: Camera location/view matrix.
      lights: Light objects in the scene
      parent_matrix: Parent matrix is the matrix of the parent. Parent can
                     be the scene itself or another object. In case of
                     another object, object will position itself relative
                     to its parent object.
    &#34;&#34;&#34;
    if not self._visible:
        return

    if not self.has_vao or self._needs_update:
        self.build()

    if self._vertex_count == 0:
        return

    self.update_matrix(parent_matrix=parent_matrix)
    self.track()

    # Material shading mode.
    mode = None
    if self._has_vertex_colors:
        mode = Shader.PER_VERTEX_COLOR

    self.material.render(proj, view, self._model_matrix, lights, mode)

    # Actual rendering
    if glIsVertexArray(self._vao):
        glBindVertexArray(self._vao)
        pmode = GL_LINE
        primitive = GL_LINE_STRIP
        if self.material.display == SOLID:
            pmode = GL_FILL
            primitive = GL_TRIANGLES
        if self.material.display == POINTS:
            pmode = GL_POINT
            primitive = GL_POINTS
        glPolygonMode(GL_FRONT_AND_BACK, pmode)

        glDrawElements(
            primitive,
            self._vertex_count,
            GL_UNSIGNED_INT,
            ctypes.c_void_p(0),
        )
        if pmode != GL_FILL:
            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
        glBindVertexArray(0)

    # End using the shader program.
    self.material.end()

    # Render motion path
    if self.track_motion:
        self._motion_path_line.render(proj, view, lights, parent_matrix)

    # render children
    for child in self.children:
        self.children[child].render(proj, view, lights, self._model_matrix)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.rotate_around_x"><code class="name flex">
<span>def <span class="ident">rotate_around_x</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<section class="desc"><p>Pitch - Rotate around X axis</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle in radians</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotate_around_x(self, angle: float) -&gt; None:
    &#34;&#34;&#34;Pitch - Rotate around X axis

    Args:
      angle: Angle in radians
    &#34;&#34;&#34;
    rot_matrix = create_rotation_matrix([1, 0, 0], angle)
    local_matrix = np.array(self.matrix, dtype=np.float32)
    local_matrix = rot_matrix.dot(local_matrix)
    self.matrix = local_matrix.tolist()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.rotate_around_y"><code class="name flex">
<span>def <span class="ident">rotate_around_y</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<section class="desc"><p>Roll - Rotate around Y Axis (Direction)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle in radians</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotate_around_y(self, angle: float) -&gt; None:
    &#34;&#34;&#34;Roll - Rotate around Y Axis (Direction)

    Args:
      angle: Angle in radians
    &#34;&#34;&#34;
    rot_matrix = create_rotation_matrix([0, 1, 0], angle)
    local_matrix = np.array(self.matrix, dtype=np.float32)
    local_matrix = rot_matrix.dot(local_matrix)
    self.matrix = local_matrix.tolist()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.rotate_around_z"><code class="name flex">
<span>def <span class="ident">rotate_around_z</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<section class="desc"><p>Rotate around Z axis, alias for yaw function</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def rotate_around_z(self, angle: float) -&gt; None:
    &#34;&#34;&#34;Rotate around Z axis, alias for yaw function&#34;&#34;&#34;
    return self.yaw(angle)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, start, vector)</span>
</code></dt>
<dd>
<section class="desc"><p>Select test for object using bounding Sphere.</p>
<p>Note: this method is not 100% accurate as it is based on a rough
assumption. Sphere area will be larger than actual object.</p>
<p>If you want to have a more accurate way to handle this, try
using raycast triangle intersect</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>Starting point of the ray (such as eye position)</dd>
<dt><strong><code>vector</code></strong></dt>
<dd>Ray direction. This is not the end point of a line! This is</dd>
</dl>
<p>a unit vector showing the ray direction.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def select(self, start: np.ndarray, vector: np.ndarray) -&gt; bool:
    &#34;&#34;&#34;Select test for object using bounding Sphere.

    Note: this method is not 100% accurate as it is based on a rough
    assumption. Sphere area will be larger than actual object.

    If you want to have a more accurate way to handle this, try
    using raycast triangle intersect

    Args:
      start: Starting point of the ray (such as eye position)
      vector: Ray direction. This is not the end point of a line! This is
    a unit vector showing the ray direction.
    &#34;&#34;&#34;
    self._selected = raycast_sphere_intersect(
        start,
        vector,
        np.array(self.matrix[3], dtype=np.float32),
        self._bounding_radius,
    )

    for obj in self.children:
        x = self.children[obj].select(start, vector)
        if not self._selected and x:
            self._selected = True

    return self._selected</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def show(self) -&gt; None:
    self._visible = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.to_absolute"><code class="name flex">
<span>def <span class="ident">to_absolute</span></span>(<span>self, coordinates)</span>
</code></dt>
<dd>
<section class="desc"><p>Return local coordinates (tuple, list) into absolute coordinates in
space.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>coordinates</code></strong></dt>
<dd>List[float] (x, y, z)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List</code>[<code>float</code>] (<code>x'</code>, <code>y'</code>, <code>z'</code>)</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def to_absolute(self, coordinates: List[float]) -&gt; List[float]:
    &#34;&#34;&#34;
    Return local coordinates (tuple, list) into absolute coordinates in
    space.

    Args:
      coordinates: List[float] (x, y, z)

    Returns:
      List[float] (x&#39;, y&#39;, z&#39;)
    &#34;&#34;&#34;
    return vector_transform(coordinates, self.matrix)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.toggle_wireframe"><code class="name flex">
<span>def <span class="ident">toggle_wireframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Toggle wireframe view of the Object</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def toggle_wireframe(self) -&gt; None:
    &#34;&#34;&#34;Toggle wireframe view of the Object&#34;&#34;&#34;
    d = self.material.display
    d += 1
    d = d % 3

    self.material.display = d
    for n in self.children:
        self.children[n].toggle_wireframe()</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.track"><code class="name flex">
<span>def <span class="ident">track</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Track object motion</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def track(self) -&gt; bool:
    &#34;&#34;&#34;
    Track object motion

    Returns:
      bool
    &#34;&#34;&#34;
    if not self.track_motion:
        return False
    if self._previous_matrix == self.matrix[3]:
        return True

    # Add the new matrix to motion path records
    self._motion_path.append(self.matrix)
    # Add the matrix position to motion math line for visualisation
    if self._motion_path_line is not None:
        self._motion_path_line.append(
            [[self.matrix[3][0], self.matrix[3][1], self.matrix[3][2]]]
        )

    # Python trick here! need to .copy or it will pass reference.
    self._previous_matrix = self.matrix[3].copy()
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.update_matrix"><code class="name flex">
<span>def <span class="ident">update_matrix</span></span>(<span>self, parent_matrix=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Update matrix</p>
<p>Turn object matrix into numpy array.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>parent_matrix</code></strong></dt>
<dd>Parent objects matrix</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def update_matrix(
    self, parent_matrix: Optional[np.ndarray] = None
) -&gt; None:
    &#34;&#34;&#34;Update matrix

    Turn object matrix into numpy array.

    Args:
      parent_matrix: Parent objects matrix
    &#34;&#34;&#34;
    # Turn matrix into numpy array. Numpy arrays are C Type arrays
    # suitable for OpenGL Pipeline
    self._model_matrix = np.array(self.matrix, dtype=np.float32)

    # When there is a parent object, child object follows parents matrix
    if parent_matrix is not None and len(parent_matrix) &gt; 0:
        self._model_matrix = parent_matrix.dot(self._model_matrix)</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.Object.yaw"><code class="name flex">
<span>def <span class="ident">yaw</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<section class="desc"><p>Yaw - Rotate around Z Axis</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>angle</code></strong></dt>
<dd>Angle in radians</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def yaw(self, angle: float) -&gt; None:
    &#34;&#34;&#34;Yaw - Rotate around Z Axis

    Args:
      angle: Angle in radians
    &#34;&#34;&#34;
    rot_matrix = create_rotation_matrix([0, 0, 1], angle)
    local_matrix = np.array(self.matrix, dtype=np.float32)
    local_matrix = rot_matrix.dot(local_matrix)
    self.matrix = local_matrix.tolist()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="payton.scene.geometry.Plane"><code class="flex name class">
<span>class <span class="ident">Plane</span></span>
<span>(</span><span>**args)</span>
</code></dt>
<dd>
<section class="desc"><p>Plane object</p>
<p>This is a 2D Plane in 3D World. Has a width in X and height in Y.
If you need to place it in another axis, try modifying its matrix.</p>
<p>Example use case:</p>
<pre><code>from payton.scene import Scene
from payton.scene.geometry import Plane


scene = Scene()
plane = Plane(width=2, height=2)
scene.add_object("plane", plane)
scene.run()
</code></pre>
<p>Initialize plane</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>width</code></strong></dt>
<dd>Width of the plane</dd>
<dt><strong><code>height</code></strong></dt>
<dd>Height of the plane</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Plane(Mesh):
    &#34;&#34;&#34;Plane object

    This is a 2D Plane in 3D World. Has a width in X and height in Y.
    If you need to place it in another axis, try modifying its matrix.

    Example use case:

        .. include:: ../../examples/basics/13_plane.py
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Initialize plane

        Args:
          width: Width of the plane
          height: Height of the plane
        &#34;&#34;&#34;
        super().__init__(**args)
        width = args.get(&#34;width&#34;, 1.0) * 0.5
        height = args.get(&#34;height&#34;, 1.0) * 0.5
        self._vertices = [
            [-width, -height, 0],
            [width, -height, 0],
            [width, height, 0],
            [-width, height, 0],
        ]
        self._normals = [[0, 0, 1], [0, 0, 1], [0, 0, 1], [0, 0, 1]]
        self._texcoords = [[-1, -1], [1, -1], [1, 1], [-1, 1]]
        self._indices = [[0, 1, 2], [0, 2, 3]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.Mesh.absolute_vertices" href="#payton.scene.geometry.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.add_child" href="#payton.scene.geometry.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.add_triangle" href="#payton.scene.geometry.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.bounding_radius" href="#payton.scene.geometry.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.build" href="#payton.scene.geometry.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.clear_triangles" href="#payton.scene.geometry.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.destroy" href="#payton.scene.geometry.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.fix_normals" href="#payton.scene.geometry.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.has_vao" href="#payton.scene.geometry.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.position" href="#payton.scene.geometry.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.refresh" href="#payton.scene.geometry.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.render" href="#payton.scene.geometry.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_x" href="#payton.scene.geometry.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_y" href="#payton.scene.geometry.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_z" href="#payton.scene.geometry.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.scale" href="#payton.scene.geometry.Mesh.scale">scale</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.select" href="#payton.scene.geometry.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.to_absolute" href="#payton.scene.geometry.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.toggle_wireframe" href="#payton.scene.geometry.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.track" href="#payton.scene.geometry.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.update_matrix" href="#payton.scene.geometry.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.visible" href="#payton.scene.geometry.Object.visible">visible</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.yaw" href="#payton.scene.geometry.Object.yaw">yaw</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.PointCloud"><code class="flex name class">
<span>class <span class="ident">PointCloud</span></span>
<span>(</span><span>**args)</span>
</code></dt>
<dd>
<section class="desc"><p>Point cloud</p>
<p>Note: If you change the vertices, do not forget to do a <code>refresh</code> to take
effect.</p>
<p>Example use case:</p>
<pre><code>import random
from payton.scene import Scene
from payton.scene.gui import Hud, Text
from payton.scene.geometry import PointCloud


def generate(name, scene, period, total):
    x = random.randint(-10, 10)
    y = random.randint(-10, 10)
    z = random.randint(-10, 10)
    r = random.randint(0, 255) / 255
    g = random.randint(0, 255) / 255
    b = random.randint(0, 255) / 255
    scene.objects["pc"].add([[x, y, z]], [[r, g, b]])


scene = Scene()

hud = Hud()
text = Text(
    label="Hit Space to create points",
    position=(5, 5),
    size=(200, 35),
    color=(1, 1, 1),
)

hud.add_child("text", text)
scene.add_object("hud", hud)

pc = PointCloud()

scene.add_object("pc", pc)
scene.create_clock("generate", 0.001, generate)

scene.run()
</code></pre>
<p>Initialize Point Cloud</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>List of point vertices</dd>
<dt><strong><code>colors</code></strong></dt>
<dd>List of colors per vertex, follows the same index as vertices</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class PointCloud(Object):
    &#34;&#34;&#34;Point cloud

    Note: If you change the vertices, do not forget to do a `refresh` to take
    effect.

    Example use case:

        .. include:: ../../examples/basics/11_point_cloud.py
    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Initialize Point Cloud

        Args:
          vertices: List of point vertices
          colors: List of colors per vertex, follows the same index as vertices
        &#34;&#34;&#34;
        super().__init__(**args)
        self._vertices: VList = args.get(&#34;vertices&#34;, [])
        # Expose vertices by reference for modification
        self.vertices: VList = self._vertices
        self._vertex_colors: VList = args.get(&#34;colors&#34;, [])
        self._vertex_history: VList = []
        self.material.display = POINTS
        self.static: bool = False

    def toggle_wireframe(self) -&gt; None:
        &#34;&#34;&#34;Toggle wireframe overwrite to disable mode change&#34;&#34;&#34;
        pass

    def track(self) -&gt; bool:
        &#34;&#34;&#34;Tracking point cloud is not possible at the moment
        &#34;&#34;&#34;
        return False

    def add(self, vertices: VList, colors: Optional[VList] = None) -&gt; None:
        &#34;&#34;&#34;Add a point to the cloud

        Args:
          vertices: Vertices to add
          colors: Colors of the vertices in the same order. (Optional)
        &#34;&#34;&#34;
        i = len(self._indices)
        for vertex in vertices:
            self._vertices.append(vertex)
            self._indices.append([i])
            i += 1

        if colors is not None:
            if len(colors) != len(vertices):
                logging.error(&#34;len(colors) != len(vertices)&#34;)
                return
            for color in colors:
                self._vertex_colors.append(color)

        self._needs_update = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.PointCloud.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, vertices, colors=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Add a point to the cloud</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vertices</code></strong></dt>
<dd>Vertices to add</dd>
<dt><strong><code>colors</code></strong></dt>
<dd>Colors of the vertices in the same order. (Optional)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def add(self, vertices: VList, colors: Optional[VList] = None) -&gt; None:
    &#34;&#34;&#34;Add a point to the cloud

    Args:
      vertices: Vertices to add
      colors: Colors of the vertices in the same order. (Optional)
    &#34;&#34;&#34;
    i = len(self._indices)
    for vertex in vertices:
        self._vertices.append(vertex)
        self._indices.append([i])
        i += 1

    if colors is not None:
        if len(colors) != len(vertices):
            logging.error(&#34;len(colors) != len(vertices)&#34;)
            return
        for color in colors:
            self._vertex_colors.append(color)

    self._needs_update = True</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.PointCloud.toggle_wireframe"><code class="name flex">
<span>def <span class="ident">toggle_wireframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Toggle wireframe overwrite to disable mode change</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def toggle_wireframe(self) -&gt; None:
    &#34;&#34;&#34;Toggle wireframe overwrite to disable mode change&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="payton.scene.geometry.PointCloud.track"><code class="name flex">
<span>def <span class="ident">track</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Tracking point cloud is not possible at the moment</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def track(self) -&gt; bool:
    &#34;&#34;&#34;Tracking point cloud is not possible at the moment
    &#34;&#34;&#34;
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.Object.absolute_vertices" href="#payton.scene.geometry.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.Object.add_child" href="#payton.scene.geometry.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.Object.bounding_radius" href="#payton.scene.geometry.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.Object.build" href="#payton.scene.geometry.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.Object.destroy" href="#payton.scene.geometry.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.Object.has_vao" href="#payton.scene.geometry.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.Object.position" href="#payton.scene.geometry.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.Object.refresh" href="#payton.scene.geometry.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.Object.render" href="#payton.scene.geometry.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_x" href="#payton.scene.geometry.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_y" href="#payton.scene.geometry.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_z" href="#payton.scene.geometry.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.Object.select" href="#payton.scene.geometry.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.Object.to_absolute" href="#payton.scene.geometry.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.Object.update_matrix" href="#payton.scene.geometry.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.Object.visible" href="#payton.scene.geometry.Object.visible">visible</a></code></li>
<li><code><a title="payton.scene.geometry.Object.yaw" href="#payton.scene.geometry.Object.yaw">yaw</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="payton.scene.geometry.Sphere"><code class="flex name class">
<span>class <span class="ident">Sphere</span></span>
<span>(</span><span>**args)</span>
</code></dt>
<dd>
<section class="desc"><p>Sphere object.</p>
<p>This object is generated using basic Spherical coordinates.
Beware of using high values for parallels and meridians. You might end up
with excessive number of vertices to render and a performance trouble.</p>
<p>Parameters:</p>
<ul>
<li><code>radius</code> default: <code>0.5</code></li>
<li><code>parallels</code> default: <code>12</code></li>
<li><code>meridians</code> default: <code>12</code></li>
</ul>
<p>Sphere object use case</p>
<pre><code>import os
import math
from payton.scene import Scene
from payton.scene.geometry import Sphere
from payton.scene.light import Light


def motion(name, scene, period, total):
    angle = (total * 10) % 360
    px = math.cos(math.radians(angle)) * 8
    py = math.sin(math.radians(angle)) * 8
    scene.objects["nucleus"].children["particle"].position = [px, py, 0]

    sx = math.cos(math.radians(angle * 10)) * 2  # 10 times faster
    sy = math.sin(math.radians(angle * 10)) * 2
    scene.objects["nucleus"].children["particle"].children[
        "sub_particle"
    ].position = [sx, sy, 0]
    scene.lights[0].position = [px, py, 0]
    scene.lights[1].position = [-px, -py, 0]


space = Scene()
space.lights.append(Light())
space.observers[0].position = [20, 20, 20]
space.grid.resize(40, 40, 1)

texture_file = os.path.join(os.path.dirname(__file__), "map.png")

nucleus = Sphere(radius=5, parallels=36, meridians=36)
nucleus.material.texture = texture_file
particle = Sphere()
particle.position = [8, 0, 0]

sub_particle = Sphere(radius=0.5)
sub_particle.position = [0, 2, 0]

nucleus.add_child("particle", particle)
particle.add_child("sub_particle", sub_particle)

space.add_object("nucleus", nucleus)

space.create_clock("motion", 0.01, motion)
print("Hit SPACE to continue animation")
space.run()
</code></pre>
<p>Initialize the sphere</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>radius</code></strong></dt>
<dd>Radius of the sphere (default: 0.5, making it a unit sphere)</dd>
<dt><strong><code>parallels</code></strong></dt>
<dd>Number of parallels (as in geography). (default: 12, 30
degrees of arcs)</dd>
<dt><strong><code>meridians</code></strong></dt>
<dd>Number of meridians (as in geography). (default: 12)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Sphere(Mesh):
    &#34;&#34;&#34;
    Sphere object.

    This object is generated using basic Spherical coordinates.
    Beware of using high values for parallels and meridians. You might end up
    with excessive number of vertices to render and a performance trouble.

    Parameters:

    - `radius` default: `0.5`
    - `parallels` default: `12`
    - `meridians` default: `12`

    Sphere object use case

        .. include:: ../../examples/basics/05_children.py

    &#34;&#34;&#34;

    def __init__(self, **args: Any) -&gt; None:
        &#34;&#34;&#34;Initialize the sphere

        Args:
          radius: Radius of the sphere (default: 0.5, making it a unit sphere)
          parallels: Number of parallels (as in geography). (default: 12, 30
                     degrees of arcs)
          meridians: Number of meridians (as in geography). (default: 12)
        &#34;&#34;&#34;
        super().__init__(**args)
        self.radius: float = args.get(&#34;radius&#34;, 0.5)
        self.parallels: int = args.get(&#34;parallels&#34;, 12)
        self.meridians: int = args.get(&#34;meridians&#34;, 12)
        self.build_sphere()

    def build_sphere(self) -&gt; bool:
        &#34;&#34;&#34;
        Generate the sphere

        Returns:
          bool
        &#34;&#34;&#34;
        r = self.radius
        # step angle is the rotational angle to build the sphere
        step_angle = math.radians(360.0 / self.meridians)
        # step height is the arc in height
        step_height = math.radians(180.0 / self.parallels)
        indices = 0
        u_step = 1.0 / self.meridians
        v_step = 1.0 / self.parallels

        for i in range(self.parallels):
            for j in range(self.meridians):
                x1 = r * math.sin(step_height * i) * math.cos(step_angle * j)
                y1 = r * math.sin(step_height * i) * math.sin(step_angle * j)
                z1 = r * math.cos(step_height * i)
                u1 = u_step * j
                v1 = v_step * i

                x2 = (
                    r
                    * math.sin(step_height * (i + 1))
                    * math.cos(step_angle * j)
                )
                y2 = (
                    r
                    * math.sin(step_height * (i + 1))
                    * math.sin(step_angle * j)
                )
                z2 = r * math.cos(step_height * (i + 1))
                u2 = u_step * j
                v2 = v_step * (i + 1)

                x3 = (
                    r
                    * math.sin(step_height * (i + 1))
                    * math.cos(step_angle * (j + 1))
                )
                y3 = (
                    r
                    * math.sin(step_height * (i + 1))
                    * math.sin(step_angle * (j + 1))
                )
                z3 = r * math.cos(step_height * (i + 1))
                u3 = u_step * (j + 1)
                v3 = v_step * (i + 1)

                x4 = (
                    r
                    * math.sin(step_height * i)
                    * math.cos(step_angle * (j + 1))
                )
                y4 = (
                    r
                    * math.sin(step_height * i)
                    * math.sin(step_angle * (j + 1))
                )
                z4 = r * math.cos(step_height * i)
                u4 = u_step * (j + 1)
                v4 = v_step * i

                normal = plane_normal([x1, y1, z1], [x2, y2, z2], [x3, y3, z3])
                self._vertices.append([x1, y1, z1])
                self._vertices.append([x2, y2, z2])
                self._vertices.append([x3, y3, z3])
                self._vertices.append([x4, y4, z4])
                self._texcoords.append([u1, v1])
                self._texcoords.append([u2, v2])
                self._texcoords.append([u3, v3])
                self._texcoords.append([u4, v4])
                self._normals.append([normal[0], normal[1], normal[2]])
                self._normals.append([normal[0], normal[1], normal[2]])
                self._normals.append([normal[0], normal[1], normal[2]])
                self._normals.append([normal[0], normal[1], normal[2]])
                self._indices.append([indices, indices + 1, indices + 2])
                self._indices.append([indices, indices + 2, indices + 3])
                indices += 4
        return True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></li>
<li><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.geometry.Sphere.build_sphere"><code class="name flex">
<span>def <span class="ident">build_sphere</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate the sphere</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build_sphere(self) -&gt; bool:
    &#34;&#34;&#34;
    Generate the sphere

    Returns:
      bool
    &#34;&#34;&#34;
    r = self.radius
    # step angle is the rotational angle to build the sphere
    step_angle = math.radians(360.0 / self.meridians)
    # step height is the arc in height
    step_height = math.radians(180.0 / self.parallels)
    indices = 0
    u_step = 1.0 / self.meridians
    v_step = 1.0 / self.parallels

    for i in range(self.parallels):
        for j in range(self.meridians):
            x1 = r * math.sin(step_height * i) * math.cos(step_angle * j)
            y1 = r * math.sin(step_height * i) * math.sin(step_angle * j)
            z1 = r * math.cos(step_height * i)
            u1 = u_step * j
            v1 = v_step * i

            x2 = (
                r
                * math.sin(step_height * (i + 1))
                * math.cos(step_angle * j)
            )
            y2 = (
                r
                * math.sin(step_height * (i + 1))
                * math.sin(step_angle * j)
            )
            z2 = r * math.cos(step_height * (i + 1))
            u2 = u_step * j
            v2 = v_step * (i + 1)

            x3 = (
                r
                * math.sin(step_height * (i + 1))
                * math.cos(step_angle * (j + 1))
            )
            y3 = (
                r
                * math.sin(step_height * (i + 1))
                * math.sin(step_angle * (j + 1))
            )
            z3 = r * math.cos(step_height * (i + 1))
            u3 = u_step * (j + 1)
            v3 = v_step * (i + 1)

            x4 = (
                r
                * math.sin(step_height * i)
                * math.cos(step_angle * (j + 1))
            )
            y4 = (
                r
                * math.sin(step_height * i)
                * math.sin(step_angle * (j + 1))
            )
            z4 = r * math.cos(step_height * i)
            u4 = u_step * (j + 1)
            v4 = v_step * i

            normal = plane_normal([x1, y1, z1], [x2, y2, z2], [x3, y3, z3])
            self._vertices.append([x1, y1, z1])
            self._vertices.append([x2, y2, z2])
            self._vertices.append([x3, y3, z3])
            self._vertices.append([x4, y4, z4])
            self._texcoords.append([u1, v1])
            self._texcoords.append([u2, v2])
            self._texcoords.append([u3, v3])
            self._texcoords.append([u4, v4])
            self._normals.append([normal[0], normal[1], normal[2]])
            self._normals.append([normal[0], normal[1], normal[2]])
            self._normals.append([normal[0], normal[1], normal[2]])
            self._normals.append([normal[0], normal[1], normal[2]])
            self._indices.append([indices, indices + 1, indices + 2])
            self._indices.append([indices, indices + 2, indices + 3])
            indices += 4
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></b></code>:
<ul class="hlist">
<li><code><a title="payton.scene.geometry.Mesh.absolute_vertices" href="#payton.scene.geometry.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.add_child" href="#payton.scene.geometry.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.add_triangle" href="#payton.scene.geometry.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.bounding_radius" href="#payton.scene.geometry.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.build" href="#payton.scene.geometry.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.clear_triangles" href="#payton.scene.geometry.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.destroy" href="#payton.scene.geometry.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.fix_normals" href="#payton.scene.geometry.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.has_vao" href="#payton.scene.geometry.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.position" href="#payton.scene.geometry.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.refresh" href="#payton.scene.geometry.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.render" href="#payton.scene.geometry.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_x" href="#payton.scene.geometry.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_y" href="#payton.scene.geometry.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.rotate_around_z" href="#payton.scene.geometry.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.scale" href="#payton.scene.geometry.Mesh.scale">scale</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.select" href="#payton.scene.geometry.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.to_absolute" href="#payton.scene.geometry.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.toggle_wireframe" href="#payton.scene.geometry.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.track" href="#payton.scene.geometry.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.update_matrix" href="#payton.scene.geometry.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.visible" href="#payton.scene.geometry.Object.visible">visible</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.yaw" href="#payton.scene.geometry.Object.yaw">yaw</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="payton.scene" href="index.html">payton.scene</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="payton.scene.geometry.Cube" href="#payton.scene.geometry.Cube">Cube</a></code></h4>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Cylinder" href="#payton.scene.geometry.Cylinder">Cylinder</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.Cylinder.build_cylinder" href="#payton.scene.geometry.Cylinder.build_cylinder">build_cylinder</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Line" href="#payton.scene.geometry.Line">Line</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.Line.append" href="#payton.scene.geometry.Line.append">append</a></code></li>
<li><code><a title="payton.scene.geometry.Line.build_lines" href="#payton.scene.geometry.Line.build_lines">build_lines</a></code></li>
<li><code><a title="payton.scene.geometry.Line.toggle_wireframe" href="#payton.scene.geometry.Line.toggle_wireframe">toggle_wireframe</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Mesh" href="#payton.scene.geometry.Mesh">Mesh</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.Mesh.add_triangle" href="#payton.scene.geometry.Mesh.add_triangle">add_triangle</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.clear_triangles" href="#payton.scene.geometry.Mesh.clear_triangles">clear_triangles</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.fix_normals" href="#payton.scene.geometry.Mesh.fix_normals">fix_normals</a></code></li>
<li><code><a title="payton.scene.geometry.Mesh.scale" href="#payton.scene.geometry.Mesh.scale">scale</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Object" href="#payton.scene.geometry.Object">Object</a></code></h4>
<ul class="two-column">
<li><code><a title="payton.scene.geometry.Object.absolute_vertices" href="#payton.scene.geometry.Object.absolute_vertices">absolute_vertices</a></code></li>
<li><code><a title="payton.scene.geometry.Object.add_child" href="#payton.scene.geometry.Object.add_child">add_child</a></code></li>
<li><code><a title="payton.scene.geometry.Object.bounding_radius" href="#payton.scene.geometry.Object.bounding_radius">bounding_radius</a></code></li>
<li><code><a title="payton.scene.geometry.Object.build" href="#payton.scene.geometry.Object.build">build</a></code></li>
<li><code><a title="payton.scene.geometry.Object.destroy" href="#payton.scene.geometry.Object.destroy">destroy</a></code></li>
<li><code><a title="payton.scene.geometry.Object.has_vao" href="#payton.scene.geometry.Object.has_vao">has_vao</a></code></li>
<li><code><a title="payton.scene.geometry.Object.hide" href="#payton.scene.geometry.Object.hide">hide</a></code></li>
<li><code><a title="payton.scene.geometry.Object.position" href="#payton.scene.geometry.Object.position">position</a></code></li>
<li><code><a title="payton.scene.geometry.Object.refresh" href="#payton.scene.geometry.Object.refresh">refresh</a></code></li>
<li><code><a title="payton.scene.geometry.Object.render" href="#payton.scene.geometry.Object.render">render</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_x" href="#payton.scene.geometry.Object.rotate_around_x">rotate_around_x</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_y" href="#payton.scene.geometry.Object.rotate_around_y">rotate_around_y</a></code></li>
<li><code><a title="payton.scene.geometry.Object.rotate_around_z" href="#payton.scene.geometry.Object.rotate_around_z">rotate_around_z</a></code></li>
<li><code><a title="payton.scene.geometry.Object.select" href="#payton.scene.geometry.Object.select">select</a></code></li>
<li><code><a title="payton.scene.geometry.Object.show" href="#payton.scene.geometry.Object.show">show</a></code></li>
<li><code><a title="payton.scene.geometry.Object.to_absolute" href="#payton.scene.geometry.Object.to_absolute">to_absolute</a></code></li>
<li><code><a title="payton.scene.geometry.Object.toggle_wireframe" href="#payton.scene.geometry.Object.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.Object.track" href="#payton.scene.geometry.Object.track">track</a></code></li>
<li><code><a title="payton.scene.geometry.Object.update_matrix" href="#payton.scene.geometry.Object.update_matrix">update_matrix</a></code></li>
<li><code><a title="payton.scene.geometry.Object.visible" href="#payton.scene.geometry.Object.visible">visible</a></code></li>
<li><code><a title="payton.scene.geometry.Object.yaw" href="#payton.scene.geometry.Object.yaw">yaw</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Plane" href="#payton.scene.geometry.Plane">Plane</a></code></h4>
</li>
<li>
<h4><code><a title="payton.scene.geometry.PointCloud" href="#payton.scene.geometry.PointCloud">PointCloud</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.PointCloud.add" href="#payton.scene.geometry.PointCloud.add">add</a></code></li>
<li><code><a title="payton.scene.geometry.PointCloud.toggle_wireframe" href="#payton.scene.geometry.PointCloud.toggle_wireframe">toggle_wireframe</a></code></li>
<li><code><a title="payton.scene.geometry.PointCloud.track" href="#payton.scene.geometry.PointCloud.track">track</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="payton.scene.geometry.Sphere" href="#payton.scene.geometry.Sphere">Sphere</a></code></h4>
<ul class="">
<li><code><a title="payton.scene.geometry.Sphere.build_sphere" href="#payton.scene.geometry.Sphere.build_sphere">build_sphere</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>