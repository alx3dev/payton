<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.5.3" />
<title>payton.scene.shader API documentation</title>
<meta name="description" content="Payton Shader â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.name small{font-weight:normal}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title"><code>payton.scene.shader</code> module</h1>
</header>
<section id="section-intro">
<p>Payton Shader</p>
<p>Payton Shader is an OpenGL 3.3 Compatible GLSL (330) module. Basic principle
is to be be able to compile vertex and fragment shaders and hold basic
ready-to-use shaders.</p>
<p>A usual user should not be aware of this shading system. Basic shaders defined
should be enough for simple simulations. Our intention is not to create a
graphics library. We want to create a simulation platform and let developers
to focus on mathematics rather than OpenGL Stuff.</p>
<p>Also, keep in mind that, this is NOT a generic-purpose shader class which can
be used at common OpenGL apps. This shader class is just enough of what is
essential to Payton Library. That is all.</p>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">&#34;&#34;&#34;Payton Shader

Payton Shader is an OpenGL 3.3 Compatible GLSL (330) module. Basic principle
is to be be able to compile vertex and fragment shaders and hold basic
ready-to-use shaders.

A usual user should not be aware of this shading system. Basic shaders defined
should be enough for simple simulations. Our intention is not to create a
graphics library. We want to create a simulation platform and let developers
to focus on mathematics rather than OpenGL Stuff.

Also, keep in mind that, this is NOT a generic-purpose shader class which can
be used at common OpenGL apps. This shader class is just enough of what is
essential to Payton Library. That is all.

&#34;&#34;&#34;

import ctypes
import numpy as np
import logging

from OpenGL.GL import (GL_VERTEX_SHADER, GL_FRAGMENT_SHADER, glEnable,
                       glDisable, GL_PROGRAM_POINT_SIZE, glUniform1i, GLuint,
                       glGetUniformLocation, glUseProgram, GL_TRUE, GL_FALSE,
                       glUniformMatrix4fv, glUniform3fv, glUniform4fv)

from OpenGL.GL import shaders

default_fragment_shader = &#34;&#34;&#34;
#version 330 core
out vec4 FragColor;

in vec3 l_normal;
in vec3 l_fragpos;
in vec2 tex_coords;

uniform vec3 light_pos;
uniform vec3 light_color;
uniform vec3 object_color;
uniform int material_mode;

uniform sampler2D tex_unit;

void main()
{
    if (material_mode == 0) {
        // lightless material with color
        FragColor = vec4(object_color, 1.0);
    }
    if (material_mode == 1) {
        // lightless material with texture
        FragColor = texture(tex_unit, tex_coords);
    }
    if (material_mode == 2 || material_mode == 3) {
        // light material
        // ambient
        float ambientStrength = 0.3;
        vec3 ambient = ambientStrength * light_color;

        // diffuse
        vec3 norm = normalize(l_normal);

        vec3 lightDir = normalize(light_pos - l_fragpos);
        float diff = max(dot(norm, lightDir), 0.0);
        vec3 diffuse = diff * light_color;
        if (material_mode == 2) {
            // color material
            FragColor = vec4((ambient + diffuse) * object_color, 1.0);
        }else{
            // texture material
            FragColor = (vec4(ambient + diffuse, 1.0) *
                         texture(tex_unit, tex_coords));
        }
    }
}&#34;&#34;&#34;


default_vertex_shader = &#34;&#34;&#34;
#version 330 core
layout ( location = 0 ) in vec3 position;
layout ( location = 1 ) in vec3 normal;
layout ( location = 2 ) in vec2 texCoords;

out vec2 tex_coords;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 l_fragpos;
out vec3 l_normal;

void main()
{
    l_fragpos = vec3(model * vec4(position, 1.0));
    l_normal = mat3(transpose(inverse(model))) * normal;

    gl_Position = projection * view * model * vec4(position, 1.0f);
    gl_PointSize = 2.0;

    tex_coords = texCoords;
}
&#34;&#34;&#34;

background_vertex_shader = &#34;&#34;&#34;
#version 330 core
out vec2 v_uv;

void main()
{
  // uint idx = gl_VertexID;
  gl_Position = (vec4( gl_VertexID &amp; 1, gl_VertexID &gt;&gt; 1, 0.0, 0.5 )
                 * 4.0 - 1.0);
  v_uv = vec2( gl_Position.xy * 0.5 + 0.5 );
}
&#34;&#34;&#34;

background_fragment_shader = &#34;&#34;&#34;
#version 330 core
uniform vec4 top_color;
uniform vec4 bot_color;
in vec2 v_uv;

out vec4 frag_color;
void main()
{
  frag_color = bot_color * (1 - v_uv.y) + top_color * v_uv.y;
}
&#34;&#34;&#34;


class Shader(object):
    &#34;&#34;&#34;Payton shader class. Creates shaders / programs

    For an improved performance, Shader aims to reduce the number of
    `glGetUniformlocation` function calls. For this purpose, `__init__` and
    `build` functions accept a list of variable names as `variables` argument.

    By this way, Shader goes through this list of variables after compiling the
    shader program and stores their locations in memory for future use.

    If you provide the list of variable names in build function call then
    it will overwrite existing list.
    &#34;&#34;&#34;
    NO_LIGHT_COLOR = 0
    NO_LIGHT_TEXTURE = 1
    LIGHT_COLOR = 2
    LIGHT_TEXTURE = 3

    def __init__(self, **args):
        &#34;&#34;&#34;Initialize Shader.

        Args:
          fragment: Fragment shader code
          vertex: Vertex shader code
          variables: List of in/out/uniform variable names.
        &#34;&#34;&#34;
        global default_fragment_shader, default_vertex_shader
        self.fragment_shader_source = args.get(&#39;fragment&#39;,
                                               default_fragment_shader)
        self.vertex_shader_source = args.get(&#39;vertex&#39;,
                                             default_vertex_shader)
        self.variables = args.get(&#39;variables&#39;, [])
        self._stack = {}  # Variable stack.
        self._mode = self.NO_LIGHT_COLOR  # Lightless color material

        self.program = None

    def build(self, variables=None):
        &#34;&#34;&#34;Build GLSL Shader
        Compile shaders and compile glsl program
        Args:
          variables: List of in/out/uniform variable names.
        Return:
            self.program
        &#34;&#34;&#34;
        vertex_shader = shaders.compileShader(self.vertex_shader_source,
                                              GL_VERTEX_SHADER)
        fragment_shader = shaders.compileShader(self.fragment_shader_source,
                                                GL_FRAGMENT_SHADER)
        self.program = shaders.compileProgram(vertex_shader,
                                              fragment_shader)
        if variables:
            self.variables = variables

        for v in self.variables:
            location = glGetUniformLocation(self.program, v)
            self._stack[v] = location

        return self.program

    def use(self):
        &#34;&#34;&#34;Use GLSL Program.
        This method should be called before setting any variables or rendering
        any entities
        &#34;&#34;&#34;
        if not self.program:
            logging.error(&#39;Shader not compiled&#39;)
            return False
        glUseProgram(self.program)
        glEnable(GL_PROGRAM_POINT_SIZE)
        return True

    def end(self):
        &#34;&#34;&#34;Set the active GLSL program to 0
        &#34;&#34;&#34;
        glUseProgram(0)
        glDisable(GL_PROGRAM_POINT_SIZE)

    def set_matrix4x4_np(self, variable, value, transpose=False):
        &#34;&#34;&#34;Set 4x4 Numpy matrix value

        Some elements like Observer and Light can pass their matrices directly
        as numpy array to reduce number of object conversions. This is the
        ideal way if possible.

        If variable not found in `self.variables` then system will try to
        locate the variable location and store it in `self.variables` for
        future reference.

        Args:
          variable: Variable name to set
          value: Matrix to set. (Numpy matrix)
          transpose: Transpose matrix.
        &#34;&#34;&#34;
        transpose = GL_TRUE if transpose else GL_FALSE
        location = self.get_location(variable)
        if not location:
            logging.error(&#39;Variable not found in program [{}]&#39;.format(
                variable))
            return False

        glUniformMatrix4fv(location, 1, transpose,
                           np.asfortranarray(value, dtype=np.float32))
        return True

    def get_location(self, variable):
        if variable in self._stack:
            return self._stack[variable]
        location = glGetUniformLocation(self.program, variable)
        if location == -1:
            return False
        self._stack[variable] = location
        return location

    def set_matrix4x4(self, variable, value, transpose=False):
        &#34;&#34;&#34;Set 4x4 Matrix value

        This method will simply convert `value` into numpy array and call
        `payton.scene.shader.Shader.set_matrix4x4_np` method.

        Args:
          variable: Variable name to set
          value: Matrix to set. (Numpy matrix)
          transpose: Transpose matrix.
        &#34;&#34;&#34;
        self.set_matrix4x4_np(variable,
                              np.array(value, np.float32),
                              transpose)

    def set_vector3_np(self, variable, value):
        &#34;&#34;&#34;Set Vector 3 as numpy array value

        If variable not found in `self.variables` then system will try to
        locate the variable location and store it in `self.variables` for
        future reference.

        Some elements like Light or pre-set materials can pass their
        vertices directly as numpy array to reduce number of object
        conversions.

        Args:
          variable: Variable name to set
          value: Vector 3 to set. (Numpy array with 3 elemenets)
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location &lt; 0:
            logging.error(&#39;Variable not found in program [{}]&#39;.format(
                variable))
            return False
        glUniform3fv(location, 1, value)

    def set_vector4_np(self, variable, value):
        &#34;&#34;&#34;Set Vector 4 as numpy array value

        If variable not found in `self.variables` then system will try to
        locate the variable location and store it in `self.variables` for
        future reference.

        Some elements like Light or pre-set materials can pass their vertices
        directly as numpy array to reduce number of object conversions.

        Args:
          variable: Variable name to set
          value: Vector 4 to set. (Numpy array with 4 elemenets)
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location &lt; 0:
            logging.error(&#39;Variable not found in program [{}]&#39;.format(
                variable))
            return False
        glUniform4fv(location, 1, value)

    def set_vector3(self, variable, value):
        &#34;&#34;&#34;Set Vector 3 as array value
        If variable not found in `self.variables` then system will try to
        locate the variable location and store it in `self.variables` for
        future reference.

        This method will simply convert `value` into numpy array and call
        `payton.scene.shader.Shader.set_vector3_np` method.

        Args:
          variable: Variable name to set
          value: Vector 3 to set. (Numpy array with 3 elemenets)
        &#34;&#34;&#34;
        self.set_vector3_np(variable,
                            np.array(value, dtype=np.float32))

    def set_int(self, variable, value):
        &#34;&#34;&#34;Set Integer value

        If variable not found in `self.variables` then system will try to
        locate the variable location and store it in `self.variables` for
        future reference.

        Args:
          variable: Variable name to set
          value: Integer value to set
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location &lt; 0:
            logging.error(&#39;Variable not found in program [{}]&#39;.format(
                variable))
            return False

        glUniform1i(location, ctypes.c_int(value))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="payton.scene.shader.Shader"><code class="flex name class">
<span>class <span class="ident">Shader</span></span>
</code></dt>
<dd>
<section class="desc"><p>Payton shader class. Creates shaders / programs</p>
<p>For an improved performance, Shader aims to reduce the number of
<code>glGetUniformlocation</code> function calls. For this purpose, <code>__init__</code> and
<code>build</code> functions accept a list of variable names as <code>variables</code> argument.</p>
<p>By this way, Shader goes through this list of variables after compiling the
shader program and stores their locations in memory for future use.</p>
<p>If you provide the list of variable names in build function call then
it will overwrite existing list.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class Shader(object):
    &#34;&#34;&#34;Payton shader class. Creates shaders / programs

    For an improved performance, Shader aims to reduce the number of
    `glGetUniformlocation` function calls. For this purpose, `__init__` and
    `build` functions accept a list of variable names as `variables` argument.

    By this way, Shader goes through this list of variables after compiling the
    shader program and stores their locations in memory for future use.

    If you provide the list of variable names in build function call then
    it will overwrite existing list.
    &#34;&#34;&#34;
    NO_LIGHT_COLOR = 0
    NO_LIGHT_TEXTURE = 1
    LIGHT_COLOR = 2
    LIGHT_TEXTURE = 3

    def __init__(self, **args):
        &#34;&#34;&#34;Initialize Shader.

        Args:
          fragment: Fragment shader code
          vertex: Vertex shader code
          variables: List of in/out/uniform variable names.
        &#34;&#34;&#34;
        global default_fragment_shader, default_vertex_shader
        self.fragment_shader_source = args.get(&#39;fragment&#39;,
                                               default_fragment_shader)
        self.vertex_shader_source = args.get(&#39;vertex&#39;,
                                             default_vertex_shader)
        self.variables = args.get(&#39;variables&#39;, [])
        self._stack = {}  # Variable stack.
        self._mode = self.NO_LIGHT_COLOR  # Lightless color material

        self.program = None

    def build(self, variables=None):
        &#34;&#34;&#34;Build GLSL Shader
        Compile shaders and compile glsl program
        Args:
          variables: List of in/out/uniform variable names.
        Return:
            self.program
        &#34;&#34;&#34;
        vertex_shader = shaders.compileShader(self.vertex_shader_source,
                                              GL_VERTEX_SHADER)
        fragment_shader = shaders.compileShader(self.fragment_shader_source,
                                                GL_FRAGMENT_SHADER)
        self.program = shaders.compileProgram(vertex_shader,
                                              fragment_shader)
        if variables:
            self.variables = variables

        for v in self.variables:
            location = glGetUniformLocation(self.program, v)
            self._stack[v] = location

        return self.program

    def use(self):
        &#34;&#34;&#34;Use GLSL Program.
        This method should be called before setting any variables or rendering
        any entities
        &#34;&#34;&#34;
        if not self.program:
            logging.error(&#39;Shader not compiled&#39;)
            return False
        glUseProgram(self.program)
        glEnable(GL_PROGRAM_POINT_SIZE)
        return True

    def end(self):
        &#34;&#34;&#34;Set the active GLSL program to 0
        &#34;&#34;&#34;
        glUseProgram(0)
        glDisable(GL_PROGRAM_POINT_SIZE)

    def set_matrix4x4_np(self, variable, value, transpose=False):
        &#34;&#34;&#34;Set 4x4 Numpy matrix value

        Some elements like Observer and Light can pass their matrices directly
        as numpy array to reduce number of object conversions. This is the
        ideal way if possible.

        If variable not found in `self.variables` then system will try to
        locate the variable location and store it in `self.variables` for
        future reference.

        Args:
          variable: Variable name to set
          value: Matrix to set. (Numpy matrix)
          transpose: Transpose matrix.
        &#34;&#34;&#34;
        transpose = GL_TRUE if transpose else GL_FALSE
        location = self.get_location(variable)
        if not location:
            logging.error(&#39;Variable not found in program [{}]&#39;.format(
                variable))
            return False

        glUniformMatrix4fv(location, 1, transpose,
                           np.asfortranarray(value, dtype=np.float32))
        return True

    def get_location(self, variable):
        if variable in self._stack:
            return self._stack[variable]
        location = glGetUniformLocation(self.program, variable)
        if location == -1:
            return False
        self._stack[variable] = location
        return location

    def set_matrix4x4(self, variable, value, transpose=False):
        &#34;&#34;&#34;Set 4x4 Matrix value

        This method will simply convert `value` into numpy array and call
        `payton.scene.shader.Shader.set_matrix4x4_np` method.

        Args:
          variable: Variable name to set
          value: Matrix to set. (Numpy matrix)
          transpose: Transpose matrix.
        &#34;&#34;&#34;
        self.set_matrix4x4_np(variable,
                              np.array(value, np.float32),
                              transpose)

    def set_vector3_np(self, variable, value):
        &#34;&#34;&#34;Set Vector 3 as numpy array value

        If variable not found in `self.variables` then system will try to
        locate the variable location and store it in `self.variables` for
        future reference.

        Some elements like Light or pre-set materials can pass their
        vertices directly as numpy array to reduce number of object
        conversions.

        Args:
          variable: Variable name to set
          value: Vector 3 to set. (Numpy array with 3 elemenets)
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location &lt; 0:
            logging.error(&#39;Variable not found in program [{}]&#39;.format(
                variable))
            return False
        glUniform3fv(location, 1, value)

    def set_vector4_np(self, variable, value):
        &#34;&#34;&#34;Set Vector 4 as numpy array value

        If variable not found in `self.variables` then system will try to
        locate the variable location and store it in `self.variables` for
        future reference.

        Some elements like Light or pre-set materials can pass their vertices
        directly as numpy array to reduce number of object conversions.

        Args:
          variable: Variable name to set
          value: Vector 4 to set. (Numpy array with 4 elemenets)
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location &lt; 0:
            logging.error(&#39;Variable not found in program [{}]&#39;.format(
                variable))
            return False
        glUniform4fv(location, 1, value)

    def set_vector3(self, variable, value):
        &#34;&#34;&#34;Set Vector 3 as array value
        If variable not found in `self.variables` then system will try to
        locate the variable location and store it in `self.variables` for
        future reference.

        This method will simply convert `value` into numpy array and call
        `payton.scene.shader.Shader.set_vector3_np` method.

        Args:
          variable: Variable name to set
          value: Vector 3 to set. (Numpy array with 3 elemenets)
        &#34;&#34;&#34;
        self.set_vector3_np(variable,
                            np.array(value, dtype=np.float32))

    def set_int(self, variable, value):
        &#34;&#34;&#34;Set Integer value

        If variable not found in `self.variables` then system will try to
        locate the variable location and store it in `self.variables` for
        future reference.

        Args:
          variable: Variable name to set
          value: Integer value to set
        &#34;&#34;&#34;
        location = self.get_location(variable)
        if location &lt; 0:
            logging.error(&#39;Variable not found in program [{}]&#39;.format(
                variable))
            return False

        glUniform1i(location, ctypes.c_int(value))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="payton.scene.shader.Shader.LIGHT_COLOR"><code class="name">var <span class="ident">LIGHT_COLOR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="payton.scene.shader.Shader.LIGHT_TEXTURE"><code class="name">var <span class="ident">LIGHT_TEXTURE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="payton.scene.shader.Shader.NO_LIGHT_COLOR"><code class="name">var <span class="ident">NO_LIGHT_COLOR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="payton.scene.shader.Shader.NO_LIGHT_TEXTURE"><code class="name">var <span class="ident">NO_LIGHT_TEXTURE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="payton.scene.shader.Shader.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, **args)</span>
</code></dt>
<dd>
<section class="desc"><p>Initialize Shader.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fragment</code></strong></dt>
<dd>Fragment shader code</dd>
<dt><strong><code>vertex</code></strong></dt>
<dd>Vertex shader code</dd>
<dt><strong><code>variables</code></strong></dt>
<dd>List of in/out/uniform variable names.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def __init__(self, **args):
    &#34;&#34;&#34;Initialize Shader.

    Args:
      fragment: Fragment shader code
      vertex: Vertex shader code
      variables: List of in/out/uniform variable names.
    &#34;&#34;&#34;
    global default_fragment_shader, default_vertex_shader
    self.fragment_shader_source = args.get(&#39;fragment&#39;,
                                           default_fragment_shader)
    self.vertex_shader_source = args.get(&#39;vertex&#39;,
                                         default_vertex_shader)
    self.variables = args.get(&#39;variables&#39;, [])
    self._stack = {}  # Variable stack.
    self._mode = self.NO_LIGHT_COLOR  # Lightless color material

    self.program = None</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self, variables=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Build GLSL Shader
Compile shaders and compile glsl program</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variables</code></strong></dt>
<dd>List of in/out/uniform variable names.</dd>
</dl>
<h2 id="return">Return</h2>
<p>self.program</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def build(self, variables=None):
    &#34;&#34;&#34;Build GLSL Shader
    Compile shaders and compile glsl program
    Args:
      variables: List of in/out/uniform variable names.
    Return:
        self.program
    &#34;&#34;&#34;
    vertex_shader = shaders.compileShader(self.vertex_shader_source,
                                          GL_VERTEX_SHADER)
    fragment_shader = shaders.compileShader(self.fragment_shader_source,
                                            GL_FRAGMENT_SHADER)
    self.program = shaders.compileProgram(vertex_shader,
                                          fragment_shader)
    if variables:
        self.variables = variables

    for v in self.variables:
        location = glGetUniformLocation(self.program, v)
        self._stack[v] = location

    return self.program</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Set the active GLSL program to 0</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def end(self):
    &#34;&#34;&#34;Set the active GLSL program to 0
    &#34;&#34;&#34;
    glUseProgram(0)
    glDisable(GL_PROGRAM_POINT_SIZE)</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.get_location"><code class="name flex">
<span>def <span class="ident">get_location</span></span>(<span>self, variable)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def get_location(self, variable):
    if variable in self._stack:
        return self._stack[variable]
    location = glGetUniformLocation(self.program, variable)
    if location == -1:
        return False
    self._stack[variable] = location
    return location</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_int"><code class="name flex">
<span>def <span class="ident">set_int</span></span>(<span>self, variable, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Set Integer value</p>
<p>If variable not found in <code>self.variables</code> then system will try to
locate the variable location and store it in <code>self.variables</code> for
future reference.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Integer value to set</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_int(self, variable, value):
    &#34;&#34;&#34;Set Integer value

    If variable not found in `self.variables` then system will try to
    locate the variable location and store it in `self.variables` for
    future reference.

    Args:
      variable: Variable name to set
      value: Integer value to set
    &#34;&#34;&#34;
    location = self.get_location(variable)
    if location &lt; 0:
        logging.error(&#39;Variable not found in program [{}]&#39;.format(
            variable))
        return False

    glUniform1i(location, ctypes.c_int(value))</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_matrix4x4"><code class="name flex">
<span>def <span class="ident">set_matrix4x4</span></span>(<span>self, variable, value, transpose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Set 4x4 Matrix value</p>
<p>This method will simply convert <code>value</code> into numpy array and call
<a title="payton.scene.shader.Shader.set_matrix4x4_np" href="#payton.scene.shader.Shader.set_matrix4x4_np"><code>Shader.set_matrix4x4_np()</code></a> method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Matrix to set. (Numpy matrix)</dd>
<dt><strong><code>transpose</code></strong></dt>
<dd>Transpose matrix.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_matrix4x4(self, variable, value, transpose=False):
    &#34;&#34;&#34;Set 4x4 Matrix value

    This method will simply convert `value` into numpy array and call
    `payton.scene.shader.Shader.set_matrix4x4_np` method.

    Args:
      variable: Variable name to set
      value: Matrix to set. (Numpy matrix)
      transpose: Transpose matrix.
    &#34;&#34;&#34;
    self.set_matrix4x4_np(variable,
                          np.array(value, np.float32),
                          transpose)</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_matrix4x4_np"><code class="name flex">
<span>def <span class="ident">set_matrix4x4_np</span></span>(<span>self, variable, value, transpose=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Set 4x4 Numpy matrix value</p>
<p>Some elements like Observer and Light can pass their matrices directly
as numpy array to reduce number of object conversions. This is the
ideal way if possible.</p>
<p>If variable not found in <code>self.variables</code> then system will try to
locate the variable location and store it in <code>self.variables</code> for
future reference.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Matrix to set. (Numpy matrix)</dd>
<dt><strong><code>transpose</code></strong></dt>
<dd>Transpose matrix.</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_matrix4x4_np(self, variable, value, transpose=False):
    &#34;&#34;&#34;Set 4x4 Numpy matrix value

    Some elements like Observer and Light can pass their matrices directly
    as numpy array to reduce number of object conversions. This is the
    ideal way if possible.

    If variable not found in `self.variables` then system will try to
    locate the variable location and store it in `self.variables` for
    future reference.

    Args:
      variable: Variable name to set
      value: Matrix to set. (Numpy matrix)
      transpose: Transpose matrix.
    &#34;&#34;&#34;
    transpose = GL_TRUE if transpose else GL_FALSE
    location = self.get_location(variable)
    if not location:
        logging.error(&#39;Variable not found in program [{}]&#39;.format(
            variable))
        return False

    glUniformMatrix4fv(location, 1, transpose,
                       np.asfortranarray(value, dtype=np.float32))
    return True</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_vector3"><code class="name flex">
<span>def <span class="ident">set_vector3</span></span>(<span>self, variable, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Set Vector 3 as array value
If variable not found in <code>self.variables</code> then system will try to
locate the variable location and store it in <code>self.variables</code> for
future reference.</p>
<p>This method will simply convert <code>value</code> into numpy array and call
<a title="payton.scene.shader.Shader.set_vector3_np" href="#payton.scene.shader.Shader.set_vector3_np"><code>Shader.set_vector3_np()</code></a> method.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Vector 3 to set. (Numpy array with 3 elemenets)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_vector3(self, variable, value):
    &#34;&#34;&#34;Set Vector 3 as array value
    If variable not found in `self.variables` then system will try to
    locate the variable location and store it in `self.variables` for
    future reference.

    This method will simply convert `value` into numpy array and call
    `payton.scene.shader.Shader.set_vector3_np` method.

    Args:
      variable: Variable name to set
      value: Vector 3 to set. (Numpy array with 3 elemenets)
    &#34;&#34;&#34;
    self.set_vector3_np(variable,
                        np.array(value, dtype=np.float32))</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_vector3_np"><code class="name flex">
<span>def <span class="ident">set_vector3_np</span></span>(<span>self, variable, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Set Vector 3 as numpy array value</p>
<p>If variable not found in <code>self.variables</code> then system will try to
locate the variable location and store it in <code>self.variables</code> for
future reference.</p>
<p>Some elements like Light or pre-set materials can pass their
vertices directly as numpy array to reduce number of object
conversions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Vector 3 to set. (Numpy array with 3 elemenets)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_vector3_np(self, variable, value):
    &#34;&#34;&#34;Set Vector 3 as numpy array value

    If variable not found in `self.variables` then system will try to
    locate the variable location and store it in `self.variables` for
    future reference.

    Some elements like Light or pre-set materials can pass their
    vertices directly as numpy array to reduce number of object
    conversions.

    Args:
      variable: Variable name to set
      value: Vector 3 to set. (Numpy array with 3 elemenets)
    &#34;&#34;&#34;
    location = self.get_location(variable)
    if location &lt; 0:
        logging.error(&#39;Variable not found in program [{}]&#39;.format(
            variable))
        return False
    glUniform3fv(location, 1, value)</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.set_vector4_np"><code class="name flex">
<span>def <span class="ident">set_vector4_np</span></span>(<span>self, variable, value)</span>
</code></dt>
<dd>
<section class="desc"><p>Set Vector 4 as numpy array value</p>
<p>If variable not found in <code>self.variables</code> then system will try to
locate the variable location and store it in <code>self.variables</code> for
future reference.</p>
<p>Some elements like Light or pre-set materials can pass their vertices
directly as numpy array to reduce number of object conversions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>variable</code></strong></dt>
<dd>Variable name to set</dd>
<dt><strong><code>value</code></strong></dt>
<dd>Vector 4 to set. (Numpy array with 4 elemenets)</dd>
</dl></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def set_vector4_np(self, variable, value):
    &#34;&#34;&#34;Set Vector 4 as numpy array value

    If variable not found in `self.variables` then system will try to
    locate the variable location and store it in `self.variables` for
    future reference.

    Some elements like Light or pre-set materials can pass their vertices
    directly as numpy array to reduce number of object conversions.

    Args:
      variable: Variable name to set
      value: Vector 4 to set. (Numpy array with 4 elemenets)
    &#34;&#34;&#34;
    location = self.get_location(variable)
    if location &lt; 0:
        logging.error(&#39;Variable not found in program [{}]&#39;.format(
            variable))
        return False
    glUniform4fv(location, 1, value)</code></pre>
</details>
</dd>
<dt id="payton.scene.shader.Shader.use"><code class="name flex">
<span>def <span class="ident">use</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Use GLSL Program.
This method should be called before setting any variables or rendering
any entities</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def use(self):
    &#34;&#34;&#34;Use GLSL Program.
    This method should be called before setting any variables or rendering
    any entities
    &#34;&#34;&#34;
    if not self.program:
        logging.error(&#39;Shader not compiled&#39;)
        return False
    glUseProgram(self.program)
    glEnable(GL_PROGRAM_POINT_SIZE)
    return True</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="payton.scene" href="index.html">payton.scene</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="payton.scene.shader.Shader" href="#payton.scene.shader.Shader">Shader</a></code></h4>
<ul class="two-column">
<li><code><a title="payton.scene.shader.Shader.LIGHT_COLOR" href="#payton.scene.shader.Shader.LIGHT_COLOR">LIGHT_COLOR</a></code></li>
<li><code><a title="payton.scene.shader.Shader.LIGHT_TEXTURE" href="#payton.scene.shader.Shader.LIGHT_TEXTURE">LIGHT_TEXTURE</a></code></li>
<li><code><a title="payton.scene.shader.Shader.NO_LIGHT_COLOR" href="#payton.scene.shader.Shader.NO_LIGHT_COLOR">NO_LIGHT_COLOR</a></code></li>
<li><code><a title="payton.scene.shader.Shader.NO_LIGHT_TEXTURE" href="#payton.scene.shader.Shader.NO_LIGHT_TEXTURE">NO_LIGHT_TEXTURE</a></code></li>
<li><code><a title="payton.scene.shader.Shader.__init__" href="#payton.scene.shader.Shader.__init__">__init__</a></code></li>
<li><code><a title="payton.scene.shader.Shader.build" href="#payton.scene.shader.Shader.build">build</a></code></li>
<li><code><a title="payton.scene.shader.Shader.end" href="#payton.scene.shader.Shader.end">end</a></code></li>
<li><code><a title="payton.scene.shader.Shader.get_location" href="#payton.scene.shader.Shader.get_location">get_location</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_int" href="#payton.scene.shader.Shader.set_int">set_int</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_matrix4x4" href="#payton.scene.shader.Shader.set_matrix4x4">set_matrix4x4</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_matrix4x4_np" href="#payton.scene.shader.Shader.set_matrix4x4_np">set_matrix4x4_np</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_vector3" href="#payton.scene.shader.Shader.set_vector3">set_vector3</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_vector3_np" href="#payton.scene.shader.Shader.set_vector3_np">set_vector3_np</a></code></li>
<li><code><a title="payton.scene.shader.Shader.set_vector4_np" href="#payton.scene.shader.Shader.set_vector4_np">set_vector4_np</a></code></li>
<li><code><a title="payton.scene.shader.Shader.use" href="#payton.scene.shader.Shader.use">use</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.5.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>